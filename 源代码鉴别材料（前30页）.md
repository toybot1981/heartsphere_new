# 数字生命体交互系统（心域）V1.0.0 源代码鉴别材料（前30页）

## 第 1 页

**文件路径：frontend/App.tsx**

```typescript

import React, { useState, useEffect, useRef } from 'react';
import { WORLD_SCENES, APP_TITLE } from './constants';
import { ChatWindow } from './components/ChatWindow';
import { ScenarioBuilder } from './components/ScenarioBuilder';
import { SettingsModal } from './components/SettingsModal';
import { CharacterCard } from './components/CharacterCard';
import { SceneCard } from './components/SceneCard';
import { Character, GameState, Message, CustomScenario, AppSettings, WorldScene, JournalEntry, JournalEcho, Mail, EraMemory, DebugLog } from './types';
import { geminiService } from './services/gemini';
import { storageService } from './services/storage';
import { authApi, journalApi, characterApi, scriptApi, worldApi, eraApi, membershipApi } from './services/api';
import { syncService } from './services/syncService';
import { EraConstructorModal } from './components/EraConstructorModal';
import { CharacterConstructorModal } from './components/CharacterConstructorModal';
import { EntryPoint } from './components/EntryPoint';
import { RealWorldScreen } from './components/RealWorldScreen';
import { MailboxModal } from './components/MailboxModal';
import { EraMemoryModal } from './components/EraMemoryModal';
import { Button } from './components/Button';
import { DebugConsole } from './components/DebugConsole';
import { ConnectionSpace } from './components/ConnectionSpace';
import { AdminScreen } from './admin/AdminScreen';
import { LoginModal } from './components/LoginModal';
import { MobileApp } from './mobile/MobileApp';
import { WelcomeOverlay } from './components/WelcomeOverlay';
import { RecycleBinModal } from './components/RecycleBinModal';
import { MembershipModal } from './components/MembershipModal';

const App: React.FC = () => {
  
  // --- 友好的错误提示函数 ---
  const showSyncErrorToast = (operation: string): void => {
    // 创建一个友好的错误提示
    const toast = document.createElement('div');
    toast.className = 'fixed top-4 right-4 z-50 bg-red-600/90 text-white px-6 py-4 rounded-lg shadow-2xl border border-red-400/50 max-w-md animate-fade-in';
    toast.innerHTML = `
      <div class="flex items-start gap-3">
        <div class="text-2xl">⚠️</div>
        <div class="flex-1">
          <div class="font-bold text-lg mb-1">远程同步失败</div>
          <div class="text-sm text-red-100">${operation}已保存到本地，但未能同步到服务器。请检查网络连接后重试。</div>
        </div>
        <button onclick="this.parentElement.parentElement.remove()" class="text-white/70 hover:text-white text-xl leading-none">×</button>
      </div>
    `;
    document.body.appendChild(toast);
    
    // 5秒后自动消失
    setTimeout(() => {
      if (toast.parentElement) {
        toast.style.opacity = '0';
        toast.style.transition = 'opacity 0.3s';
        setTimeout(() => toast.remove(), 300);
      }
    }, 5000);
  };
  
  // --- Device Adaptation & Mode Switching ---
  
  const checkIsMobile = (): boolean => {
    if (typeof window === 'undefined') return false;
    const userAgent = navigator.userAgent || '';
    const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);
    const isSmallScreen = window.innerWidth < 768;
    return isMobileDevice || isSmallScreen;
  };

  const [isMobileMode, setIsMobileMode] = useState(checkIsMobile());

  const EXAMPLE_SCENARIO: CustomScenario = {
      id: 'example_scenario_01',
      sceneId: 'university_era',
      title: '示例剧本：深夜网咖的邂逅',
      description: '在这座城市的霓虹灯下，你走进了一家名为"Binary Beans"的网咖...',
      author: 'System', startNodeId: 'start',
      nodes: {
          'start': { id: 'start', title: '初入网咖', prompt: 'User enters a cyberpunk internet cafe at rainy night. Introduce a mysterious hacker girl (Yuki style) sitting in the corner, looking nervous. The barista asks for the user\'s order.', options: [ { id: 'opt_1', text: '走向那个黑客少女', nextNodeId: 'node_hacker' }, { id: 'opt_2', text: '点一杯咖啡，坐在吧台', nextNodeId: 'node_coffee' } ] },
          'node_hacker': { id: 'node_hacker', title: '黑客的求助', prompt: 'The girl hands over a data chip. "They are watching," she whispers. Suddenly, the cafe lights turn red. Action scene begins.', options: [ { id: 'opt_help', text: '答应帮助她', nextNodeId: 'node_mission_start' }, { id: 'opt_leave', text: '表示对此不感兴趣，离开', nextNodeId: 'start' } ] },
          'node_coffee': { id: 'node_coffee', title: '平静的夜晚', prompt: 'The user sits at the bar. The barista serves a glowing neon coffee. The atmosphere is chill and lo-fi. Nothing dangerous happens, just a conversation.', options: [ { id: 'opt_chat', text: '和咖啡师聊天', nextNodeId: 'node_coffee' }, { id: 'opt_look_around', text: '观察四周', nextNodeId: 'start' } ] },
          'node_mission_start': { id: 'node_mission_start', title: '任务开始', prompt: 'The girl hands over a data chip. "They are watching," she whispers. Suddenly, the cafe lights turn red. Action scene begins.', options: [] }
      }
  };

  // Initial default state
  const DEFAULT_STATE: GameState = {
    currentScreen: 'profileSetup',
    userProfile: null,
    selectedSceneId: null,
    selectedCharacterId: null,
    selectedScenarioId: null,
    tempStoryCharacter: null,
    editingScenarioId: null,
    history: {},
    customAvatars: {},
    generatingAvatarId: null,
    customCharacters: {},
    customScenarios: [EXAMPLE_SCENARIO],
    customScenes: [],
    userWorldScenes: [],
    journalEntries: [],
    activeJournalEntryId: null,
    settings: { 
      autoGenerateAvatars: false, 
      autoGenerateStoryScenes: false,
      autoGenerateJournalImages: false,
      debugMode: false,
      textProvider: 'gemini',
      imageProvider: 'gemini',
      videoProvider: 'gemini',
      audioProvider: 'gemini',
      enableFallback: true,
      geminiConfig: { apiKey: '', modelName: 'gemini-2.5-flash', imageModel: 'gemini-2.5-flash-image', videoModel: 'veo-3.1-fast-generate-preview' },
      openaiConfig: { apiKey: '', baseUrl: 'https://api.openai.com/v1', modelName: 'gpt-4o', imageModel: 'dall-e-3' },
      qwenConfig: { apiKey: 'sk-a486b81e29484fcea112b2c010b7bd95', baseUrl: 'https://dashscope.aliyuncs.com/compatible-mode/v1', modelName: 'qwen-max', imageModel: 'qwen-image-plus', videoModel: 'wanx-video' },
      doubaoConfig: { apiKey: '', baseUrl: 'https://ark.cn-beijing.volces.com/api/v3', modelName: 'ep-...', imageModel: 'doubao-image-v1', videoModel: 'doubao-video-v1' }
    },
    mailbox: [],
    lastLoginTime: Date.now(),
    sceneMemories: {}, 
    debugLogs: [],
    showWelcomeOverlay: false,
    worldStyle: 'anime', // 默认风格为二次元
  };

  const [gameState, setGameState] = useState<GameState>(DEFAULT_STATE);
  const [isLoaded, setIsLoaded] = useState(false); 
  
  const [showSettingsModal, setShowSettingsModal] = useState(false);
  const [showEraCreator, setShowEraCreator] = useState(false);
  const [editingScene, setEditingScene] = useState<WorldScene | null>(null); 
  
  const [showCharacterCreator, setShowCharacterCreator] = useState(false);
  const [editingCharacter, setEditingCharacter] = useState<Character | null>(null);
  const [editingCharacterSceneId, setEditingCharacterSceneId] = useState<string | null>(null);

  const [showMailbox, setShowMailbox] = useState(false);
  
  const [showEraMemory, setShowEraMemory] = useState(false);
  const [memoryScene, setMemoryScene] = useState<WorldScene | null>(null);
  const [showRecycleBin, setShowRecycleBin] = useState(false);
  const [showMembershipModal, setShowMembershipModal] = useState(false);
  const [currentMembership, setCurrentMembership] = useState<any>(null);

  const [profileNickname, setProfileNickname] = useState('');

  const [showLoginModal, setShowLoginModal] = useState(false);
  const pendingActionRef = useRef<() => void>(() => {});

  const hasCheckedMail = useRef(false);
  const hasLoadedEntryPointData = useRef(false);
  
  // Use ref to access current gameState in event listeners without stale closures
  const gameStateRef = useRef(gameState);
  useEffect(() => { gameStateRef.current = gameState; }, [gameState]);

  // --- PERSISTENCE LOGIC ---
  
  const loadGameData = async (): Promise<void> => {
      setIsLoaded(false);
      const loadedState = await storageService.loadState();
      if (loadedState) {
          const savedSettings = (loadedState.settings || {}) as Partial<AppSettings>;
          
          const mergedSettings: AppSettings = {
              ...DEFAULT_STATE.settings,
              ...savedSettings,
              geminiConfig: { ...DEFAULT_STATE.settings.geminiConfig, ...(savedSettings.geminiConfig || {}) },
              openaiConfig: { ...DEFAULT_STATE.settings.openaiConfig, ...(savedSettings.openaiConfig || {}) },
              qwenConfig: { ...DEFAULT_STATE.settings.qwenConfig, ...(savedSettings.qwenConfig || {}) },
              doubaoConfig: { ...DEFAULT_STATE.settings.doubaoConfig, ...(savedSettings.doubaoConfig || {}) },
              autoGenerateAvatars: savedSettings.autoGenerateAvatars ?? DEFAULT_STATE.settings.autoGenerateAvatars,
              autoGenerateStoryScenes: savedSettings.autoGenerateStoryScenes ?? DEFAULT_STATE.settings.autoGenerateStoryScenes,
              autoGenerateJournalImages: savedSettings.autoGenerateJournalImages ?? DEFAULT_STATE.settings.autoGenerateJournalImages,
              textProvider: savedSettings.textProvider || DEFAULT_STATE.settings.textProvider,
              imageProvider: savedSettings.imageProvider || DEFAULT_STATE.settings.imageProvider,
              videoProvider: savedSettings.videoProvider || DEFAULT_STATE.settings.videoProvider,
              audioProvider: savedSettings.audioProvider || DEFAULT_STATE.settings.audioProvider,
              enableFallback: savedSettings.enableFallback ?? DEFAULT_STATE.settings.enableFallback,
          };

          setGameState(prev => ({
            ...prev,
            ...loadedState,
            currentScreen: loadedState.userProfile ? 'entryPoint' : 'profileSetup',
            generatingAvatarId: null,
            activeJournalEntryId: null,
            editingScenarioId: null,
            tempStoryCharacter: null, 
            mailbox: loadedState.mailbox || [],
            lastLoginTime: loadedState.lastLoginTime || Date.now(),
            sceneMemories: loadedState.sceneMemories || {},
            customCharacters: loadedState.customCharacters || {},
            userWorldScenes: loadedState.userWorldScenes || [],
            debugLogs: [], 
            settings: mergedSettings,
            worldStyle: loadedState.worldStyle || 'anime'
          }));
          
          geminiService.updateConfig(mergedSettings);
      }
      setIsLoaded(true);
  };

```

## 第 2 页

**文件路径：frontend/types.ts**

```typescript

// This file includes legacy types like 'Persona' to prevent errors in unused components,
// but the main application logic relies on the 'WorldScene' architecture.
export interface Persona {
  id: string;
  name: string;
  description: string;
  avatarUrl: string;
  eras: Character[];
}

export interface Character {
  id: string;
  name: string;
  age: number;
  era?: string; // Legacy support
  role: string;
  bio: string;
  avatarUrl: string;
  backgroundUrl: string;
  systemInstruction: string;
  themeColor: string;
  colorAccent: string;
  firstMessage: string;
  voiceName: string;

  // --- New Deep Personality Fields ---
  mbti?: string;             // e.g., "INFJ"
  tags?: string[];           // e.g., "Tsundere", "Hacker", "Cat Lover"
  speechStyle?: string;      // e.g., "Short, coded, uses slang"
  catchphrases?: string[];   // e.g., "Interesting.", "Baka!"
  secrets?: string;          // Hidden depth not known to user initially
  motivations?: string;      // Current goal driving the character
  relationships?: string;    // Text description of connections with others
}

export interface Message {
  id:string;
  role: 'user' | 'model';
  text: string;
  image?: string;
  timestamp: number;
}

export interface StoryOption {
  id: string;
  text: string;
  nextNodeId: string;
}

export interface StoryNode {
  id: string;
  title: string;
  prompt: string;
  backgroundHint?: string;
  options: StoryOption[];
}

export interface CustomScenario {
  id: string;
  sceneId: string; // Belongs to a specific scene
  title: string;
  description: string;
  nodes: Record<string, StoryNode>;
  startNodeId: string;
  author: string;
}

export interface EraMemory {
  id: string;
  content: string; // Text memory
  imageUrl?: string; // Optional photo
  timestamp: number;
}

export interface WorldScene {
  id: string;
  name: string;
  description: string;
  imageUrl: string;
  characters: Character[];
  mainStory?: Character;
  memories?: EraMemory[]; // Personal memories specific to this era
  scenes?: any[]; // Scenes for this era
  worldId?: number; // Associated world ID
}

export type AIProvider = 'gemini' | 'openai' | 'qwen' | 'doubao';

// 世界风格类型
export type WorldStyle = 'anime' | 'realistic' | 'cyberpunk' | 'fantasy' | 'steampunk' | 'minimalist' | 'watercolor' | 'oil-painting';

// 风格描述映射
export const WORLD_STYLE_DESCRIPTIONS: Record<WorldStyle, { name: string; description: string; promptSuffix: string }> = {
  anime: {
    name: '二次元',
    description: '现代中国动漫风格，充满活力的色彩和细腻的表情',
    promptSuffix: 'Style: Modern Chinese Anime (Manhua), vibrant colors, detailed eyes, expressive emotions, cinematic lighting.'
  },
  realistic: {
    name: '写实风格',
    description: '高度写实的照片级渲染，真实的光影和质感',
    promptSuffix: 'Style: Photorealistic, highly detailed, realistic lighting and textures, professional photography quality.'
  },
  cyberpunk: {
    name: '赛博朋克',
    description: '赛博朋克未来主义，霓虹灯、科技感、暗黑美学',
    promptSuffix: 'Style: Cyberpunk, neon lights, futuristic technology, dark aesthetic, Blade Runner inspired, high-tech low-life atmosphere.'
  },
  fantasy: {
    name: '奇幻风格',
    description: '魔幻世界，魔法元素，史诗般的场景',
    promptSuffix: 'Style: Fantasy art, magical elements, epic scenes, mystical atmosphere, high fantasy aesthetic, detailed world-building.'
  },
  steampunk: {
    name: '蒸汽朋克',
    description: '维多利亚时代与蒸汽机械的完美结合',
    promptSuffix: 'Style: Steampunk, Victorian era aesthetics, brass and copper machinery, gears and cogs, retro-futuristic technology.'
  },
  minimalist: {
    name: '极简主义',
    description: '简洁优雅，留白艺术，现代设计',
    promptSuffix: 'Style: Minimalist, clean lines, elegant simplicity, modern design, ample white space, refined aesthetics.'
  },
  'watercolor': {
    name: '水彩画风',
    description: '柔和的水彩笔触，梦幻的色彩渐变',
    promptSuffix: 'Style: Watercolor painting, soft brushstrokes, dreamy color gradients, artistic and ethereal, flowing pigments.'
  },
  'oil-painting': {
    name: '油画风格',
    description: '古典油画质感，丰富的笔触和层次',
    promptSuffix: 'Style: Oil painting, classical art, rich brushstrokes and texture, Renaissance or Baroque inspired, artistic depth.'
  }
};

export interface ModelConfig {
  apiKey: string;
  baseUrl?: string; // Optional for custom endpoints
  modelName: string;      // Text Model
  imageModel?: string;    // Image Generation Model
  videoModel?: string;     // Video Generation Model
}

export interface AppSettings {
  autoGenerateAvatars: boolean;
  autoGenerateStoryScenes: boolean;
  autoGenerateJournalImages: boolean; // New setting for journal
  debugMode: boolean; 
  
  // Modality Routing Settings
  textProvider: AIProvider;
  imageProvider: AIProvider;
  videoProvider: AIProvider; // New Video Support
  audioProvider: AIProvider;
  enableFallback: boolean; // If true, try other providers on error

  // Provider Configurations
  geminiConfig: ModelConfig;
  openaiConfig: ModelConfig;
  qwenConfig: ModelConfig;
  doubaoConfig: ModelConfig;
}

export interface UserProfile {
  id?: string;
  nickname: string;
  avatarUrl: string;
  phoneNumber?: string;
  isGuest: boolean; // True if not logged in/registered
}

export interface JournalEcho {
  characterName: string;
  text: string;
  timestamp: number;
  imageUrl?: string; 
}

export interface JournalEntry {
  id: string;
  title: string;
  content: string;
  timestamp: number;
  imageUrl?: string; // Mind Projection
  echo?: JournalEcho; // Echoes of Wisdom
  insight?: string; // Mirror of Truth (本我镜像)
  tags?: string; // 标签（逗号分隔，如：#灵感,#梦境,#工作）
}

export interface Mail {
  id: string;
  senderId: string;
  senderName: string;
  senderAvatarUrl: string;
  subject: string;
  content: string;
  timestamp: number;
  isRead: boolean;
  themeColor: string;
}

// Debug Logging Structure
export interface DebugLog {
  id: string;
  timestamp: number;
  provider: string;
  model?: string; // Specific model name used
  method: string;
  type: string;
  data: any;
}

export interface GameState {
  currentScreen: 'profileSetup' | 'entryPoint' | 'realWorld' | 'sceneSelection' | 'characterSelection' | 'chat' | 'builder' | 'connectionSpace' | 'admin' | 'mobileProfile';
  userProfile: UserProfile | null;
  selectedSceneId: string | null;
  selectedCharacterId: string | null;
  selectedScenarioId: string | null;
  
  // New field to hold the temporary narrator character for scenarios
  tempStoryCharacter: Character | null;

  editingScenarioId: string | null;
  history: Record<string, Message[]>; 
  customAvatars: Record<string, string>; 
  generatingAvatarId: string | null; 
  
  // Custom characters added to scenes (Map: sceneId -> Character[])
  customCharacters: Record<string, Character[]>;

  customScenarios: CustomScenario[];
  customScenes: WorldScene[];
  userWorldScenes: WorldScene[]; // 用户从后端获取的世界场景
  journalEntries: JournalEntry[];
  activeJournalEntryId: string | null; // Track which entry is currently being "explored"
  currentScenarioState?: {
    scenarioId: string;
    currentNodeId: string;
  };
  settings: AppSettings;
  mailbox: Mail[]; // Chronos Mailbox
  lastLoginTime: number; // For tracking offline duration
  sceneMemories: Record<string, EraMemory[]>; // Map sceneId -> memories
  
  debugLogs: DebugLog[]; // Store runtime logs
  showWelcomeOverlay: boolean; // 是否显示首次登录欢迎蒙层
  worldStyle: WorldStyle; // 当前世界风格设定
}

```

## 第 3 页

**文件路径：backend/src/main/java/com/heartsphere/HeartSphereApplication.java**

```java
package com.heartsphere;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class HeartSphereApplication {

    public static void main(String[] args) {
        SpringApplication.run(HeartSphereApplication.class, args);
    }

}
```

**文件路径：backend/src/main/java/com/heartsphere/entity/User.java**

```java
package com.heartsphere.entity;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;

@Data
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String username;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false)
    private String password;

    @Column(name = "wechat_openid", unique = true)
    private String wechatOpenid;

    @Column(name = "nickname")
    private String nickname;

    @Column(name = "avatar")
    private String avatar;

    @Column(name = "is_enabled", nullable = false)
    private Boolean isEnabled = true;

    @Column(name = "created_at")
    @CreationTimestamp
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    @UpdateTimestamp
    private LocalDateTime updatedAt;
}
```

**文件路径：backend/src/main/java/com/heartsphere/entity/World.java**

```java
package com.heartsphere.entity;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;

@Data
@Entity
@Table(name = "worlds")
public class World {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(columnDefinition = "TEXT")
    private String description;

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Column(name = "created_at")
    @CreationTimestamp
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    @UpdateTimestamp
    private LocalDateTime updatedAt;
    
    // 冗余字段，用于Spring Data JPA的findByUserId查询
    @Column(name = "user_id", insertable = false, updatable = false)
    private Long userId;

    @Column(name = "is_deleted", nullable = false)
    private Boolean isDeleted = false;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;
}
```

**文件路径：backend/src/main/java/com/heartsphere/entity/Era.java**

```java
package com.heartsphere.entity;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;

@Data
@Entity
@Table(name = "eras")
public class Era {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Column(name = "start_year")
    private Integer startYear;

    @Column(name = "end_year")
    private Integer endYear;

    @Column(name = "image_url", columnDefinition = "TEXT")
    private String imageUrl;

    @ManyToOne
    @JoinColumn(name = "world_id", nullable = false)
    private World world;

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Column(name = "created_at")
    @CreationTimestamp
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    @UpdateTimestamp
    private LocalDateTime updatedAt;

    @Column(name = "is_deleted", nullable = false)
    private Boolean isDeleted = false;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;
}
```

## 第 4 页

**文件路径：backend/src/main/java/com/heartsphere/entity/Character.java**

```java
package com.heartsphere.entity;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;
import org.springframework.data.annotation.Transient;

import java.time.LocalDateTime;

@Data
@Entity
@Table(name = "characters")
public class Character {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Column(name = "age")
    private Integer age;

    @Column(name = "gender")
    private String gender;

    @Column(name = "role")
    private String role;

    @Column(name = "bio", columnDefinition = "TEXT")
    private String bio;

    @Column(name = "avatar_url")
    private String avatarUrl;

    @Column(name = "background_url")
    private String backgroundUrl;

    @Column(name = "theme_color")
    private String themeColor;

    @Column(name = "color_accent")
    private String colorAccent;

    @Column(name = "first_message")
    private String firstMessage;

    @Column(name = "system_instruction", columnDefinition = "TEXT")
    private String systemInstruction;

    @Column(name = "voice_name")
    private String voiceName;

    @Column(name = "mbti")
    private String mbti;

    @Column(name = "tags")
    private String tags;

    @Column(name = "speech_style")
    private String speechStyle;

    @Column(name = "catchphrases")
    private String catchphrases;

    @Column(name = "secrets", columnDefinition = "TEXT")
    private String secrets;

    @Column(name = "motivations", columnDefinition = "TEXT")
    private String motivations;

    @Column(name = "relationships", columnDefinition = "TEXT")
    private String relationships;

    @ManyToOne
    @JoinColumn(name = "world_id", nullable = false)
    private World world;

    @ManyToOne
    @JoinColumn(name = "era_id")
    private Era era;

    // 为前端提供worldId字段
    @Transient
    public Long getWorldId() {
        return world != null ? world.getId() : null;
    }

    // 为前端提供eraId字段
    @Transient
    public Long getEraId() {
        return era != null ? era.getId() : null;
    }

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Column(name = "created_at")
    @CreationTimestamp
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    @UpdateTimestamp
    private LocalDateTime updatedAt;

    @Column(name = "is_deleted", nullable = false)
    private Boolean isDeleted = false;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;
}
```

## 第 5 页

**文件路径：backend/src/main/java/com/heartsphere/controller/AuthController.java**

```java
package com.heartsphere.controller;

import com.heartsphere.dto.AuthResponse;
import com.heartsphere.dto.LoginRequest;
import com.heartsphere.dto.RegisterRequest;
import com.heartsphere.dto.WorldDTO;
import com.heartsphere.entity.User;
import com.heartsphere.repository.UserRepository;
import com.heartsphere.entity.World;
import com.heartsphere.repository.WorldRepository;
import java.util.List;
import java.util.stream.Collectors;
import com.heartsphere.security.UserDetailsImpl;
import com.heartsphere.service.InitializationService;
import com.heartsphere.utils.JwtUtils;
import com.heartsphere.utils.DTOMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.*;

import java.util.Map;
import java.util.HashMap;

@CrossOrigin(origins = "*")
@RestController
@RequestMapping("/api/auth")
public class AuthController {

    @Autowired
    AuthenticationManager authenticationManager;

    @Autowired
    UserRepository userRepository;

    @Autowired
    PasswordEncoder encoder;

    @Autowired
    JwtUtils jwtUtils;

    @Autowired
    InitializationService initializationService;

    @Autowired
    WorldRepository worldRepository;

    @Autowired
    com.heartsphere.admin.service.InviteCodeService inviteCodeService;

    @Autowired
    com.heartsphere.admin.service.SystemConfigService systemConfigService;

    @PostMapping("/login")
    public ResponseEntity<?> authenticateUser(@RequestBody LoginRequest loginRequest) {
        try {
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(loginRequest.getUsername(), loginRequest.getPassword()));

            SecurityContextHolder.getContext().setAuthentication(authentication);
            String jwt = jwtUtils.generateJwtToken(authentication);

            UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
            User user = userRepository.findByUsername(userDetails.getUsername()).orElseThrow();

            // 查询用户的世界，若为空则初始化，再次查询以返回最新数据
            List<World> userWorlds = worldRepository.findByUserId(user.getId());
            boolean isFirstLogin = userWorlds.isEmpty();
            if (isFirstLogin) {
                try {
                    initializationService.initializeUserData(user);
                    userWorlds = worldRepository.findByUserId(user.getId());
                } catch (Exception e) {
                    // 初始化失败不影响登录，记录日志即可
                    java.util.logging.Logger.getLogger(AuthController.class.getName())
                        .warning("用户数据初始化失败: " + e.getMessage());
                    e.printStackTrace();
                }
            }

            // 返回登录响应，包含首次登录标识
            Map<String, Object> resp = new HashMap<>();
            resp.put("token", jwt);
            resp.put("id", user.getId());
            resp.put("username", user.getUsername());
            resp.put("email", user.getEmail());
            resp.put("nickname", user.getNickname());
            resp.put("avatar", user.getAvatar()); // 允许为 null
            resp.put("isFirstLogin", isFirstLogin);
            
            // 转换为DTO列表，确保没有循环引用
            // 手动构建简单的DTO，将 LocalDateTime 转换为字符串
            List<Map<String, Object>> worldDTOs = new java.util.ArrayList<>();
            for (World world : userWorlds) {
                try {
                    Map<String, Object> worldMap = new HashMap<>();
                    worldMap.put("id", world.getId());
                    worldMap.put("name", world.getName());
                    worldMap.put("description", world.getDescription());
                    worldMap.put("userId", world.getUserId());
                    // 将 LocalDateTime 转换为字符串
                    worldMap.put("createdAt", world.getCreatedAt() != null ? world.getCreatedAt().toString() : null);
                    worldMap.put("updatedAt", world.getUpdatedAt() != null ? world.getUpdatedAt().toString() : null);
                    worldDTOs.add(worldMap);
                } catch (Exception e) {
                    // 跳过有问题的世界
                    java.util.logging.Logger.getLogger(AuthController.class.getName())
                        .warning("世界序列化失败: " + e.getMessage());
                }
            }
            resp.put("worlds", worldDTOs);
            
            return ResponseEntity.ok(resp);
        } catch (org.springframework.security.core.AuthenticationException e) {
            // 认证异常（用户名或密码错误）
            return ResponseEntity
                    .status(401)
                    .body(Map.of("message", "用户名或密码错误"));
        } catch (Exception e) {
            // 其他异常，记录日志并返回错误信息
            java.util.logging.Logger.getLogger(AuthController.class.getName())
                .severe("登录异常: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity
                    .status(500)
                    .body(Map.of("message", "登录失败: " + e.getMessage()));
        }
    }
```

由于文档会很长，我将继续创建包含更多源代码的文档。让我创建一个更完整的版本，包含前30页和后30页的源代码。
<｜tool▁calls▁begin｜><｜tool▁call▁begin｜>
read_file