# 阶段五：记忆系统优化

**文档版本**: V1.0  
**编写日期**: 2025-12-28  
**阶段目标**: 性能优化、记忆衰减、系统稳定性提升  
**预计周期**: 4-6周

---

## 一、阶段目标

### 1.1 核心目标

1. ✅ 实现记忆衰减机制
2. ✅ 实现记忆压缩和归档
3. ✅ 性能优化（缓存、索引、查询优化）
4. ✅ 监控和诊断系统
5. ✅ 系统稳定性提升

### 1.2 成功标准

- 记忆检索性能提升 50%以上
- 存储空间节省 30%以上
- 系统可用性 > 99.9%
- 平均响应时间 < 100ms
- 支持百万级用户

---

## 二、优化需求

### 2.1 性能优化

- **缓存策略**：常用记忆的缓存
- **索引优化**：MongoDB索引优化
- **查询优化**：查询语句优化
- **批量操作**：批量读写优化

### 2.2 存储优化

- **记忆压缩**：压缩低频访问的记忆
- **记忆归档**：归档长期未使用的记忆
- **数据清理**：清理过期和无效记忆
- **存储分层**：热数据和冷数据分层存储

### 2.3 记忆衰减

- **时间衰减**：基于时间的记忆重要性衰减
- **访问衰减**：基于访问频率的衰减
- **自动清理**：自动清理低重要性记忆

### 2.4 监控和诊断

- **性能监控**：监控系统性能指标
- **错误监控**：监控系统错误
- **使用统计**：统计系统使用情况
- **诊断工具**：系统诊断工具

---

## 三、技术方案

### 3.1 缓存策略

#### 3.1.1 多级缓存

```
L1缓存（内存）：热点记忆，TTL 5分钟
  ↓
L2缓存（Redis）：常用记忆，TTL 1小时
  ↓
L3存储（MongoDB）：所有记忆
```

#### 3.1.2 缓存实现

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class CachedMemoryService {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private final MemoryService memoryService;
    
    // 本地缓存（Caffeine）
    private final Cache<String, Memory> localCache = Caffeine.newBuilder()
        .maximumSize(1000)
        .expireAfterWrite(5, TimeUnit.MINUTES)
        .build();
    
    public Memory getMemory(String memoryId) {
        // 1. 先查本地缓存
        Memory memory = localCache.getIfPresent(memoryId);
        if (memory != null) {
            return memory;
        }
        
        // 2. 查Redis缓存
        String redisKey = "memory:" + memoryId;
        memory = (Memory) redisTemplate.opsForValue().get(redisKey);
        if (memory != null) {
            localCache.put(memoryId, memory);
            return memory;
        }
        
        // 3. 查数据库
        memory = memoryService.getMemory(memoryId);
        if (memory != null) {
            // 写入缓存
            redisTemplate.opsForValue().set(redisKey, memory, 1, TimeUnit.HOURS);
            localCache.put(memoryId, memory);
        }
        
        return memory;
    }
}
```

### 3.2 记忆衰减机制

#### 3.2.1 衰减模型

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class MemoryDecayService {
    
    /**
     * 计算衰减后的重要性
     */
    public double calculateDecayedImportance(Memory memory) {
        double baseImportance = memory.getImportance().getValue();
        
        // 1. 时间衰减
        double timeDecay = calculateTimeDecay(memory);
        
        // 2. 访问衰减
        double accessDecay = calculateAccessDecay(memory);
        
        // 3. 综合衰减
        double decayedImportance = baseImportance * (1 - timeDecay) * (1 - accessDecay);
        
        // 4. 最低保护（核心记忆不受衰减影响）
        if (memory.getImportance() == MemoryImportance.CORE) {
            return Math.max(decayedImportance, 0.8);
        }
        
        return Math.max(0, decayedImportance);
    }
    
    private double calculateTimeDecay(Memory memory) {
        if (memory.getLastAccessedAt() == null) {
            return 0.0;
        }
        
        long daysSince = Duration.between(
            memory.getLastAccessedAt(), Instant.now()).toDays();
        
        // 指数衰减：30天衰减一半
        return 1 - Math.exp(-daysSince / 30.0);
    }
    
    private double calculateAccessDecay(Memory memory) {
        if (memory.getAccessCount() == null || memory.getAccessCount() == 0) {
            return 0.1; // 未访问的记忆衰减10%
        }
        
        // 访问频率越高，衰减越小
        double frequencyScore = Math.log(1 + memory.getAccessCount()) / 10.0;
        return Math.max(0, 0.1 - frequencyScore);
    }
    
    /**
     * 批量更新记忆衰减
     */
    @Scheduled(cron = "0 0 3 * * ?") // 每天凌晨3点执行
    public void batchUpdateDecay() {
        log.info("开始批量更新记忆衰减");
        
        // 1. 获取所有需要更新的记忆
        List<Memory> memories = memoryService.getAllMemories();
        
        int updatedCount = 0;
        for (Memory memory : memories) {
            double decayedImportance = calculateDecayedImportance(memory);
            
            // 2. 如果衰减后重要性过低，标记为归档
            if (decayedImportance < 0.1 && 
                memory.getImportance() != MemoryImportance.CORE) {
                memoryService.archiveMemory(memory.getId());
                updatedCount++;
            } else {
                // 3. 更新记忆的重要性
                memory.setDecayedImportance(decayedImportance);
                memoryService.updateMemory(memory);
                updatedCount++;
            }
        }
        
        log.info("批量更新记忆衰减完成，更新数量: {}", updatedCount);
    }
}
```

### 3.3 记忆压缩和归档

#### 3.3.1 压缩策略

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class MemoryCompressionService {
    
    private final AIService aiService;
    
    /**
     * 压缩记忆内容
     */
    public String compressMemory(Memory memory) {
        String originalContent = memory.getContent();
        
        // 如果内容较短，不压缩
        if (originalContent.length() < 200) {
            return originalContent;
        }
        
        // 使用LLM压缩内容
        String prompt = String.format("""
            请将以下记忆内容压缩为更简洁的形式，保留关键信息：
            
            原始内容：
            %s
            
            要求：
            1. 保留所有重要信息
            2. 压缩到原始长度的50%%左右
            3. 保持语义完整
            """, originalContent);
        
        return aiService.generateText(prompt);
    }
    
    /**
     * 批量压缩低频记忆
     */
    @Scheduled(cron = "0 0 4 * * ?") // 每天凌晨4点执行
    public void batchCompressLowFrequencyMemories() {
        log.info("开始批量压缩低频记忆");
        
        // 1. 获取低频记忆（访问次数 < 5，且超过30天未访问）
        Instant thresholdDate = Instant.now().minus(30, ChronoUnit.DAYS);
        List<Memory> lowFrequencyMemories = memoryService.findLowFrequencyMemories(
            5, thresholdDate);
        
        int compressedCount = 0;
        for (Memory memory : lowFrequencyMemories) {
            try {
                String compressedContent = compressMemory(memory);
                memory.setContent(compressedContent);
                memory.setCompressed(true);
                memoryService.updateMemory(memory);
                compressedCount++;
            } catch (Exception e) {
                log.error("压缩记忆失败: memoryId={}", memory.getId(), e);
            }
        }
        
        log.info("批量压缩低频记忆完成，压缩数量: {}", compressedCount);
    }
}
```

#### 3.3.2 归档策略

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class MemoryArchiveService {
    
    /**
     * 归档记忆
     */
    public void archiveMemory(String memoryId) {
        Memory memory = memoryService.getMemory(memoryId);
        if (memory == null) {
            return;
        }
        
        // 1. 创建归档记录
        ArchivedMemory archivedMemory = new ArchivedMemory();
        archivedMemory.setMemoryId(memoryId);
        archivedMemory.setOriginalMemory(memory);
        archivedMemory.setArchivedAt(Instant.now());
        archivedMemory.setReason("自动归档：低重要性");
        
        // 2. 保存归档记录
        archiveRepository.save(archivedMemory);
        
        // 3. 从主存储中删除（或标记为归档）
        memory.setStatus(MemoryStatus.ARCHIVED);
        memoryService.updateMemory(memory);
        
        log.info("记忆已归档: memoryId={}", memoryId);
    }
    
    /**
     * 恢复归档记忆
     */
    public void restoreArchivedMemory(String memoryId) {
        ArchivedMemory archivedMemory = archiveRepository.findByMemoryId(memoryId);
        if (archivedMemory == null) {
            return;
        }
        
        // 1. 恢复记忆
        Memory memory = archivedMemory.getOriginalMemory();
        memory.setStatus(MemoryStatus.ACTIVE);
        memoryService.saveMemory(memory);
        
        // 2. 删除归档记录
        archiveRepository.delete(archivedMemory);
        
        log.info("归档记忆已恢复: memoryId={}", memoryId);
    }
    
    /**
     * 清理长期归档记忆（超过1年）
     */
    @Scheduled(cron = "0 0 5 * * ?") // 每天凌晨5点执行
    public void cleanupOldArchivedMemories() {
        log.info("开始清理长期归档记忆");
        
        Instant thresholdDate = Instant.now().minus(365, ChronoUnit.DAYS);
        List<ArchivedMemory> oldArchives = archiveRepository.findByArchivedAtBefore(
            thresholdDate);
        
        int deletedCount = 0;
        for (ArchivedMemory archive : oldArchives) {
            archiveRepository.delete(archive);
            deletedCount++;
        }
        
        log.info("清理长期归档记忆完成，删除数量: {}", deletedCount);
    }
}
```

### 3.4 索引优化

#### 3.4.1 MongoDB索引策略

```javascript
// user_memories集合索引
db.user_memories.createIndex({ userId: 1, type: 1, importance: -1 });
db.user_memories.createIndex({ userId: 1, lastAccessedAt: -1 });
db.user_memories.createIndex({ userId: 1, createdAt: -1 });
db.user_memories.createIndex({ content: "text" });
db.user_memories.createIndex({ tags: 1 });

// character_memories集合索引
db.character_memories.createIndex({ characterId: 1, userId: 1, eraId: 1 });
db.character_memories.createIndex({ characterId: 1, type: 1 });
db.character_memories.createIndex({ interactionTime: -1 });

// memory_associations集合索引
db.memory_associations.createIndex({ fromMemoryId: 1, toMemoryId: 1 }, { unique: true });
db.memory_associations.createIndex({ fromMemoryId: 1, strength: -1 });
db.memory_associations.createIndex({ userId: 1, type: 1 });

// 复合索引优化查询
db.user_memories.createIndex({ 
  userId: 1, 
  type: 1, 
  importance: -1, 
  lastAccessedAt: -1 
});
```

### 3.5 查询优化

#### 3.5.1 查询优化策略

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class OptimizedMemoryRetrievalService {
    
    /**
     * 优化后的记忆检索
     */
    public List<Memory> retrieveMemoriesOptimized(
            String userId, String query, int limit) {
        
        // 1. 先尝试从缓存获取
        String cacheKey = "retrieve:" + userId + ":" + query;
        List<Memory> cached = (List<Memory>) redisTemplate.opsForValue().get(cacheKey);
        if (cached != null) {
            return cached.stream().limit(limit).collect(Collectors.toList());
        }
        
        // 2. 构建优化查询
        Query mongoQuery = buildOptimizedQuery(userId, query);
        mongoQuery.limit(limit * 2); // 多查询一些，用于后续过滤
        
        // 3. 执行查询
        List<Memory> memories = mongoTemplate.find(mongoQuery, Memory.class);
        
        // 4. 计算相关性并排序
        memories = memories.stream()
            .map(memory -> {
                double relevance = calculateRelevance(memory, query);
                memory.setRelevance(relevance);
                return memory;
            })
            .sorted(Comparator.comparing(Memory::getRelevance).reversed())
            .limit(limit)
            .collect(Collectors.toList());
        
        // 5. 缓存结果（5分钟）
        redisTemplate.opsForValue().set(cacheKey, memories, 5, TimeUnit.MINUTES);
        
        return memories;
    }
    
    private Query buildOptimizedQuery(String userId, String query) {
        Query mongoQuery = new Query();
        
        // 使用索引优化查询
        mongoQuery.addCriteria(Criteria.where("userId").is(userId));
        
        // 如果查询词较少，使用文本搜索
        if (query.split("\\s+").length <= 3) {
            TextCriteria textCriteria = TextCriteria.forDefaultLanguage()
                .matchingAny(query);
            mongoQuery.addCriteria(textCriteria);
        } else {
            // 否则使用正则表达式
            Pattern pattern = Pattern.compile(query, Pattern.CASE_INSENSITIVE);
            mongoQuery.addCriteria(Criteria.where("content").regex(pattern));
        }
        
        // 只查询活跃的记忆
        mongoQuery.addCriteria(Criteria.where("status").is(MemoryStatus.ACTIVE));
        
        // 使用索引排序
        mongoQuery.with(Sort.by(
            Sort.Direction.DESC, "importance",
            Sort.Direction.DESC, "lastAccessedAt"
        ));
        
        return mongoQuery;
    }
}
```

### 3.6 监控和诊断

#### 3.6.1 性能监控

```java
@Component
@Slf4j
public class MemorySystemMetrics {
    
    private final MeterRegistry meterRegistry;
    
    // 指标定义
    private final Counter memoryReadCounter;
    private final Counter memoryWriteCounter;
    private final Timer memoryReadTimer;
    private final Timer memoryWriteTimer;
    private final Gauge memoryCountGauge;
    
    public MemorySystemMetrics(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        
        this.memoryReadCounter = Counter.builder("memory.read.count")
            .description("记忆读取次数")
            .register(meterRegistry);
        
        this.memoryWriteCounter = Counter.builder("memory.write.count")
            .description("记忆写入次数")
            .register(meterRegistry);
        
        this.memoryReadTimer = Timer.builder("memory.read.duration")
            .description("记忆读取耗时")
            .register(meterRegistry);
        
        this.memoryWriteTimer = Timer.builder("memory.write.duration")
            .description("记忆写入耗时")
            .register(meterRegistry);
    }
    
    public void recordMemoryRead(long durationMs) {
        memoryReadCounter.increment();
        memoryReadTimer.record(durationMs, TimeUnit.MILLISECONDS);
    }
    
    public void recordMemoryWrite(long durationMs) {
        memoryWriteCounter.increment();
        memoryWriteTimer.record(durationMs, TimeUnit.MILLISECONDS);
    }
}
```

#### 3.6.2 诊断工具

```java
@RestController
@RequestMapping("/api/memory/admin")
@RequiredArgsConstructor
@Slf4j
public class MemorySystemDiagnosticsController {
    
    private final MemoryService memoryService;
    private final MemorySystemMetrics metrics;
    
    @GetMapping("/health")
    public Map<String, Object> healthCheck() {
        Map<String, Object> health = new HashMap<>();
        
        try {
            // 1. 检查数据库连接
            health.put("database", checkDatabase());
            
            // 2. 检查Redis连接
            health.put("redis", checkRedis());
            
            // 3. 检查系统指标
            health.put("metrics", getSystemMetrics());
            
            health.put("status", "healthy");
        } catch (Exception e) {
            health.put("status", "unhealthy");
            health.put("error", e.getMessage());
        }
        
        return health;
    }
    
    @GetMapping("/stats")
    public Map<String, Object> getStatistics() {
        Map<String, Object> stats = new HashMap<>();
        
        stats.put("totalMemories", memoryService.getTotalMemoryCount());
        stats.put("activeMemories", memoryService.getActiveMemoryCount());
        stats.put("archivedMemories", memoryService.getArchivedMemoryCount());
        stats.put("averageImportance", memoryService.getAverageImportance());
        
        return stats;
    }
}
```

---

## 四、实施计划

### 4.1 第一阶段：缓存优化（1-2周）

- 实现多级缓存
- 缓存预热策略
- 缓存失效策略
- 性能测试

### 4.2 第二阶段：衰减和归档（2-3周）

- 实现记忆衰减机制
- 实现记忆压缩
- 实现记忆归档
- 自动化任务调度

### 4.3 第三阶段：索引和查询优化（1-2周）

- MongoDB索引优化
- 查询语句优化
- 批量操作优化
- 性能测试

### 4.4 第四阶段：监控和诊断（1周）

- 性能监控实现
- 诊断工具开发
- 监控仪表板
- 文档编写

---

## 五、交付清单

### 5.1 代码交付

- [ ] 缓存服务实现
- [ ] 记忆衰减服务
- [ ] 记忆压缩服务
- [ ] 记忆归档服务
- [ ] 查询优化服务
- [ ] 监控和诊断工具

### 5.2 文档交付

- [ ] 性能优化报告
- [ ] 监控和诊断文档
- [ ] 运维文档
- [ ] 最佳实践文档

---

## 六、性能目标

### 6.1 响应时间

- 记忆读取：< 50ms（缓存命中）/< 100ms（缓存未命中）
- 记忆写入：< 100ms
- 记忆检索：< 150ms
- 批量操作：< 500ms

### 6.2 吞吐量

- 记忆读取：> 10000 ops/s
- 记忆写入：> 5000 ops/s
- 记忆检索：> 2000 ops/s

### 6.3 存储

- 存储空间节省：> 30%
- 归档率：< 20%
- 压缩率：> 50%

---

## 七、总结

阶段五的主要目标是：

1. ✅ **性能优化**：通过缓存、索引、查询优化提升系统性能
2. ✅ **存储优化**：通过压缩、归档减少存储空间
3. ✅ **记忆衰减**：实现智能的记忆衰减机制
4. ✅ **监控诊断**：建立完善的监控和诊断系统

通过这些优化，记忆系统将达到生产级别的性能和稳定性要求。



