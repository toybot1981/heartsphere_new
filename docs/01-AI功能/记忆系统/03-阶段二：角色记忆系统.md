# 阶段二：角色记忆系统

**文档版本**: V1.0  
**编写日期**: 2025-12-28  
**阶段目标**: 让心域的E-SOUL角色具备独立的记忆能力  
**预计周期**: 4-6周

---

## 一、阶段目标

### 1.1 核心目标

1. ✅ 实现角色记忆模型和数据存储
2. ✅ 实现角色与用户的交互记忆
3. ✅ 实现角色场景记忆（不同场景切片中的记忆）
4. ✅ 实现角色关系记忆（角色与其他角色的关系）
5. ✅ 实现角色记忆检索和更新API

### 1.2 成功标准

- 每个角色拥有独立的记忆体系
- 角色能够记住与用户的交互历史
- 角色在不同场景中的记忆正确隔离
- 角色关系网络构建完整
- API接口覆盖角色记忆的所有功能
- 性能满足要求（检索延迟 < 150ms）

---

## 二、需求分析

### 2.1 角色记忆需求

#### 2.1.1 角色自身记忆

每个E-SOUL角色应该拥有：
- **角色背景记忆**：角色的基本信息、性格、经历等
- **角色性格记忆**：角色的性格特点、行为模式等
- **角色经历记忆**：角色的重要经历和事件

#### 2.1.2 角色与用户交互记忆

- **交互历史**：角色与用户的对话历史
- **用户偏好记忆**：角色记住用户的偏好和习惯
- **情感记忆**：角色记住与用户的情感互动
- **重要时刻记忆**：角色记住与用户的重要时刻

#### 2.1.3 角色场景记忆

- **场景隔离**：不同场景切片中的记忆相互隔离
- **场景上下文**：角色在特定场景中的表现和记忆
- **场景切换记忆**：角色切换场景时的记忆继承（可选）

#### 2.1.4 角色关系记忆

- **角色间关系**：角色与其他角色的关系
- **关系历史**：角色间的关系变化历史
- **关系强度**：角色间关系的强度评估

### 2.2 使用场景

1. **对话场景**：
   - 用户与角色对话时，角色能够回忆起之前的对话内容
   - 角色能够根据用户的偏好调整对话风格
   - 角色能够记住与用户的重要约定或事件

2. **多场景切换**：
   - 角色在不同场景切片中拥有独立的记忆
   - 角色在切换场景时能够保持部分记忆（如角色背景）

3. **多角色交互**：
   - 多个角色之间可以互相记住对方
   - 角色能够记住其他角色的特点和行为

---

## 三、技术架构

### 3.1 组件设计

```
┌─────────────────────────────────────────────────────────────┐
│                阶段二：角色记忆系统                          │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌─────────────────────────────────────────────────────┐    │
│  │           角色记忆服务                              │    │
│  │     CharacterMemoryService                          │    │
│  ├─────────────────────────────────────────────────────┤    │
│  │  ┌──────────────┐  ┌──────────────┐              │    │
│  │  │角色自身记忆  │  │角色交互记忆  │              │    │
│  │  │Character     │  │Interaction   │              │    │
│  │  │Self Memory   │  │Memory        │              │    │
│  │  └──────────────┘  └──────────────┘              │    │
│  │  ┌──────────────┐  ┌──────────────┐              │    │
│  │  │角色场景记忆  │  │角色关系记忆  │              │    │
│  │  │Scene Memory  │  │Relationship  │              │    │
│  │  │              │  │Memory        │              │    │
│  │  └──────────────┘  └──────────────┘              │    │
│  └─────────────────────────────────────────────────────┘    │
│                      │                                       │
│  ┌───────────────────▼───────────────────┐                  │
│  │      记忆管理器扩展                   │                  │
│  │  MemoryManager (Extended)             │                  │
│  ├───────────────────────────────────────┤                  │
│  │ • 角色记忆存储                        │                  │
│  │ • 角色记忆检索                        │                  │
│  │ • 角色记忆关联                        │                  │
│  └───────────────────────────────────────┘                  │
│                      │                                       │
│  ┌───────────────────▼───────────────────┐                  │
│  │      存储层 (MongoDB)                 │                  │
│  └───────────────────────────────────────┘                  │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 核心服务

#### 3.2.1 CharacterMemoryService（角色记忆服务）

**职责**：
- 管理角色的各种记忆
- 提供角色记忆的检索和更新
- 处理角色记忆的生命周期

**接口**：
```java
public interface CharacterMemoryService {
    // 角色自身记忆
    void saveCharacterSelfMemory(CharacterSelfMemory memory);
    CharacterSelfMemory getCharacterSelfMemory(String characterId);
    void updateCharacterSelfMemory(String characterId, CharacterSelfMemory memory);
    
    // 角色与用户交互记忆
    void saveInteractionMemory(CharacterInteractionMemory memory);
    List<CharacterInteractionMemory> getInteractionMemories(String characterId, String userId);
    List<CharacterInteractionMemory> getInteractionMemories(String characterId, String userId, String eraId);
    void updateInteractionMemory(String memoryId, CharacterInteractionMemory memory);
    
    // 角色场景记忆
    void saveSceneMemory(CharacterSceneMemory memory);
    List<CharacterSceneMemory> getSceneMemories(String characterId, String eraId);
    void deleteSceneMemory(String memoryId);
    
    // 角色关系记忆
    void saveRelationshipMemory(CharacterRelationshipMemory memory);
    CharacterRelationshipMemory getRelationshipMemory(String characterId, String relatedCharacterId);
    List<CharacterRelationshipMemory> getAllRelationships(String characterId);
    void updateRelationshipStrength(String characterId, String relatedCharacterId, double strength);
    
    // 记忆检索
    List<CharacterMemory> retrieveRelevantMemories(String characterId, String query, int limit);
    List<CharacterMemory> retrieveMemoriesByContext(String characterId, Map<String, Object> context, int limit);
    
    // 角色记忆画像
    CharacterMemoryProfile getCharacterMemoryProfile(String characterId);
}
```

---

## 四、数据模型

### 4.1 CharacterSelfMemory（角色自身记忆）

```java
@Data
@Document(collection = "character_self_memories")
public class CharacterSelfMemory {
    @Id
    private String id;
    
    private String characterId; // 角色ID
    private MemoryType type; // 记忆类型
    private MemoryImportance importance;
    private String content; // 记忆内容
    
    // 结构化数据
    private Map<String, Object> structuredData; // 如：性格特点、背景信息等
    private List<String> tags;
    private Map<String, Object> metadata;
    
    // 时间信息
    private Instant createdAt;
    private Instant updatedAt;
    private Instant lastAccessedAt;
    private Integer accessCount;
    
    // 来源信息
    private MemorySource source;
    private String sourceId;
    private Double confidence;
}
```

### 4.2 CharacterInteractionMemory（角色交互记忆）

```java
@Data
@Document(collection = "character_interaction_memories")
public class CharacterInteractionMemory {
    @Id
    private String id;
    
    private String characterId; // 角色ID
    private String userId; // 用户ID
    private String eraId; // 场景切片ID（可选）
    
    private MemoryType type; // 交互记忆类型
    private MemoryImportance importance;
    private String content; // 记忆内容
    
    // 交互信息
    private String interactionSessionId; // 交互会话ID
    private Instant interactionTime; // 交互时间
    private InteractionType interactionType; // 对话、操作等
    
    // 用户相关记忆
    private Map<String, Object> userRelatedData; // 用户偏好、习惯等
    
    // 结构化数据
    private Map<String, Object> structuredData;
    private List<String> tags;
    private Map<String, Object> metadata;
    
    // 时间信息
    private Instant createdAt;
    private Instant lastAccessedAt;
    private Integer accessCount;
    
    public enum InteractionType {
        CONVERSATION,  // 对话
        ACTION,        // 操作
        EVENT,         // 事件
        EMOTION        // 情感
    }
}
```

### 4.3 CharacterSceneMemory（角色场景记忆）

```java
@Data
@Document(collection = "character_scene_memories")
public class CharacterSceneMemory {
    @Id
    private String id;
    
    private String characterId; // 角色ID
    private String eraId; // 场景切片ID
    
    private MemoryType type;
    private MemoryImportance importance;
    private String content;
    
    // 场景相关信息
    private String sceneContext; // 场景上下文
    private Map<String, Object> sceneMetadata; // 场景元数据
    
    // 结构化数据
    private Map<String, Object> structuredData;
    private List<String> tags;
    private Map<String, Object> metadata;
    
    // 时间信息
    private Instant createdAt;
    private Instant updatedAt;
    private Instant lastAccessedAt;
    private Integer accessCount;
    
    // 是否可跨场景继承
    private Boolean inheritable; // 是否可在场景切换时继承
}
```

### 4.4 CharacterRelationshipMemory（角色关系记忆）

```java
@Data
@Document(collection = "character_relationship_memories")
public class CharacterRelationshipMemory {
    @Id
    private String id;
    
    private String characterId; // 角色ID
    private String relatedCharacterId; // 关联的角色ID
    
    private RelationshipType relationshipType; // 关系类型
    private Double strength; // 关系强度 (0.0-1.0)
    private String description; // 关系描述
    
    // 交互历史
    private List<InteractionRecord> interactions; // 交互记录
    private Integer interactionCount; // 交互次数
    private Instant firstMetAt; // 首次交互时间
    private Instant lastInteractedAt; // 最后交互时间
    
    // 关系变化历史
    private List<RelationshipChange> relationshipHistory; // 关系变化历史
    
    // 时间信息
    private Instant createdAt;
    private Instant updatedAt;
    
    // 元数据
    private Map<String, Object> metadata;
    
    public enum RelationshipType {
        FRIEND,        // 朋友
        FAMILY,        // 家人
        COLLEAGUE,     // 同事
        ENEMY,         // 敌人
        MENTOR,        // 导师
        STUDENT,       // 学生
        LOVER,         // 恋人
        ACQUAINTANCE,  // 熟人
        UNKNOWN        // 未知
    }
    
    @Data
    public static class InteractionRecord {
        private String interactionId;
        private InteractionType type;
        private String description;
        private Instant timestamp;
        private Map<String, Object> metadata;
    }
    
    @Data
    public static class RelationshipChange {
        private RelationshipType oldType;
        private RelationshipType newType;
        private Double oldStrength;
        private Double newStrength;
        private String reason;
        private Instant timestamp;
    }
}
```

### 4.5 CharacterMemory（通用角色记忆接口）

```java
public interface CharacterMemory {
    String getId();
    String getCharacterId();
    MemoryType getType();
    MemoryImportance getImportance();
    String getContent();
    Double getRelevance(String query);
    Instant getTimestamp();
}
```

---

## 五、实现细节

### 5.1 MongoDB集合设计

**character_self_memories集合**：
```javascript
{
  _id: ObjectId,
  characterId: String,
  type: String,
  importance: String,
  content: String,
  structuredData: Object,
  tags: [String],
  metadata: Object,
  createdAt: Date,
  updatedAt: Date,
  lastAccessedAt: Date,
  accessCount: Number,
  source: String,
  sourceId: String,
  confidence: Number
}

// 索引
db.character_self_memories.createIndex({ characterId: 1, type: 1 });
db.character_self_memories.createIndex({ characterId: 1, importance: -1 });
db.character_self_memories.createIndex({ content: "text" });
```

**character_interaction_memories集合**：
```javascript
{
  _id: ObjectId,
  characterId: String,
  userId: String,
  eraId: String,
  type: String,
  importance: String,
  content: String,
  interactionSessionId: String,
  interactionTime: Date,
  interactionType: String,
  userRelatedData: Object,
  structuredData: Object,
  tags: [String],
  metadata: Object,
  createdAt: Date,
  lastAccessedAt: Date,
  accessCount: Number
}

// 索引
db.character_interaction_memories.createIndex({ characterId: 1, userId: 1 });
db.character_interaction_memories.createIndex({ characterId: 1, userId: 1, eraId: 1 });
db.character_interaction_memories.createIndex({ interactionTime: -1 });
db.character_interaction_memories.createIndex({ content: "text" });
```

**character_scene_memories集合**：
```javascript
{
  _id: ObjectId,
  characterId: String,
  eraId: String,
  type: String,
  importance: String,
  content: String,
  sceneContext: String,
  sceneMetadata: Object,
  structuredData: Object,
  tags: [String],
  metadata: Object,
  createdAt: Date,
  updatedAt: Date,
  lastAccessedAt: Date,
  accessCount: Number,
  inheritable: Boolean
}

// 索引
db.character_scene_memories.createIndex({ characterId: 1, eraId: 1 });
db.character_scene_memories.createIndex({ characterId: 1, inheritable: 1 });
db.character_scene_memories.createIndex({ content: "text" });
```

**character_relationship_memories集合**：
```javascript
{
  _id: ObjectId,
  characterId: String,
  relatedCharacterId: String,
  relationshipType: String,
  strength: Number,
  description: String,
  interactions: [Object],
  interactionCount: Number,
  firstMetAt: Date,
  lastInteractedAt: Date,
  relationshipHistory: [Object],
  createdAt: Date,
  updatedAt: Date,
  metadata: Object
}

// 索引
db.character_relationship_memories.createIndex({ 
  characterId: 1, relatedCharacterId: 1 
}, { unique: true });
db.character_relationship_memories.createIndex({ characterId: 1, strength: -1 });
```

### 5.2 核心实现

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class MongoCharacterMemoryService implements CharacterMemoryService {
    
    private final MongoTemplate mongoTemplate;
    
    @Override
    public void saveInteractionMemory(CharacterInteractionMemory memory) {
        if (memory.getCreatedAt() == null) {
            memory.setCreatedAt(Instant.now());
        }
        if (memory.getInteractionTime() == null) {
            memory.setInteractionTime(Instant.now());
        }
        mongoTemplate.save(memory);
    }
    
    @Override
    public List<CharacterInteractionMemory> getInteractionMemories(
            String characterId, String userId, String eraId) {
        Query query = new Query();
        query.addCriteria(Criteria.where("characterId").is(characterId))
             .addCriteria(Criteria.where("userId").is(userId));
        
        if (eraId != null) {
            query.addCriteria(Criteria.where("eraId").is(eraId));
        }
        
        query.with(Sort.by(Sort.Direction.DESC, "interactionTime"));
        
        return mongoTemplate.find(query, CharacterInteractionMemory.class);
    }
    
    @Override
    public CharacterRelationshipMemory getRelationshipMemory(
            String characterId, String relatedCharacterId) {
        Query query = new Query();
        query.addCriteria(Criteria.where("characterId").is(characterId))
             .addCriteria(Criteria.where("relatedCharacterId").is(relatedCharacterId));
        
        return mongoTemplate.findOne(query, CharacterRelationshipMemory.class);
    }
    
    @Override
    public void updateRelationshipStrength(
            String characterId, String relatedCharacterId, double strength) {
        CharacterRelationshipMemory relationship = getRelationshipMemory(
            characterId, relatedCharacterId);
        
        if (relationship != null) {
            RelationshipType oldType = relationship.getRelationshipType();
            Double oldStrength = relationship.getStrength();
            
            relationship.setStrength(strength);
            relationship.setUpdatedAt(Instant.now());
            relationship.setLastInteractedAt(Instant.now());
            
            // 记录关系变化
            RelationshipChange change = new RelationshipChange();
            change.setOldStrength(oldStrength);
            change.setNewStrength(strength);
            change.setOldType(oldType);
            change.setNewType(determineRelationshipType(strength));
            change.setTimestamp(Instant.now());
            
            if (relationship.getRelationshipHistory() == null) {
                relationship.setRelationshipHistory(new ArrayList<>());
            }
            relationship.getRelationshipHistory().add(change);
            
            mongoTemplate.save(relationship);
        }
    }
    
    // ... 其他方法实现
}
```

---

## 六、REST API设计

### 6.1 角色自身记忆API

**保存角色自身记忆**：
```
POST /api/memory/v2/characters/{characterId}/self-memories
Content-Type: application/json

{
  "type": "PERSONALITY",
  "importance": "IMPORTANT",
  "content": "性格温和，喜欢帮助他人",
  "structuredData": {
    "personality": "温和",
    "trait": "助人为乐"
  },
  "tags": ["性格", "特点"]
}

Response: 201 Created
{
  "id": "cmem-123",
  "characterId": "char-456",
  "content": "性格温和，喜欢帮助他人",
  "createdAt": "2025-12-28T10:00:00Z"
}
```

**获取角色自身记忆**：
```
GET /api/memory/v2/characters/{characterId}/self-memories

Response: 200 OK
{
  "memories": [
    {
      "id": "cmem-123",
      "type": "PERSONALITY",
      "content": "性格温和，喜欢帮助他人",
      "importance": "IMPORTANT",
      "createdAt": "2025-12-28T10:00:00Z"
    }
  ],
  "total": 1
}
```

### 6.2 角色交互记忆API

**保存角色交互记忆**：
```
POST /api/memory/v2/characters/{characterId}/interaction-memories
Content-Type: application/json

{
  "userId": "user-789",
  "eraId": "era-001",
  "type": "CONVERSATION_TOPIC",
  "importance": "NORMAL",
  "content": "用户喜欢谈论旅行话题",
  "interactionType": "CONVERSATION",
  "userRelatedData": {
    "preference": "旅行"
  }
}

Response: 201 Created
```

**获取角色与用户的交互记忆**：
```
GET /api/memory/v2/characters/{characterId}/interaction-memories?userId={userId}&eraId={eraId}

Response: 200 OK
{
  "memories": [
    {
      "id": "imem-123",
      "userId": "user-789",
      "content": "用户喜欢谈论旅行话题",
      "interactionTime": "2025-12-28T10:00:00Z",
      "type": "CONVERSATION_TOPIC"
    }
  ],
  "total": 1
}
```

### 6.3 角色场景记忆API

**保存角色场景记忆**：
```
POST /api/memory/v2/characters/{characterId}/scene-memories
Content-Type: application/json

{
  "eraId": "era-001",
  "type": "SCENE_CONTEXT",
  "importance": "NORMAL",
  "content": "在大学场景中，角色是学生",
  "sceneContext": "大学场景",
  "inheritable": false
}

Response: 201 Created
```

**获取角色场景记忆**：
```
GET /api/memory/v2/characters/{characterId}/scene-memories?eraId={eraId}

Response: 200 OK
{
  "memories": [
    {
      "id": "smem-123",
      "eraId": "era-001",
      "content": "在大学场景中，角色是学生",
      "createdAt": "2025-12-28T10:00:00Z"
    }
  ],
  "total": 1
}
```

### 6.4 角色关系记忆API

**保存或更新角色关系**：
```
POST /api/memory/v2/characters/{characterId}/relationships
Content-Type: application/json

{
  "relatedCharacterId": "char-789",
  "relationshipType": "FRIEND",
  "strength": 0.8,
  "description": "好朋友"
}

Response: 201 Created
```

**获取角色所有关系**：
```
GET /api/memory/v2/characters/{characterId}/relationships

Response: 200 OK
{
  "relationships": [
    {
      "id": "rel-123",
      "relatedCharacterId": "char-789",
      "relationshipType": "FRIEND",
      "strength": 0.8,
      "description": "好朋友",
      "lastInteractedAt": "2025-12-28T10:00:00Z"
    }
  ],
  "total": 1
}
```

### 6.5 角色记忆检索API

**检索相关记忆**：
```
POST /api/memory/v2/characters/{characterId}/memories/search
Content-Type: application/json

{
  "query": "用户偏好",
  "limit": 10,
  "memoryTypes": ["INTERACTION_MEMORY", "SCENE_MEMORY"]
}

Response: 200 OK
{
  "memories": [
    {
      "id": "imem-123",
      "type": "INTERACTION_MEMORY",
      "content": "用户喜欢谈论旅行话题",
      "relevance": 0.85
    }
  ],
  "total": 1
}
```

---

## 七、集成到对话系统

### 7.1 对话上下文增强

在对话时，角色记忆应该被整合到对话上下文中：

```java
@Service
@RequiredArgsConstructor
public class EnhancedConversationService {
    
    private final CharacterMemoryService characterMemoryService;
    private final ShortMemoryService shortMemoryService;
    
    public ConversationContext getConversationContext(
            String characterId, String userId, String sessionId, String eraId) {
        
        // 1. 获取短期对话历史
        List<ChatMessage> messages = shortMemoryService.getMessages(sessionId, 20);
        
        // 2. 获取角色与用户的交互记忆
        List<CharacterInteractionMemory> interactionMemories = 
            characterMemoryService.getInteractionMemories(characterId, userId, eraId);
        
        // 3. 获取角色场景记忆
        List<CharacterSceneMemory> sceneMemories = 
            characterMemoryService.getSceneMemories(characterId, eraId);
        
        // 4. 构建增强的对话上下文
        return ConversationContext.builder()
            .messages(messages)
            .characterInteractionMemories(interactionMemories)
            .characterSceneMemories(sceneMemories)
            .build();
    }
}
```

### 7.2 记忆自动提取

在对话过程中自动提取和保存角色记忆：

```java
@Async
public void extractAndSaveCharacterMemories(
        String characterId, String userId, String sessionId, String eraId) {
    
    // 1. 获取最近的对话
    List<ChatMessage> messages = shortMemoryService.getMessages(sessionId, 10);
    
    // 2. 提取角色记忆
    List<CharacterInteractionMemory> memories = 
        memoryExtractor.extractCharacterInteractionMemories(
            characterId, userId, messages);
    
    // 3. 保存记忆
    for (CharacterInteractionMemory memory : memories) {
        memory.setEraId(eraId);
        characterMemoryService.saveInteractionMemory(memory);
    }
}
```

---

## 八、测试计划

### 8.1 单元测试

- 角色记忆服务的CRUD操作
- 角色关系管理的逻辑
- 角色记忆检索功能

### 8.2 集成测试

- 角色记忆与对话系统的集成
- 多场景记忆隔离测试
- 角色关系网络构建测试

### 8.3 性能测试

- 角色记忆检索性能
- 大量角色记忆的存储和检索
- 并发访问测试

---

## 九、交付清单

### 9.1 代码交付

- [ ] CharacterMemoryService实现
- [ ] 角色记忆数据模型
- [ ] 角色记忆REST API
- [ ] 与对话系统的集成
- [ ] 记忆提取器扩展

### 9.2 文档交付

- [ ] API文档
- [ ] 数据库设计文档
- [ ] 集成文档
- [ ] 测试报告

---

## 十、后续阶段准备

阶段二完成后，为阶段三做准备：

1. 设计参与者记忆的数据模型
2. 设计参与者关系网络
3. 规划多用户场景的记忆管理



