# 阶段三：参与者记忆系统

**文档版本**: V1.0  
**编写日期**: 2025-12-28  
**阶段目标**: 实现参与者的记忆能力，支持多用户交互场景  
**预计周期**: 3-4周

---

## 一、阶段目标

### 1.1 核心目标

1. ✅ 实现参与者记忆模型和数据存储
2. ✅ 实现参与者交互记忆
3. ✅ 实现参与者关系网络
4. ✅ 实现参与者偏好记忆
5. ✅ 实现多参与者场景记忆

### 1.2 成功标准

- 每个参与者拥有独立的记忆体系
- 参与者之间能够互相记住对方
- 参与者关系网络构建完整
- 支持多参与者场景的记忆管理
- API接口覆盖参与者记忆的所有功能
- 性能满足要求（检索延迟 < 150ms）

---

## 二、需求分析

### 2.1 参与者记忆需求

#### 2.1.1 参与者身份记忆

- **身份信息**：参与者在系统中的身份和角色
- **基本资料**：参与者的基本信息和资料
- **权限信息**：参与者的权限和角色权限

#### 2.1.2 参与者交互记忆

- **交互历史**：参与者之间的交互历史
- **协作记忆**：参与者之间的协作历史
- **事件记忆**：参与者共同经历的事件

#### 2.1.3 参与者关系网络

- **关系类型**：朋友、同事、合作伙伴等
- **关系强度**：关系的强度和亲密程度
- **关系历史**：关系的变化历史

#### 2.1.4 参与者偏好记忆

- **交互偏好**：参与者的交互偏好和习惯
- **行为模式**：参与者的行为模式
- **兴趣偏好**：参与者的兴趣和偏好

### 2.2 使用场景

1. **多用户协作场景**：
   - 多个用户在心域中协作完成任务
   - 参与者之间需要记住协作历史和约定

2. **社区场景**：
   - 用户在社区中与其他用户互动
   - 参与者之间建立关系网络

3. **游戏场景**：
   - 多个用户参与游戏或活动
   - 参与者之间需要记住游戏历史和关系

---

## 三、技术架构

### 3.1 组件设计

```
┌─────────────────────────────────────────────────────────────┐
│              阶段三：参与者记忆系统                          │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌─────────────────────────────────────────────────────┐    │
│  │         参与者记忆服务                              │    │
│  │     ParticipantMemoryService                        │    │
│  ├─────────────────────────────────────────────────────┤    │
│  │  ┌──────────────┐  ┌──────────────┐              │    │
│  │  │参与者身份记忆│  │参与者交互记忆│              │    │
│  │  │Identity      │  │Interaction   │              │    │
│  │  │Memory        │  │Memory        │              │    │
│  │  └──────────────┘  └──────────────┘              │    │
│  │  ┌──────────────┐  ┌──────────────┐              │    │
│  │  │参与者关系网络│  │参与者偏好记忆│              │    │
│  │  │Relationship  │  │Preference    │              │    │
│  │  │Network       │  │Memory        │              │    │
│  │  └──────────────┘  └──────────────┘              │    │
│  └─────────────────────────────────────────────────────┘    │
│                      │                                       │
│  ┌───────────────────▼───────────────────┐                  │
│  │      关系网络构建服务                 │                  │
│  │  RelationshipNetworkService           │                  │
│  ├───────────────────────────────────────┤                  │
│  │ • 关系图构建                          │                  │
│  │ • 关系强度计算                        │                  │
│  │ • 关系路径查找                        │                  │
│  └───────────────────────────────────────┘                  │
│                      │                                       │
│  ┌───────────────────▼───────────────────┐                  │
│  │      存储层 (MongoDB)                 │                  │
│  └───────────────────────────────────────┘                  │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 核心服务

#### 3.2.1 ParticipantMemoryService（参与者记忆服务）

**接口**：
```java
public interface ParticipantMemoryService {
    // 参与者身份记忆
    void saveIdentityMemory(ParticipantIdentityMemory memory);
    ParticipantIdentityMemory getIdentityMemory(String participantId);
    
    // 参与者交互记忆
    void saveInteractionMemory(ParticipantInteractionMemory memory);
    List<ParticipantInteractionMemory> getInteractionMemories(String participantId);
    List<ParticipantInteractionMemory> getInteractionMemories(
        String participantId, String relatedParticipantId);
    
    // 参与者关系
    void saveRelationship(ParticipantRelationship relationship);
    ParticipantRelationship getRelationship(
        String participantId, String relatedParticipantId);
    List<ParticipantRelationship> getAllRelationships(String participantId);
    void updateRelationshipStrength(
        String participantId, String relatedParticipantId, double strength);
    
    // 参与者偏好
    void savePreference(ParticipantPreference preference);
    ParticipantPreference getPreference(String participantId, String key);
    List<ParticipantPreference> getAllPreferences(String participantId);
    
    // 场景记忆
    void saveSceneMemory(ParticipantSceneMemory memory);
    List<ParticipantSceneMemory> getSceneMemories(String participantId, String sceneId);
    
    // 记忆检索
    List<ParticipantMemory> retrieveRelevantMemories(
        String participantId, String query, int limit);
}
```

#### 3.2.2 RelationshipNetworkService（关系网络服务）

**接口**：
```java
public interface RelationshipNetworkService {
    // 关系图构建
    RelationshipGraph buildRelationshipGraph(String participantId);
    RelationshipGraph buildRelationshipGraph(
        String participantId, int maxDepth);
    
    // 关系强度计算
    double calculateRelationshipStrength(
        String participantId, String relatedParticipantId);
    
    // 关系路径查找
    List<String> findRelationshipPath(
        String fromParticipantId, String toParticipantId);
    
    // 社区发现
    List<Community> detectCommunities(String sceneId);
    
    // 关系分析
    RelationshipAnalysis analyzeRelationships(String participantId);
}
```

---

## 四、数据模型

### 4.1 ParticipantIdentityMemory（参与者身份记忆）

```java
@Data
@Document(collection = "participant_identity_memories")
public class ParticipantIdentityMemory {
    @Id
    private String id;
    
    private String participantId; // 参与者ID
    private String sceneId; // 场景ID
    
    // 身份信息
    private String identity; // 身份描述
    private String role; // 角色
    private List<String> roles; // 多个角色
    
    // 基本资料
    private Map<String, Object> profile; // 资料信息
    
    // 权限信息
    private List<String> permissions; // 权限列表
    
    // 时间信息
    private Instant createdAt;
    private Instant updatedAt;
    private Instant lastAccessedAt;
    
    // 元数据
    private Map<String, Object> metadata;
}
```

### 4.2 ParticipantInteractionMemory（参与者交互记忆）

```java
@Data
@Document(collection = "participant_interaction_memories")
public class ParticipantInteractionMemory {
    @Id
    private String id;
    
    private String participantId; // 参与者ID
    private String relatedParticipantId; // 关联的参与者ID
    private String sceneId; // 场景ID
    
    private MemoryType type;
    private MemoryImportance importance;
    private String content;
    
    // 交互信息
    private InteractionType interactionType; // 交互类型
    private String interactionSessionId; // 交互会话ID
    private Instant interactionTime;
    
    // 协作信息
    private String collaborationType; // 协作类型
    private String collaborationResult; // 协作结果
    
    // 结构化数据
    private Map<String, Object> structuredData;
    private List<String> tags;
    private Map<String, Object> metadata;
    
    // 时间信息
    private Instant createdAt;
    private Instant lastAccessedAt;
    private Integer accessCount;
    
    public enum InteractionType {
        CONVERSATION,  // 对话
        COLLABORATION, // 协作
        EVENT,         // 事件
        GAME,          // 游戏
        SHARE          // 分享
    }
}
```

### 4.3 ParticipantRelationship（参与者关系）

```java
@Data
@Document(collection = "participant_relationships")
public class ParticipantRelationship {
    @Id
    private String id;
    
    private String participantId; // 参与者ID
    private String relatedParticipantId; // 关联的参与者ID
    private String sceneId; // 场景ID（可选）
    
    private RelationshipType relationshipType;
    private Double strength; // 关系强度 (0.0-1.0)
    private String description;
    
    // 交互历史
    private List<InteractionRecord> interactions;
    private Integer interactionCount;
    private Instant firstMetAt;
    private Instant lastInteractedAt;
    
    // 关系变化历史
    private List<RelationshipChange> relationshipHistory;
    
    // 时间信息
    private Instant createdAt;
    private Instant updatedAt;
    
    // 元数据
    private Map<String, Object> metadata;
    
    public enum RelationshipType {
        FRIEND,        // 朋友
        COLLEAGUE,     // 同事
        PARTNER,       // 合作伙伴
        RIVAL,         // 对手
        MENTOR,        // 导师
        STUDENT,       // 学生
        FAMILY,        // 家人
        ACQUAINTANCE,  // 熟人
        UNKNOWN        // 未知
    }
}
```

### 4.4 ParticipantPreference（参与者偏好）

```java
@Data
@Document(collection = "participant_preferences")
public class ParticipantPreference {
    @Id
    private String id;
    
    private String participantId;
    private String sceneId; // 场景ID（可选）
    private String key;
    private Object value;
    private PreferenceType type;
    
    private Double confidence;
    private Instant updatedAt;
    private Integer accessCount;
    private Instant lastAccessedAt;
    
    private Map<String, Object> metadata;
}
```

### 4.5 ParticipantSceneMemory（参与者场景记忆）

```java
@Data
@Document(collection = "participant_scene_memories")
public class ParticipantSceneMemory {
    @Id
    private String id;
    
    private String participantId;
    private String sceneId;
    
    private MemoryType type;
    private MemoryImportance importance;
    private String content;
    
    // 场景相关信息
    private List<String> relatedParticipantIds; // 相关的参与者ID列表
    private Map<String, Object> sceneContext;
    
    // 结构化数据
    private Map<String, Object> structuredData;
    private List<String> tags;
    private Map<String, Object> metadata;
    
    // 时间信息
    private Instant createdAt;
    private Instant updatedAt;
    private Instant lastAccessedAt;
    private Integer accessCount;
}
```

---

## 五、关系网络设计

### 5.1 关系图结构

```java
@Data
public class RelationshipGraph {
    private String participantId; // 中心参与者ID
    private Map<String, RelationshipNode> nodes; // 节点集合
    private List<RelationshipEdge> edges; // 边集合
    private int maxDepth; // 最大深度
    private Instant generatedAt; // 生成时间
    
    @Data
    public static class RelationshipNode {
        private String participantId;
        private String identity;
        private Map<String, Object> metadata;
    }
    
    @Data
    public static class RelationshipEdge {
        private String fromParticipantId;
        private String toParticipantId;
        private RelationshipType type;
        private Double strength;
        private String description;
    }
}
```

### 5.2 关系强度计算

关系强度基于：
- 交互频率
- 交互时长
- 交互类型（协作 > 对话 > 事件）
- 时间衰减

```java
public double calculateRelationshipStrength(
        String participantId, String relatedParticipantId) {
    
    ParticipantRelationship relationship = getRelationship(
        participantId, relatedParticipantId);
    
    if (relationship == null) {
        return 0.0;
    }
    
    // 基础强度
    double baseStrength = relationship.getStrength();
    
    // 交互频率加成
    double frequencyBonus = calculateFrequencyBonus(
        relationship.getInteractionCount());
    
    // 时间衰减
    double timeDecay = calculateTimeDecay(
        relationship.getLastInteractedAt());
    
    return Math.min(1.0, baseStrength + frequencyBonus - timeDecay);
}

private double calculateFrequencyBonus(int interactionCount) {
    return Math.log(1 + interactionCount) / 10.0;
}

private double calculateTimeDecay(Instant lastInteractedAt) {
    long daysSince = Duration.between(lastInteractedAt, Instant.now()).toDays();
    return Math.min(0.3, daysSince / 365.0);
}
```

---

## 六、REST API设计

### 6.1 参与者交互记忆API

**保存交互记忆**：
```
POST /api/memory/v3/participants/{participantId}/interaction-memories
Content-Type: application/json

{
  "relatedParticipantId": "part-789",
  "sceneId": "scene-001",
  "type": "COLLABORATION",
  "importance": "NORMAL",
  "content": "与参与者part-789协作完成了任务A",
  "interactionType": "COLLABORATION",
  "collaborationType": "TASK_COLLABORATION",
  "collaborationResult": "SUCCESS"
}

Response: 201 Created
```

**获取交互记忆**：
```
GET /api/memory/v3/participants/{participantId}/interaction-memories?relatedParticipantId={relatedId}&sceneId={sceneId}

Response: 200 OK
{
  "memories": [
    {
      "id": "pmem-123",
      "relatedParticipantId": "part-789",
      "content": "与参与者part-789协作完成了任务A",
      "interactionTime": "2025-12-28T10:00:00Z"
    }
  ],
  "total": 1
}
```

### 6.2 参与者关系API

**保存或更新关系**：
```
POST /api/memory/v3/participants/{participantId}/relationships
Content-Type: application/json

{
  "relatedParticipantId": "part-789",
  "sceneId": "scene-001",
  "relationshipType": "COLLEAGUE",
  "strength": 0.7,
  "description": "工作伙伴"
}

Response: 201 Created
```

**获取关系网络**：
```
GET /api/memory/v3/participants/{participantId}/relationship-network?maxDepth=2

Response: 200 OK
{
  "participantId": "part-456",
  "nodes": [
    {
      "participantId": "part-456",
      "identity": "用户A"
    },
    {
      "participantId": "part-789",
      "identity": "用户B"
    }
  ],
  "edges": [
    {
      "fromParticipantId": "part-456",
      "toParticipantId": "part-789",
      "relationshipType": "COLLEAGUE",
      "strength": 0.7
    }
  ],
  "maxDepth": 2,
  "generatedAt": "2025-12-28T10:00:00Z"
}
```

### 6.3 参与者偏好API

**保存偏好**：
```
POST /api/memory/v3/participants/{participantId}/preferences
Content-Type: application/json

{
  "sceneId": "scene-001",
  "key": "interactionStyle",
  "value": "collaborative",
  "type": "STRING",
  "confidence": 0.8
}

Response: 201 Created
```

---

## 七、实现细节

### 7.1 MongoDB集合设计

**participant_interaction_memories集合**：
```javascript
{
  _id: ObjectId,
  participantId: String,
  relatedParticipantId: String,
  sceneId: String,
  type: String,
  importance: String,
  content: String,
  interactionType: String,
  interactionSessionId: String,
  interactionTime: Date,
  collaborationType: String,
  collaborationResult: String,
  structuredData: Object,
  tags: [String],
  metadata: Object,
  createdAt: Date,
  lastAccessedAt: Date,
  accessCount: Number
}

// 索引
db.participant_interaction_memories.createIndex({ 
  participantId: 1, relatedParticipantId: 1 
});
db.participant_interaction_memories.createIndex({ 
  participantId: 1, sceneId: 1 
});
db.participant_interaction_memories.createIndex({ interactionTime: -1 });
```

**participant_relationships集合**：
```javascript
{
  _id: ObjectId,
  participantId: String,
  relatedParticipantId: String,
  sceneId: String,
  relationshipType: String,
  strength: Number,
  description: String,
  interactions: [Object],
  interactionCount: Number,
  firstMetAt: Date,
  lastInteractedAt: Date,
  relationshipHistory: [Object],
  createdAt: Date,
  updatedAt: Date,
  metadata: Object
}

// 索引
db.participant_relationships.createIndex({ 
  participantId: 1, relatedParticipantId: 1 
}, { unique: true });
db.participant_relationships.createIndex({ participantId: 1, strength: -1 });
db.participant_relationships.createIndex({ sceneId: 1 });
```

### 7.2 关系网络构建实现

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class MongoRelationshipNetworkService implements RelationshipNetworkService {
    
    private final ParticipantMemoryService participantMemoryService;
    
    @Override
    public RelationshipGraph buildRelationshipGraph(
            String participantId, int maxDepth) {
        RelationshipGraph graph = new RelationshipGraph();
        graph.setParticipantId(participantId);
        graph.setMaxDepth(maxDepth);
        graph.setGeneratedAt(Instant.now());
        graph.setNodes(new HashMap<>());
        graph.setEdges(new ArrayList<>());
        
        // 添加中心节点
        ParticipantIdentityMemory identity = 
            participantMemoryService.getIdentityMemory(participantId);
        RelationshipGraph.RelationshipNode centerNode = 
            new RelationshipGraph.RelationshipNode();
        centerNode.setParticipantId(participantId);
        if (identity != null) {
            centerNode.setIdentity(identity.getIdentity());
        }
        graph.getNodes().put(participantId, centerNode);
        
        // 递归构建关系网络
        buildRelationshipGraphRecursive(
            participantId, graph, 0, maxDepth, new HashSet<>());
        
        return graph;
    }
    
    private void buildRelationshipGraphRecursive(
            String participantId, 
            RelationshipGraph graph, 
            int currentDepth, 
            int maxDepth,
            Set<String> visited) {
        
        if (currentDepth >= maxDepth || visited.contains(participantId)) {
            return;
        }
        
        visited.add(participantId);
        
        // 获取所有关系
        List<ParticipantRelationship> relationships = 
            participantMemoryService.getAllRelationships(participantId);
        
        for (ParticipantRelationship relationship : relationships) {
            String relatedId = relationship.getRelatedParticipantId();
            
            // 添加节点
            if (!graph.getNodes().containsKey(relatedId)) {
                ParticipantIdentityMemory identity = 
                    participantMemoryService.getIdentityMemory(relatedId);
                RelationshipGraph.RelationshipNode node = 
                    new RelationshipGraph.RelationshipNode();
                node.setParticipantId(relatedId);
                if (identity != null) {
                    node.setIdentity(identity.getIdentity());
                }
                graph.getNodes().put(relatedId, node);
            }
            
            // 添加边
            RelationshipGraph.RelationshipEdge edge = 
                new RelationshipGraph.RelationshipEdge();
            edge.setFromParticipantId(participantId);
            edge.setToParticipantId(relatedId);
            edge.setType(relationship.getRelationshipType());
            edge.setStrength(relationship.getStrength());
            edge.setDescription(relationship.getDescription());
            graph.getEdges().add(edge);
            
            // 递归处理关联节点
            buildRelationshipGraphRecursive(
                relatedId, graph, currentDepth + 1, maxDepth, visited);
        }
    }
}
```

---

## 八、测试计划

### 8.1 单元测试

- 参与者记忆服务的CRUD操作
- 关系网络构建逻辑
- 关系强度计算算法

### 8.2 集成测试

- 多参与者场景的记忆管理
- 关系网络的构建和查询
- 与场景系统的集成

### 8.3 性能测试

- 关系网络构建性能
- 大量参与者的关系管理
- 并发访问测试

---

## 九、交付清单

### 9.1 代码交付

- [ ] ParticipantMemoryService实现
- [ ] RelationshipNetworkService实现
- [ ] 参与者记忆数据模型
- [ ] 参与者记忆REST API
- [ ] 关系网络可视化工具（可选）

### 9.2 文档交付

- [ ] API文档
- [ ] 数据库设计文档
- [ ] 关系网络算法文档
- [ ] 测试报告

---

## 十、后续阶段准备

阶段三完成后，为阶段四做准备：

1. 设计向量搜索的数据模型
2. 设计记忆关联的算法
3. 规划高级记忆检索功能

