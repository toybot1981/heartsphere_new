# 阶段四：高级记忆能力

**文档版本**: V1.0  
**编写日期**: 2025-12-28  
**阶段目标**: 实现语义搜索、记忆关联等高级能力  
**预计周期**: 6-8周

---

## 一、阶段目标

### 1.1 核心目标

1. ✅ 实现向量嵌入和语义搜索
2. ✅ 实现记忆关联网络
3. ✅ 实现智能记忆检索
4. ✅ 实现记忆重要性评估
5. ✅ 实现记忆巩固机制

### 1.2 成功标准

- 语义搜索准确率 > 75%
- 记忆关联准确率 > 70%
- 检索响应时间 < 200ms
- 记忆巩固自动化率 > 80%
- 重要性评估准确率 > 75%

---

## 二、需求分析

### 2.1 语义搜索需求

- **向量嵌入**：将记忆内容转换为向量表示
- **相似度计算**：计算记忆之间的语义相似度
- **语义检索**：基于语义相似度的记忆检索
- **混合检索**：结合关键词和语义的混合检索

### 2.2 记忆关联需求

- **关联发现**：自动发现记忆之间的关联
- **关联网络**：构建记忆关联网络
- **关联检索**：基于关联关系的记忆检索
- **关联强度**：计算和更新关联强度

### 2.3 智能检索需求

- **多维度检索**：支持关键词、语义、关联、上下文等多维度检索
- **检索排序**：智能排序检索结果
- **检索推荐**：推荐相关记忆

### 2.4 记忆重要性评估

- **重要性计算**：自动计算记忆的重要性
- **重要性更新**：根据使用情况更新重要性
- **重要性衰减**：实现记忆的时间衰减

### 2.5 记忆巩固机制

- **自动巩固**：自动将重要记忆从短期转为长期
- **批量巩固**：批量处理记忆巩固
- **去重合并**：合并重复或相似的记忆

---

## 三、技术架构

### 3.1 组件设计

```
┌─────────────────────────────────────────────────────────────┐
│              阶段四：高级记忆能力                            │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌─────────────────────────────────────────────────────┐    │
│  │           向量搜索服务                              │    │
│  │     VectorSearchService                             │    │
│  ├─────────────────────────────────────────────────────┤    │
│  │ • 向量嵌入生成                                      │    │
│  │ • 向量存储                                          │    │
│  │ • 语义相似度计算                                    │    │
│  │ • 语义检索                                          │    │
│  └─────────────────────────────────────────────────────┘    │
│                      │                                       │
│  ┌───────────────────▼───────────────────┐                  │
│  │         记忆关联服务                 │                  │
│  │     MemoryAssociationService          │                  │
│  ├───────────────────────────────────────┤                  │
│  │ • 关联发现                           │                  │
│  │ • 关联网络构建                       │                  │
│  │ • 关联检索                           │                  │
│  │ • 关联强度计算                       │                  │
│  └───────────────────────────────────────┘                  │
│                      │                                       │
│  ┌───────────────────▼───────────────────┐                  │
│  │         智能检索服务                 │                  │
│  │     IntelligentRetrievalService       │                  │
│  ├───────────────────────────────────────┤                  │
│  │ • 多维度检索                         │                  │
│  │ • 检索排序                           │                  │
│  │ • 检索推荐                           │                  │
│  └───────────────────────────────────────┘                  │
│                      │                                       │
│  ┌───────────────────▼───────────────────┐                  │
│  │         记忆巩固服务                 │                  │
│  │     MemoryConsolidationService        │                  │
│  ├───────────────────────────────────────┤                  │
│  │ • 重要性评估                         │                  │
│  │ • 自动巩固                           │                  │
│  │ • 批量处理                           │                  │
│  │ • 去重合并                           │                  │
│  └───────────────────────────────────────┘                  │
│                      │                                       │
│  ┌───────────────────▼───────────────────┐                  │
│  │      存储层 (MongoDB + Vector DB)     │                  │
│  └───────────────────────────────────────┘                  │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 核心服务

#### 3.2.1 VectorSearchService（向量搜索服务）

**接口**：
```java
public interface VectorSearchService {
    // 向量嵌入
    float[] generateEmbedding(String text);
    List<float[]> generateEmbeddings(List<String> texts);
    float[] generateMemoryEmbedding(Memory memory);
    
    // 向量存储
    void saveMemoryVector(String memoryId, float[] vector);
    void saveMemoryVectors(Map<String, float[]> vectors);
    float[] getMemoryVector(String memoryId);
    
    // 相似度计算
    double cosineSimilarity(float[] vec1, float[] vec2);
    
    // 语义搜索
    List<SimilarMemory> searchSimilarMemories(
        String query, String userId, int limit, double threshold);
    List<SimilarMemory> searchSimilarMemories(
        float[] queryVector, String userId, int limit, double threshold);
    
    // 混合检索
    List<Memory> hybridSearch(
        String query, String userId, int limit, 
        double semanticWeight, double keywordWeight);
}
```

#### 3.2.2 MemoryAssociationService（记忆关联服务）

**接口**：
```java
public interface MemoryAssociationService {
    // 关联发现
    List<MemoryAssociation> discoverAssociations(String memoryId);
    void discoverAndSaveAssociations(String memoryId);
    
    // 关联管理
    void saveAssociation(MemoryAssociation association);
    MemoryAssociation getAssociation(String fromMemoryId, String toMemoryId);
    List<MemoryAssociation> getAssociations(String memoryId);
    void updateAssociationStrength(
        String fromMemoryId, String toMemoryId, double strength);
    
    // 关联网络
    MemoryAssociationNetwork buildAssociationNetwork(
        String memoryId, int maxDepth);
    
    // 关联检索
    List<Memory> retrieveByAssociation(
        String memoryId, int limit, double minStrength);
}
```

#### 3.2.3 MemoryConsolidationService（记忆巩固服务）

**接口**：
```java
public interface MemoryConsolidationService {
    // 重要性评估
    double evaluateImportance(Memory memory);
    void updateMemoryImportance(String memoryId);
    void batchUpdateImportance(String userId);
    
    // 记忆巩固
    void consolidateMemory(String memoryId);
    void consolidateMemories(String userId, List<String> memoryIds);
    void consolidateSessionMemories(String userId, String sessionId);
    
    // 批量处理
    void batchConsolidate(String userId);
    void scheduledConsolidate();
    
    // 去重合并
    List<Memory> findDuplicateMemories(String userId, Memory memory);
    void mergeMemories(String targetMemoryId, List<String> sourceMemoryIds);
}
```

---

## 四、向量搜索实现

### 4.1 向量嵌入生成

使用嵌入模型将文本转换为向量：

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class EmbeddingVectorSearchService implements VectorSearchService {
    
    private final EmbeddingClient embeddingClient;
    private final MongoTemplate mongoTemplate;
    
    @Override
    public float[] generateEmbedding(String text) {
        // 使用嵌入模型生成向量
        List<Double> embedding = embeddingClient.embed(text);
        
        // 转换为float数组
        float[] vector = new float[embedding.size()];
        for (int i = 0; i < embedding.size(); i++) {
            vector[i] = embedding.get(i).floatValue();
        }
        
        return vector;
    }
    
    @Override
    public float[] generateMemoryEmbedding(Memory memory) {
        // 构建记忆的文本表示
        String text = buildMemoryText(memory);
        return generateEmbedding(text);
    }
    
    private String buildMemoryText(Memory memory) {
        StringBuilder sb = new StringBuilder();
        sb.append(memory.getContent());
        
        if (memory.getTags() != null && !memory.getTags().isEmpty()) {
            sb.append(" ").append(String.join(" ", memory.getTags()));
        }
        
        if (memory.getStructuredData() != null) {
            sb.append(" ").append(memory.getStructuredData().toString());
        }
        
        return sb.toString();
    }
}
```

### 4.2 向量存储

在MongoDB中存储向量（或使用专用向量数据库）：

```java
@Data
@Document(collection = "memory_vectors")
public class MemoryVector {
    @Id
    private String id;
    
    private String memoryId;
    private String userId;
    private MemoryType memoryType;
    private float[] vector; // 向量数据
    private int dimension; // 向量维度
    
    private Instant createdAt;
    private Instant updatedAt;
}
```

### 4.3 语义搜索

```java
@Override
public List<SimilarMemory> searchSimilarMemories(
        String query, String userId, int limit, double threshold) {
    
    // 1. 生成查询向量
    float[] queryVector = generateEmbedding(query);
    
    // 2. 获取用户的所有记忆向量
    Query mongoQuery = new Query(Criteria.where("userId").is(userId));
    List<MemoryVector> memoryVectors = mongoTemplate.find(
        mongoQuery, MemoryVector.class);
    
    // 3. 计算相似度
    List<SimilarMemory> results = new ArrayList<>();
    for (MemoryVector memoryVector : memoryVectors) {
        double similarity = cosineSimilarity(
            queryVector, memoryVector.getVector());
        
        if (similarity >= threshold) {
            SimilarMemory similarMemory = new SimilarMemory();
            similarMemory.setMemoryId(memoryVector.getMemoryId());
            similarMemory.setSimilarity(similarity);
            results.add(similarMemory);
        }
    }
    
    // 4. 排序并返回top N
    return results.stream()
        .sorted(Comparator.comparing(SimilarMemory::getSimilarity).reversed())
        .limit(limit)
        .collect(Collectors.toList());
}

@Override
public double cosineSimilarity(float[] vec1, float[] vec2) {
    if (vec1.length != vec2.length) {
        throw new IllegalArgumentException("向量维度不匹配");
    }
    
    double dotProduct = 0.0;
    double norm1 = 0.0;
    double norm2 = 0.0;
    
    for (int i = 0; i < vec1.length; i++) {
        dotProduct += vec1[i] * vec2[i];
        norm1 += vec1[i] * vec1[i];
        norm2 += vec2[i] * vec2[i];
    }
    
    return dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));
}
```

---

## 五、记忆关联实现

### 5.1 关联模型

```java
@Data
@Document(collection = "memory_associations")
public class MemoryAssociation {
    @Id
    private String id;
    
    private String fromMemoryId; // 源记忆ID
    private String toMemoryId;   // 目标记忆ID
    private String userId;       // 用户ID
    
    private AssociationType type; // 关联类型
    private Double strength;      // 关联强度 (0.0-1.0)
    private String description;   // 关联描述
    
    // 关联发现方式
    private AssociationSource source; // 关联来源
    
    // 时间信息
    private Instant createdAt;
    private Instant updatedAt;
    
    // 元数据
    private Map<String, Object> metadata;
    
    public enum AssociationType {
        SEMANTIC,      // 语义关联
        TEMPORAL,      // 时间关联
        CONTEXTUAL,    // 上下文关联
        USER_DEFINED,  // 用户定义
        SIMILAR,       // 相似关联
        CAUSAL         // 因果关系
    }
    
    public enum AssociationSource {
        AUTO_DISCOVERED,  // 自动发现
        USER_CREATED,     // 用户创建
        SYSTEM_SUGGESTED  // 系统建议
    }
}
```

### 5.2 关联发现

```java
@Override
public List<MemoryAssociation> discoverAssociations(String memoryId) {
    List<MemoryAssociation> associations = new ArrayList<>();
    
    // 1. 获取记忆
    Memory memory = memoryService.getMemory(memoryId);
    if (memory == null) {
        return associations;
    }
    
    // 2. 获取用户的所有记忆
    List<Memory> allMemories = memoryService.getAllMemories(memory.getUserId());
    
    // 3. 发现不同类型的关联
    associations.addAll(discoverSemanticAssociations(memory, allMemories));
    associations.addAll(discoverTemporalAssociations(memory, allMemories));
    associations.addAll(discoverContextualAssociations(memory, allMemories));
    
    return associations;
}

private List<MemoryAssociation> discoverSemanticAssociations(
        Memory memory, List<Memory> allMemories) {
    List<MemoryAssociation> associations = new ArrayList<>();
    
    // 使用向量搜索发现语义相似的记忆
    List<SimilarMemory> similarMemories = vectorSearchService.searchSimilarMemories(
        memory.getContent(), memory.getUserId(), 10, 0.7);
    
    for (SimilarMemory similarMemory : similarMemories) {
        if (similarMemory.getMemoryId().equals(memory.getId())) {
            continue; // 跳过自己
        }
        
        MemoryAssociation association = new MemoryAssociation();
        association.setFromMemoryId(memory.getId());
        association.setToMemoryId(similarMemory.getMemoryId());
        association.setUserId(memory.getUserId());
        association.setType(AssociationType.SEMANTIC);
        association.setStrength(similarMemory.getSimilarity());
        association.setSource(AssociationSource.AUTO_DISCOVERED);
        association.setCreatedAt(Instant.now());
        
        associations.add(association);
    }
    
    return associations;
}
```

---

## 六、记忆巩固实现

### 6.1 重要性评估

```java
@Override
public double evaluateImportance(Memory memory) {
    double importance = 0.0;
    
    // 1. 基础重要性
    if (memory.getImportance() != null) {
        importance += memory.getImportance().getValue() * 0.4;
    }
    
    // 2. 访问频率加成
    if (memory.getAccessCount() != null && memory.getAccessCount() > 0) {
        double frequencyScore = Math.log(1 + memory.getAccessCount()) / 10.0;
        importance += Math.min(0.3, frequencyScore);
    }
    
    // 3. 时间因子（最近访问的记忆更重要）
    if (memory.getLastAccessedAt() != null) {
        long daysSince = Duration.between(
            memory.getLastAccessedAt(), Instant.now()).toDays();
        double timeScore = Math.exp(-daysSince / 30.0); // 30天衰减一半
        importance += timeScore * 0.2;
    }
    
    // 4. 关联度加成（被关联的记忆更重要）
    List<MemoryAssociation> associations = 
        memoryAssociationService.getAssociations(memory.getId());
    double associationScore = Math.min(0.1, associations.size() / 100.0);
    importance += associationScore;
    
    return Math.min(1.0, importance);
}
```

### 6.2 自动巩固

```java
@Override
public void consolidateMemory(String memoryId) {
    Memory memory = memoryService.getMemory(memoryId);
    if (memory == null) {
        return;
    }
    
    // 1. 评估重要性
    double importance = evaluateImportance(memory);
    
    // 2. 如果重要性足够高，转为长期记忆
    if (importance >= CONSOLIDATION_THRESHOLD) {
        // 3. 检查是否有重复记忆
        List<Memory> duplicates = findDuplicateMemories(
            memory.getUserId(), memory);
        
        if (duplicates.isEmpty()) {
            // 没有重复，直接保存
            longMemoryService.saveMemory(memory);
        } else {
            // 有重复，合并
            mergeMemories(duplicates.get(0).getId(), 
                Collections.singletonList(memoryId));
        }
        
        // 4. 生成向量嵌入（如果还没有）
        if (!vectorExists(memoryId)) {
            float[] vector = vectorSearchService.generateMemoryEmbedding(memory);
            vectorSearchService.saveMemoryVector(memoryId, vector);
        }
        
        // 5. 发现关联
        memoryAssociationService.discoverAndSaveAssociations(memoryId);
    }
}
```

---

## 七、REST API设计

### 7.1 语义搜索API

**语义搜索**：
```
POST /api/memory/v4/search/semantic
Content-Type: application/json

{
  "userId": "user-456",
  "query": "用户喜欢喝咖啡",
  "limit": 10,
  "threshold": 0.7
}

Response: 200 OK
{
  "results": [
    {
      "memoryId": "mem-123",
      "similarity": 0.85,
      "content": "用户喜欢喝拿铁咖啡",
      "type": "PREFERENCE"
    }
  ],
  "total": 1
}
```

### 7.2 记忆关联API

**获取记忆关联**：
```
GET /api/memory/v4/memories/{memoryId}/associations?limit=20

Response: 200 OK
{
  "associations": [
    {
      "id": "assoc-123",
      "toMemoryId": "mem-789",
      "type": "SEMANTIC",
      "strength": 0.8,
      "description": "语义相似"
    }
  ],
  "total": 1
}
```

**基于关联检索**：
```
GET /api/memory/v4/memories/{memoryId}/retrieve-by-association?limit=10&minStrength=0.6

Response: 200 OK
{
  "memories": [
    {
      "id": "mem-789",
      "content": "相关记忆内容",
      "associationStrength": 0.8
    }
  ],
  "total": 1
}
```

### 7.3 记忆巩固API

**手动巩固记忆**：
```
POST /api/memory/v4/memories/{memoryId}/consolidate

Response: 200 OK
{
  "success": true,
  "importance": 0.85,
  "consolidated": true
}
```

**批量巩固**：
```
POST /api/memory/v4/users/{userId}/consolidate
Content-Type: application/json

{
  "memoryIds": ["mem-123", "mem-456"],
  "auto": true
}

Response: 200 OK
{
  "consolidatedCount": 2,
  "skippedCount": 0
}
```

---

## 八、测试计划

### 8.1 功能测试

- 向量嵌入生成准确性
- 语义搜索准确率
- 记忆关联发现准确性
- 记忆巩固逻辑正确性

### 8.2 性能测试

- 向量搜索性能（< 200ms）
- 关联发现性能
- 批量巩固性能

### 8.3 准确性测试

- 语义搜索准确率 > 75%
- 关联发现准确率 > 70%
- 重要性评估准确率 > 75%

---

## 九、交付清单

### 9.1 代码交付

- [ ] VectorSearchService实现
- [ ] MemoryAssociationService实现
- [ ] MemoryConsolidationService实现
- [ ] 向量存储和检索
- [ ] 关联网络构建
- [ ] REST API扩展

### 9.2 文档交付

- [ ] API文档
- [ ] 算法文档
- [ ] 性能测试报告
- [ ] 准确性测试报告

---

## 十、后续阶段准备

阶段四完成后，为阶段五做准备：

1. 设计性能优化方案
2. 设计记忆衰减机制
3. 规划监控和诊断功能



