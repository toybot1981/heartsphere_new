# 阶段一：基础记忆系统

**文档版本**: V1.0  
**编写日期**: 2025-12-28  
**阶段目标**: 建立记忆系统的基础架构，实现用户记忆的基础能力  
**预计周期**: 4-6周

---

## 一、阶段目标

### 1.1 核心目标

1. ✅ 建立短期记忆系统（Redis）
2. ✅ 建立长期记忆系统（MongoDB）
3. ✅ 实现基础记忆检索功能
4. ✅ 实现记忆提取和存储
5. ✅ 提供基础REST API接口（20+）

### 1.2 成功标准

- 短期记忆读写延迟 < 10ms
- 长期记忆检索延迟 < 100ms
- 支持基础的关键词检索
- 记忆提取准确率 > 70%
- API接口覆盖核心功能
- 单元测试覆盖率 > 80%

---

## 二、技术架构

### 2.1 组件设计

```
┌─────────────────────────────────────────────────────────────┐
│                  阶段一：基础记忆系统                        │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌──────────────────┐         ┌──────────────────┐          │
│  │ 短期记忆服务     │         │ 长期记忆服务     │          │
│  │ ShortMemory      │         │ LongMemory       │          │
│  │ Service          │         │ Service          │          │
│  └──────────────────┘         └──────────────────┘          │
│           │                              │                   │
│           └──────────┬───────────────────┘                   │
│                      │                                       │
│           ┌──────────▼───────────────────┐                   │
│           │   记忆管理器                 │                   │
│           │  MemoryManager               │                   │
│           ├──────────────────────────────┤                   │
│           │ • 记忆存储                   │                   │
│           │ • 记忆检索                   │                   │
│           │ • 记忆提取                   │                   │
│           └──────────────────────────────┘                   │
│                      │                                       │
│           ┌──────────▼───────────────────┐                   │
│           │   存储层                     │                   │
│           ├──────────────────────────────┤                   │
│           │ • Redis (短期)              │                   │
│           │ • MongoDB (长期)            │                   │
│           └──────────────────────────────┘                   │
│                      │                                       │
│           ┌──────────▼───────────────────┐                   │
│           │   REST API Controller        │                   │
│           └──────────────────────────────┘                   │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 核心服务

#### 2.2.1 ShortMemoryService（短期记忆服务）

**职责**：
- 管理对话上下文（最近N条消息）
- 管理会话状态
- 管理工作记忆（临时数据）

**接口**：
```java
public interface ShortMemoryService {
    // 消息管理
    void saveMessage(String sessionId, ChatMessage message);
    List<ChatMessage> getMessages(String sessionId, int limit);
    List<ChatMessage> getMessages(String sessionId, Instant startTime, Instant endTime);
    void deleteMessage(String sessionId, String messageId);
    void clearSession(String sessionId);
    
    // 工作记忆
    void saveWorkingMemory(String sessionId, String key, Object value);
    <T> T getWorkingMemory(String sessionId, String key, Class<T> type);
    void deleteWorkingMemory(String sessionId, String key);
    
    // 会话管理
    boolean sessionExists(String sessionId);
    void deleteSession(String sessionId);
    List<String> getAllSessionIds(String userId);
    
    // 统计
    int getMessageCount(String sessionId);
    int getSessionCount(String userId);
}
```

#### 2.2.2 LongMemoryService（长期记忆服务）

**职责**：
- 存储用户事实和偏好
- 提供记忆检索功能
- 管理记忆的生命周期

**接口**：
```java
public interface LongMemoryService {
    // 用户事实
    void saveFact(UserFact fact);
    void saveFacts(List<UserFact> facts);
    UserFact getFact(String factId);
    List<UserFact> getAllFacts(String userId);
    List<UserFact> getFactsByCategory(String userId, FactCategory category);
    List<UserFact> searchFacts(String userId, String query);
    void deleteFact(String factId);
    
    // 用户偏好
    void savePreference(UserPreference preference);
    UserPreference getPreference(String userId, String key);
    List<UserPreference> getAllPreferences(String userId);
    void deletePreference(String userId, String key);
    
    // 记忆检索
    List<UserMemory> retrieveRelevantMemories(String userId, String query, int limit);
    List<UserMemory> retrieveMemoriesByContext(String userId, Map<String, Object> context, int limit);
}
```

#### 2.2.3 MemoryManager（记忆管理器）

**职责**：
- 协调短期和长期记忆
- 提供统一的记忆访问接口
- 实现记忆提取和巩固的基础逻辑

**接口**：
```java
public interface MemoryManager {
    // 消息管理
    void saveMessage(String userId, String sessionId, ChatMessage message);
    ConversationContext getConversationContext(String userId, String sessionId, int messageLimit);
    
    // 记忆提取
    void extractAndSaveMemories(String userId, String sessionId);
    List<UserFact> extractFacts(String userId, List<ChatMessage> messages);
    
    // 记忆检索
    List<UserMemory> retrieveRelevantMemories(String userId, String query, int limit);
    List<UserMemory> retrieveMemoriesByContext(String userId, Map<String, Object> context, int limit);
    
    // 用户画像
    UserProfile getUserProfile(String userId);
}
```

#### 2.2.4 MemoryExtractor（记忆提取器）

**职责**：
- 从对话中提取重要信息
- 使用规则或LLM进行提取
- 验证和清理提取的记忆

**接口**：
```java
public interface MemoryExtractor {
    List<UserFact> extractFacts(String userId, List<ChatMessage> messages);
    List<UserPreference> extractPreferences(String userId, List<ChatMessage> messages);
    List<UserMemory> extractMemories(String userId, List<ChatMessage> messages);
    
    // 验证和清理
    List<UserFact> validateAndCleanFacts(List<UserFact> facts);
    List<UserPreference> validateAndCleanPreferences(List<UserPreference> preferences);
}
```

---

## 三、数据模型

### 3.1 ChatMessage（对话消息）

```java
@Data
@Builder
public class ChatMessage {
    private String id;
    private String sessionId;
    private String userId;
    private MessageRole role; // USER, ASSISTANT, SYSTEM
    private String content;
    private Map<String, Object> metadata;
    private Long timestamp;
    private Double importance; // 重要性评分 (0.0-1.0)
    private List<String> extractedFacts; // 提取的事实ID列表
}

enum MessageRole {
    USER,       // 用户消息
    ASSISTANT,  // AI助手消息
    SYSTEM      // 系统消息
}
```

### 3.2 UserFact（用户事实）

```java
@Data
@Document(collection = "user_facts")
public class UserFact {
    @Id
    private String id;
    
    private String userId;
    private String fact; // 事实描述
    private FactCategory category; // 事实类别
    private Double importance; // 重要性 (0.0-1.0)
    private Double confidence; // 置信度 (0.0-1.0)
    
    private String sourceSessionId; // 来源会话ID
    private Instant createdAt;
    private Instant lastAccessedAt;
    private Integer accessCount;
    
    private List<String> tags; // 标签
    private Map<String, Object> metadata; // 扩展元数据
    
    public enum FactCategory {
        PERSONAL,      // 个人信息
        PREFERENCE,    // 偏好
        HISTORY,       // 历史事件
        RELATIONSHIP,  // 人际关系
        WORK,          // 工作相关
        HEALTH,        // 健康信息
        FINANCE,       // 财务信息
        LOCATION,      // 位置信息
        CONTACT,       // 联系方式
        SKILL,         // 技能
        GOAL,          // 目标
        HABIT,         // 习惯
        OTHER          // 其他
    }
}
```

### 3.3 UserPreference（用户偏好）

```java
@Data
@Document(collection = "user_preferences")
public class UserPreference {
    @Id
    private String id;
    
    private String userId;
    private String key;
    private Object value;
    private PreferenceType type; // STRING, NUMBER, BOOLEAN, JSON, LIST, RATING
    private Double confidence; // 置信度 (0.0-1.0)
    
    private Instant updatedAt;
    private Integer accessCount;
    private Instant lastAccessedAt;
    private Map<String, Object> metadata;
    
    public void recordAccess() {
        this.lastAccessedAt = Instant.now();
        this.accessCount = (this.accessCount == null ? 0 : this.accessCount) + 1;
    }
    
    public enum PreferenceType {
        STRING,   // 字符串
        NUMBER,   // 数字
        BOOLEAN,  // 布尔值
        JSON,     // JSON对象
        LIST,     // 列表
        RATING    // 评分（1-5）
    }
}
```

### 3.4 UserMemory（用户记忆）

```java
@Data
@Document(collection = "user_memories")
public class UserMemory {
    @Id
    private String id;
    
    private String userId;
    private MemoryType type; // 记忆类型
    private MemoryImportance importance; // 重要性
    private String content; // 记忆内容
    
    private Map<String, Object> structuredData; // 结构化数据
    private MemorySource source; // 记忆来源
    private String sourceId; // 来源ID
    
    private Instant createdAt;
    private Instant lastAccessedAt;
    private Integer accessCount;
    private Double confidence; // 提取置信度
    
    private List<String> tags; // 标签
    private Map<String, Object> metadata; // 扩展元数据
}
```

---

## 四、实现细节

### 4.1 短期记忆实现（Redis）

#### 4.1.1 Redis数据结构

**对话消息**：
```
Key: short:msg:{sessionId}
Type: List
Value: JSON序列化的ChatMessage对象
TTL: 7天（默认）
```

**工作记忆**：
```
Key: short:work:{sessionId}:{key}
Type: String
Value: JSON序列化的对象
TTL: 24小时（默认）
```

**会话索引**：
```
Key: short:sessions:{userId}
Type: Set
Value: sessionId列表
TTL: 7天（默认）
```

#### 4.1.2 核心实现

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class RedisShortMemoryService implements ShortMemoryService {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private static final String MESSAGE_KEY_PREFIX = "short:msg:";
    private static final String WORKING_MEMORY_PREFIX = "short:work:";
    private static final String SESSION_INDEX_PREFIX = "short:sessions:";
    private static final int DEFAULT_MESSAGE_TTL = 3600 * 24 * 7; // 7天
    private static final int MAX_MESSAGES_PER_SESSION = 100;
    
    @Override
    public void saveMessage(String sessionId, ChatMessage message) {
        String key = MESSAGE_KEY_PREFIX + sessionId;
        
        // 使用List存储消息，按时间顺序
        redisTemplate.opsForList().rightPush(key, message);
        
        // 限制消息数量
        Long size = redisTemplate.opsForList().size(key);
        if (size != null && size > MAX_MESSAGES_PER_SESSION) {
            redisTemplate.opsForList().leftPop(key);
        }
        
        // 设置过期时间
        redisTemplate.expire(key, Duration.ofSeconds(DEFAULT_MESSAGE_TTL));
        
        // 更新会话索引
        String sessionIndexKey = SESSION_INDEX_PREFIX + message.getUserId();
        redisTemplate.opsForSet().add(sessionIndexKey, sessionId);
        redisTemplate.expire(sessionIndexKey, Duration.ofSeconds(DEFAULT_MESSAGE_TTL));
    }
    
    @Override
    public List<ChatMessage> getMessages(String sessionId, int limit) {
        String key = MESSAGE_KEY_PREFIX + sessionId;
        
        Long size = redisTemplate.opsForList().size(key);
        if (size == null || size == 0) {
            return Collections.emptyList();
        }
        
        int start = Math.max(0, (int)(size - limit));
        List<Object> messages = redisTemplate.opsForList().range(key, start, -1);
        
        return messages.stream()
            .map(msg -> (ChatMessage) msg)
            .collect(Collectors.toList());
    }
    
    // ... 其他方法实现
}
```

### 4.2 长期记忆实现（MongoDB）

#### 4.2.1 MongoDB集合设计

**user_facts集合**：
```javascript
{
  _id: ObjectId,
  userId: String,
  fact: String,
  category: String,
  importance: Number,
  confidence: Number,
  sourceSessionId: String,
  createdAt: Date,
  lastAccessedAt: Date,
  accessCount: Number,
  tags: [String],
  metadata: Object
}

// 索引
db.user_facts.createIndex({ userId: 1, category: 1 });
db.user_facts.createIndex({ userId: 1, importance: -1 });
db.user_facts.createIndex({ fact: "text" }); // 文本搜索索引
```

**user_preferences集合**：
```javascript
{
  _id: ObjectId,
  userId: String,
  key: String,
  value: Object,
  type: String,
  confidence: Number,
  updatedAt: Date,
  accessCount: Number,
  lastAccessedAt: Date,
  metadata: Object
}

// 索引
db.user_preferences.createIndex({ userId: 1, key: 1 }, { unique: true });
```

#### 4.2.2 核心实现

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class MongoLongMemoryService implements LongMemoryService {
    
    private final MongoTemplate mongoTemplate;
    
    @Override
    public void saveFact(UserFact fact) {
        if (fact.getCreatedAt() == null) {
            fact.setCreatedAt(Instant.now());
        }
        mongoTemplate.save(fact);
    }
    
    @Override
    public List<UserFact> getAllFacts(String userId) {
        Query query = new Query(Criteria.where("userId").is(userId));
        return mongoTemplate.find(query, UserFact.class);
    }
    
    @Override
    public List<UserFact> searchFacts(String userId, String query) {
        // 使用MongoDB文本搜索
        TextCriteria criteria = TextCriteria.forDefaultLanguage()
            .matchingAny(query);
        
        Query mongoQuery = new Query(criteria)
            .addCriteria(Criteria.where("userId").is(userId));
        
        return mongoTemplate.find(mongoQuery, UserFact.class);
    }
    
    // ... 其他方法实现
}
```

### 4.3 记忆提取实现

#### 4.3.1 规则提取（备用方案）

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class RuleBasedMemoryExtractor implements MemoryExtractor {
    
    @Override
    public List<UserFact> extractFacts(String userId, List<ChatMessage> messages) {
        List<UserFact> facts = new ArrayList<>();
        
        for (ChatMessage message : messages) {
            if (message.getRole() != MessageRole.USER) {
                continue;
            }
            
            String content = message.getContent();
            
            // 提取姓名
            facts.addAll(extractNames(userId, content, message.getId()));
            
            // 提取偏好
            facts.addAll(extractPreferences(userId, content, message.getId()));
            
            // 提取其他信息
            facts.addAll(extractOtherFacts(userId, content, message.getId()));
        }
        
        return validateAndCleanFacts(facts);
    }
    
    private List<UserFact> extractNames(String userId, String content, String sourceId) {
        List<UserFact> facts = new ArrayList<>();
        
        // 使用正则表达式提取姓名
        Pattern pattern = Pattern.compile("我(叫|是)([\\u4e00-\\u9fa5]{2,4})");
        Matcher matcher = pattern.matcher(content);
        
        while (matcher.find()) {
            String name = matcher.group(2);
            UserFact fact = UserFact.builder()
                .userId(userId)
                .fact("名字: " + name)
                .category(UserFact.FactCategory.PERSONAL)
                .importance(0.9)
                .confidence(0.8)
                .sourceSessionId(sourceId)
                .createdAt(Instant.now())
                .build();
            facts.add(fact);
        }
        
        return facts;
    }
    
    // ... 其他提取方法
}
```

#### 4.3.2 LLM提取（主要方案）

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class LLMMemoryExtractor implements MemoryExtractor {
    
    private final AIService aiService;
    
    @Override
    public List<UserFact> extractFacts(String userId, List<ChatMessage> messages) {
        String conversationText = messages.stream()
            .map(ChatMessage::getContent)
            .collect(Collectors.joining("\n"));
        
        String prompt = buildFactExtractionPrompt(conversationText);
        String response = aiService.generateText(prompt, FACT_EXTRACTION_INSTRUCTION);
        
        return parseExtractedFacts(userId, response);
    }
    
    private String buildFactExtractionPrompt(String conversation) {
        return String.format("""
            请从以下对话中提取用户的重要事实信息。
            
            对话内容：
            %s
            
            请提取：
            1. 个人信息（姓名、年龄、职业等）
            2. 重要事件
            3. 关系信息
            4. 偏好信息
            
            返回JSON格式，包含：
            - fact: 事实描述
            - category: 事实类别（PERSONAL, PREFERENCE, HISTORY, RELATIONSHIP等）
            - importance: 重要性评分 (0.0-1.0)
            - confidence: 置信度 (0.0-1.0)
            """, conversation);
    }
    
    private List<UserFact> parseExtractedFacts(String userId, String response) {
        try {
            ObjectMapper mapper = new ObjectMapper();
            List<Map<String, Object>> factsJson = mapper.readValue(response, List.class);
            
            return factsJson.stream()
                .map(json -> {
                    UserFact fact = new UserFact();
                    fact.setUserId(userId);
                    fact.setFact((String) json.get("fact"));
                    fact.setCategory(UserFact.FactCategory.valueOf((String) json.get("category")));
                    fact.setImportance(((Number) json.get("importance")).doubleValue());
                    fact.setConfidence(((Number) json.get("confidence")).doubleValue());
                    fact.setCreatedAt(Instant.now());
                    return fact;
                })
                .collect(Collectors.toList());
        } catch (Exception e) {
            log.error("解析提取的事实失败", e);
            return Collections.emptyList();
        }
    }
}
```

---

## 五、REST API设计

### 5.1 短期记忆API

#### 5.1.1 消息管理

**保存消息**：
```
POST /api/memory/v1/sessions/{sessionId}/messages
Content-Type: application/json

{
  "role": "USER",
  "content": "你好，我叫张三",
  "metadata": {}
}

Response: 201 Created
{
  "id": "msg-123",
  "sessionId": "session-456",
  "role": "USER",
  "content": "你好，我叫张三",
  "timestamp": 1703683200000
}
```

**获取消息**：
```
GET /api/memory/v1/sessions/{sessionId}/messages?limit=20

Response: 200 OK
{
  "messages": [
    {
      "id": "msg-123",
      "role": "USER",
      "content": "你好，我叫张三",
      "timestamp": 1703683200000
    }
  ],
  "total": 1
}
```

#### 5.1.2 工作记忆

**保存工作记忆**：
```
POST /api/memory/v1/sessions/{sessionId}/working-memory
Content-Type: application/json

{
  "key": "currentTask",
  "value": {
    "task": "预订机票",
    "status": "in_progress"
  }
}

Response: 201 Created
```

**获取工作记忆**：
```
GET /api/memory/v1/sessions/{sessionId}/working-memory/{key}

Response: 200 OK
{
  "key": "currentTask",
  "value": {
    "task": "预订机票",
    "status": "in_progress"
  },
  "timestamp": 1703683200000
}
```

### 5.2 长期记忆API

#### 5.2.1 用户事实

**保存事实**：
```
POST /api/memory/v1/users/{userId}/facts
Content-Type: application/json

{
  "fact": "名字: 张三",
  "category": "PERSONAL",
  "importance": 0.9,
  "confidence": 0.8,
  "tags": ["基本信息"]
}

Response: 201 Created
{
  "id": "fact-123",
  "userId": "user-456",
  "fact": "名字: 张三",
  "category": "PERSONAL",
  "createdAt": "2025-12-28T10:00:00Z"
}
```

**搜索事实**：
```
GET /api/memory/v1/users/{userId}/facts/search?query=张三&limit=10

Response: 200 OK
{
  "facts": [
    {
      "id": "fact-123",
      "fact": "名字: 张三",
      "category": "PERSONAL",
      "importance": 0.9
    }
  ],
  "total": 1
}
```

#### 5.2.2 用户偏好

**保存偏好**：
```
POST /api/memory/v1/users/{userId}/preferences
Content-Type: application/json

{
  "key": "language",
  "value": "zh-CN",
  "type": "STRING",
  "confidence": 0.9
}

Response: 201 Created
```

**获取偏好**：
```
GET /api/memory/v1/users/{userId}/preferences/{key}

Response: 200 OK
{
  "id": "pref-123",
  "userId": "user-456",
  "key": "language",
  "value": "zh-CN",
  "type": "STRING",
  "updatedAt": "2025-12-28T10:00:00Z"
}
```

### 5.3 记忆提取API

**从会话提取记忆**：
```
POST /api/memory/v1/users/{userId}/sessions/{sessionId}/extract

Response: 200 OK
{
  "extractedFacts": 5,
  "extractedPreferences": 2,
  "facts": [
    {
      "id": "fact-123",
      "fact": "名字: 张三",
      "category": "PERSONAL",
      "confidence": 0.9
    }
  ]
}
```

---

## 六、测试计划

### 6.1 单元测试

- 短期记忆服务的读写操作
- 长期记忆服务的CRUD操作
- 记忆提取器的提取逻辑
- 记忆管理器的协调逻辑

### 6.2 集成测试

- Redis和MongoDB的集成
- API接口的端到端测试
- 记忆提取和存储的完整流程

### 6.3 性能测试

- 短期记忆读写性能
- 长期记忆检索性能
- 并发访问测试
- 大数据量测试

---

## 七、交付清单

### 7.1 代码交付

- [ ] ShortMemoryService实现
- [ ] LongMemoryService实现
- [ ] MemoryManager实现
- [ ] MemoryExtractor实现
- [ ] REST API Controller
- [ ] 数据模型定义
- [ ] 配置文件

### 7.2 文档交付

- [ ] API文档
- [ ] 数据库设计文档
- [ ] 部署文档
- [ ] 测试报告

### 7.3 测试交付

- [ ] 单元测试（覆盖率 > 80%）
- [ ] 集成测试
- [ ] 性能测试报告

---

## 八、风险评估

### 8.1 技术风险

- **Redis性能**：大量并发访问可能影响性能
  - 缓解措施：使用Redis Cluster，优化数据结构
  
- **MongoDB查询性能**：复杂查询可能较慢
  - 缓解措施：合理设计索引，优化查询语句

### 8.2 业务风险

- **记忆提取准确率**：LLM提取可能不准确
  - 缓解措施：使用规则提取作为备用，人工审核重要记忆

---

## 九、后续阶段准备

阶段一完成后，为阶段二做准备：

1. 设计角色记忆的数据模型
2. 设计角色记忆的API接口
3. 规划角色记忆与用户记忆的关系



