# 长期记忆与短期记忆设计详解

**文档版本**: V1.0  
**编写日期**: 2025-12-28

---

## 一、设计理念

### 1.1 理论基础

记忆系统的设计基于认知科学的记忆理论：

- **短期记忆（Short-term Memory）**：类似人类的工作记忆，容量有限（7±2个信息块），保持时间短（几秒到几小时），需要快速访问
- **长期记忆（Long-term Memory）**：类似人类的长期记忆，容量几乎无限，保持时间长（几天到终身），需要持久化存储

### 1.2 核心区别

| 特性 | 短期记忆 | 长期记忆 |
|------|---------|---------|
| **存储介质** | Redis（内存） | MongoDB（磁盘） |
| **访问速度** | < 10ms | < 100ms |
| **容量限制** | 有限（每会话最多100条消息） | 几乎无限 |
| **保持时间** | 7天（TTL自动过期） | 永久（除非手动删除） |
| **数据内容** | 对话上下文、会话状态、工作记忆 | 用户事实、偏好、角色记忆、关系记忆 |
| **检索方式** | 顺序访问（List） | 索引查询、文本搜索、语义搜索 |
| **使用场景** | 当前对话上下文 | 跨会话记忆、用户画像、个性化推荐 |

---

## 二、短期记忆（Short Memory）设计

### 2.1 功能定位

短期记忆用于管理**当前对话会话的上下文信息**，具有以下特点：

1. **临时性**：只在当前会话中有效，会话结束后自动清理
2. **快速访问**：需要毫秒级响应，使用内存存储
3. **容量限制**：遵循"7±2"原则，限制上下文窗口大小
4. **自动清理**：基于TTL自动过期，无需手动管理

### 2.2 数据结构设计

#### 2.2.1 Redis数据结构

**1. 对话消息（ChatMessage）**
```
Key: short:msg:{sessionId}
Type: List
Value: JSON序列化的ChatMessage对象列表
TTL: 7天
最大长度: 100条消息
```

**存储示例**：
```json
[
  {
    "id": "msg-001",
    "sessionId": "session-123",
    "userId": "user-456",
    "role": "USER",
    "content": "你好，我叫张三",
    "timestamp": 1703683200000,
    "importance": 0.8
  },
  {
    "id": "msg-002",
    "sessionId": "session-123",
    "userId": "user-456",
    "role": "ASSISTANT",
    "content": "你好张三，很高兴认识你！",
    "timestamp": 1703683201000,
    "importance": 0.6
  }
]
```

**2. 工作记忆（Working Memory）**
```
Key: short:work:{sessionId}:{key}
Type: String
Value: JSON序列化的对象
TTL: 24小时
```

**存储示例**：
```json
{
  "key": "currentTask",
  "value": {
    "task": "预订机票",
    "status": "in_progress",
    "params": {
      "destination": "北京",
      "date": "2025-12-30"
    }
  },
  "timestamp": 1703683200000
}
```

**3. 会话索引（Session Index）**
```
Key: short:sessions:{userId}
Type: Set
Value: sessionId列表
TTL: 7天
```

**存储示例**：
```
["session-123", "session-456", "session-789"]
```

### 2.3 数据模型

```java
@Data
@Builder
public class ChatMessage {
    private String id;                    // 消息ID
    private String sessionId;             // 会话ID
    private String userId;                // 用户ID
    private MessageRole role;             // 角色：USER, ASSISTANT, SYSTEM
    private String content;                // 消息内容
    private Map<String, Object> metadata; // 元数据
    private Long timestamp;               // 时间戳
    private Double importance;            // 重要性评分 (0.0-1.0)
    private List<String> extractedFacts; // 已提取的事实ID列表
}
```

### 2.4 核心实现

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class RedisShortMemoryService implements ShortMemoryService {
    
    private final RedisTemplate<String, Object> redisTemplate;
    
    // Key前缀
    private static final String MESSAGE_KEY_PREFIX = "short:msg:";
    private static final String WORKING_MEMORY_PREFIX = "short:work:";
    private static final String SESSION_INDEX_PREFIX = "short:sessions:";
    
    // 配置参数
    private static final int DEFAULT_MESSAGE_TTL = 3600 * 24 * 7; // 7天
    private static final int MAX_MESSAGES_PER_SESSION = 100;      // 最多100条消息
    
    /**
     * 保存消息到短期记忆
     */
    @Override
    public void saveMessage(String sessionId, ChatMessage message) {
        String key = MESSAGE_KEY_PREFIX + sessionId;
        
        // 1. 使用List存储消息，按时间顺序（右端插入）
        redisTemplate.opsForList().rightPush(key, message);
        
        // 2. 限制消息数量（遵循容量限制原则）
        Long size = redisTemplate.opsForList().size(key);
        if (size != null && size > MAX_MESSAGES_PER_SESSION) {
            // 超过限制，删除最旧的消息（左端弹出）
            redisTemplate.opsForList().leftPop(key);
        }
        
        // 3. 设置过期时间（自动清理）
        redisTemplate.expire(key, Duration.ofSeconds(DEFAULT_MESSAGE_TTL));
        
        // 4. 更新会话索引
        String sessionIndexKey = SESSION_INDEX_PREFIX + message.getUserId();
        redisTemplate.opsForSet().add(sessionIndexKey, sessionId);
        redisTemplate.expire(sessionIndexKey, Duration.ofSeconds(DEFAULT_MESSAGE_TTL));
    }
    
    /**
     * 获取消息列表（最近N条）
     */
    @Override
    public List<ChatMessage> getMessages(String sessionId, int limit) {
        String key = MESSAGE_KEY_PREFIX + sessionId;
        
        Long size = redisTemplate.opsForList().size(key);
        if (size == null || size == 0) {
            return Collections.emptyList();
        }
        
        // 计算起始位置（从后往前取）
        int start = Math.max(0, (int)(size - limit));
        
        // 获取指定范围的消息
        List<Object> messages = redisTemplate.opsForList().range(key, start, -1);
        
        return messages.stream()
            .map(msg -> (ChatMessage) msg)
            .collect(Collectors.toList());
    }
    
    /**
     * 保存工作记忆（临时状态）
     */
    @Override
    public void saveWorkingMemory(String sessionId, String key, Object value) {
        String redisKey = WORKING_MEMORY_PREFIX + sessionId + ":" + key;
        
        WorkingMemory workingMemory = WorkingMemory.builder()
            .sessionId(sessionId)
            .key(key)
            .value(value)
            .timestamp(System.currentTimeMillis())
            .ttl(DEFAULT_MESSAGE_TTL * 1000L)
            .build();
        
        // 保存并设置过期时间（24小时）
        redisTemplate.opsForValue().set(
            redisKey, 
            workingMemory, 
            Duration.ofHours(24)
        );
    }
    
    /**
     * 获取工作记忆
     */
    @Override
    @SuppressWarnings("unchecked")
    public <T> T getWorkingMemory(String sessionId, String key, Class<T> type) {
        String redisKey = WORKING_MEMORY_PREFIX + sessionId + ":" + key;
        WorkingMemory workingMemory = (WorkingMemory) redisTemplate.opsForValue().get(redisKey);
        
        if (workingMemory == null) {
            return null;
        }
        
        return type.cast(workingMemory.getValue());
    }
    
    /**
     * 清空会话记忆
     */
    @Override
    public void clearSession(String sessionId) {
        // 删除消息列表
        String messageKey = MESSAGE_KEY_PREFIX + sessionId;
        redisTemplate.delete(messageKey);
        
        // 删除所有工作记忆
        String workingMemoryPattern = WORKING_MEMORY_PREFIX + sessionId + ":*";
        Set<String> keys = redisTemplate.keys(workingMemoryPattern);
        if (keys != null && !keys.isEmpty()) {
            redisTemplate.delete(keys);
        }
    }
}
```

### 2.5 使用场景

1. **对话上下文管理**
   ```java
   // 保存用户消息
   ChatMessage userMessage = ChatMessage.builder()
       .id(UUID.randomUUID().toString())
       .sessionId(sessionId)
       .userId(userId)
       .role(MessageRole.USER)
       .content("你好，我叫张三")
       .timestamp(System.currentTimeMillis())
       .build();
   shortMemoryService.saveMessage(sessionId, userMessage);
   
   // 获取最近20条消息作为上下文
   List<ChatMessage> context = shortMemoryService.getMessages(sessionId, 20);
   ```

2. **工作记忆管理**
   ```java
   // 保存当前任务状态
   Map<String, Object> taskState = new HashMap<>();
   taskState.put("task", "预订机票");
   taskState.put("status", "in_progress");
   shortMemoryService.saveWorkingMemory(sessionId, "currentTask", taskState);
   
   // 获取任务状态
   Map<String, Object> currentTask = shortMemoryService.getWorkingMemory(
       sessionId, "currentTask", Map.class);
   ```

---

## 三、长期记忆（Long Memory）设计

### 3.1 功能定位

长期记忆用于存储**用户的持久化信息**，具有以下特点：

1. **持久性**：长期保存，不会自动删除（除非用户主动删除或重要性过低）
2. **结构化**：支持复杂的数据结构（用户事实、偏好、决策记录等）
3. **可检索**：支持丰富的查询和检索（关键词、语义、关联检索）
4. **可关联**：支持记忆之间的关联关系（标签、主题、时间等）

### 3.2 数据结构设计

#### 3.2.1 MongoDB集合设计

**1. user_facts（用户事实）集合**

```javascript
{
  _id: ObjectId("..."),
  userId: "user-456",
  fact: "名字: 张三",
  category: "PERSONAL",        // 事实类别
  importance: 0.9,              // 重要性 (0.0-1.0)
  confidence: 0.8,              // 置信度 (0.0-1.0)
  sourceSessionId: "session-123", // 来源会话ID
  createdAt: ISODate("2025-12-28T10:00:00Z"),
  lastAccessedAt: ISODate("2025-12-28T10:00:00Z"),
  accessCount: 5,               // 访问次数
  tags: ["基本信息", "个人信息"], // 标签
  metadata: {                   // 扩展元数据
    extractedBy: "LLM",
    extractionMethod: "auto"
  }
}

// 索引
db.user_facts.createIndex({ userId: 1, category: 1 });
db.user_facts.createIndex({ userId: 1, importance: -1 });
db.user_facts.createIndex({ fact: "text" }); // 文本搜索索引
db.user_facts.createIndex({ userId: 1, lastAccessedAt: -1 });
```

**2. user_preferences（用户偏好）集合**

```javascript
{
  _id: ObjectId("..."),
  userId: "user-456",
  key: "language",
  value: "zh-CN",
  type: "STRING",               // STRING, NUMBER, BOOLEAN, JSON, LIST, RATING
  confidence: 0.9,
  updatedAt: ISODate("2025-12-28T10:00:00Z"),
  accessCount: 10,
  lastAccessedAt: ISODate("2025-12-28T10:00:00Z"),
  metadata: {}
}

// 索引
db.user_preferences.createIndex({ userId: 1, key: 1 }, { unique: true });
db.user_preferences.createIndex({ userId: 1, updatedAt: -1 });
```

**3. user_memories（用户记忆）集合**

```javascript
{
  _id: ObjectId("..."),
  userId: "user-456",
  type: "PREFERENCE",           // 记忆类型
  importance: "IMPORTANT",      // 重要性级别
  content: "用户喜欢喝咖啡",
  structuredData: {            // 结构化数据
    key: "coffee_preference",
    value: "latte"
  },
  source: "CONVERSATION",      // 记忆来源
  sourceId: "session-123",
  createdAt: ISODate("2025-12-28T10:00:00Z"),
  lastAccessedAt: ISODate("2025-12-28T10:00:00Z"),
  accessCount: 3,
  confidence: 0.85,
  tags: ["偏好", "饮食"],
  metadata: {}
}
```

### 3.3 数据模型

```java
/**
 * 用户事实
 */
@Data
@Document(collection = "user_facts")
public class UserFact {
    @Id
    private String id;
    
    private String userId;
    private String fact;                    // 事实描述
    private FactCategory category;          // 事实类别
    private Double importance;              // 重要性 (0.0-1.0)
    private Double confidence;              // 置信度 (0.0-1.0)
    
    private String sourceSessionId;        // 来源会话ID
    private Instant createdAt;
    private Instant lastAccessedAt;
    private Integer accessCount;
    
    private List<String> tags;             // 标签
    private Map<String, Object> metadata;   // 扩展元数据
    
    public enum FactCategory {
        PERSONAL,      // 个人信息
        PREFERENCE,    // 偏好
        HISTORY,       // 历史事件
        RELATIONSHIP,  // 人际关系
        WORK,          // 工作相关
        HEALTH,        // 健康信息
        FINANCE,       // 财务信息
        LOCATION,      // 位置信息
        CONTACT,       // 联系方式
        SKILL,         // 技能
        GOAL,          // 目标
        HABIT,         // 习惯
        OTHER          // 其他
    }
    
    /**
     * 计算衰减后的重要性
     */
    public double getDecayedImportance() {
        if (lastAccessedAt == null) {
            return importance;
        }
        
        // 时间衰减（7天衰减一半）
        long daysSinceLastAccess = Duration.between(lastAccessedAt, Instant.now()).toDays();
        double timeDecay = Math.exp(-daysSinceLastAccess / 7.0);
        
        // 访问频率加成
        double accessBonus = Math.log(1 + (accessCount == null ? 0 : accessCount)) / 10.0;
        
        return importance * timeDecay + accessBonus;
    }
}
```

### 3.4 核心实现

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class MongoLongMemoryService implements LongMemoryService {
    
    private final MongoTemplate mongoTemplate;
    
    /**
     * 保存用户事实
     */
    @Override
    public void saveFact(UserFact fact) {
        if (fact.getCreatedAt() == null) {
            fact.setCreatedAt(Instant.now());
        }
        mongoTemplate.save(fact);
    }
    
    /**
     * 批量保存事实
     */
    @Override
    public void saveFacts(List<UserFact> facts) {
        facts.forEach(fact -> {
            if (fact.getCreatedAt() == null) {
                fact.setCreatedAt(Instant.now());
            }
        });
        mongoTemplate.insertAll(facts);
    }
    
    /**
     * 获取所有事实
     */
    @Override
    public List<UserFact> getAllFacts(String userId) {
        Query query = new Query(Criteria.where("userId").is(userId));
        return mongoTemplate.find(query, UserFact.class);
    }
    
    /**
     * 按类别获取事实
     */
    @Override
    public List<UserFact> getFactsByCategory(String userId, FactCategory category) {
        Query query = new Query();
        query.addCriteria(Criteria.where("userId").is(userId))
             .addCriteria(Criteria.where("category").is(category));
        return mongoTemplate.find(query, UserFact.class);
    }
    
    /**
     * 获取重要事实
     */
    @Override
    public List<UserFact> getImportantFacts(String userId, double minImportance) {
        Query query = new Query(Criteria.where("userId").is(userId));
        List<UserFact> allFacts = mongoTemplate.find(query, UserFact.class);
        
        return allFacts.stream()
            .filter(fact -> fact.getDecayedImportance() >= minImportance)
            .sorted(Comparator.comparing(UserFact::getDecayedImportance).reversed())
            .collect(Collectors.toList());
    }
    
    /**
     * 搜索事实（文本搜索）
     */
    @Override
    public List<UserFact> searchFacts(String userId, String query) {
        // 使用MongoDB文本搜索
        TextCriteria criteria = TextCriteria.forDefaultLanguage()
            .matchingAny(query);
        
        Query mongoQuery = new Query(criteria)
            .addCriteria(Criteria.where("userId").is(userId));
        
        return mongoTemplate.find(mongoQuery, UserFact.class);
    }
    
    /**
     * 保存用户偏好
     */
    @Override
    public void savePreference(UserPreference preference) {
        preference.setUpdatedAt(Instant.now());
        mongoTemplate.save(preference);
    }
    
    /**
     * 获取用户偏好
     */
    @Override
    public UserPreference getPreference(String userId, String key) {
        Query query = new Query();
        query.addCriteria(Criteria.where("userId").is(userId))
             .addCriteria(Criteria.where("key").is(key));
        
        UserPreference preference = mongoTemplate.findOne(query, UserPreference.class);
        if (preference != null) {
            preference.recordAccess();
            mongoTemplate.save(preference);
        }
        
        return preference;
    }
    
    /**
     * 检索相关记忆
     */
    @Override
    public List<UserMemory> retrieveRelevantMemories(String userId, String query, int limit) {
        // 1. 搜索用户事实
        List<UserFact> facts = searchFacts(userId, query);
        
        // 2. 搜索用户偏好
        List<UserPreference> preferences = getAllPreferences(userId);
        
        // 3. 计算相关性并排序
        List<UserMemory> memories = new ArrayList<>();
        
        facts.forEach(fact -> {
            double relevance = calculateRelevance(fact.getFact(), query);
            memories.add(new FactMemory(fact, relevance));
        });
        
        preferences.forEach(pref -> {
            double relevance = calculateRelevance(
                pref.getKey() + " " + pref.getValue().toString(), query);
            memories.add(new PreferenceMemory(pref, relevance));
        });
        
        // 4. 按相关性排序并返回top N
        return memories.stream()
            .sorted(Comparator.comparing(Memory::getRelevance).reversed())
            .limit(limit)
            .collect(Collectors.toList());
    }
    
    private double calculateRelevance(String text, String query) {
        // 简单的关键词匹配相关性计算
        // 实际可以使用更复杂的算法（如TF-IDF、语义相似度等）
        String[] queryWords = query.toLowerCase().split("\\s+");
        String lowerText = text.toLowerCase();
        
        int matches = 0;
        for (String word : queryWords) {
            if (lowerText.contains(word)) {
                matches++;
            }
        }
        
        return matches / (double) queryWords.length;
    }
}
```

### 3.5 使用场景

1. **保存用户事实**
   ```java
   UserFact fact = UserFact.builder()
       .userId(userId)
       .fact("名字: 张三")
       .category(FactCategory.PERSONAL)
       .importance(0.9)
       .confidence(0.8)
       .sourceSessionId(sessionId)
       .createdAt(Instant.now())
       .tags(Arrays.asList("基本信息", "个人信息"))
       .build();
   longMemoryService.saveFact(fact);
   ```

2. **检索相关记忆**
   ```java
   // 检索与"咖啡"相关的记忆
   List<UserMemory> memories = longMemoryService.retrieveRelevantMemories(
       userId, "咖啡", 10);
   
   // 结果可能包括：
   // - 用户事实："喜欢喝拿铁咖啡"
   // - 用户偏好：key="coffee_type", value="latte"
   ```

---

## 四、记忆巩固机制（从短期到长期）

### 4.1 巩固流程

```
短期记忆（Redis）
    ↓
[记忆提取] ← 使用LLM或规则提取重要信息
    ↓
[重要性评估] ← 评估提取的记忆的重要性
    ↓
[去重检查] ← 检查是否已存在相似记忆
    ↓
[保存到长期记忆] ← 保存到MongoDB
    ↓
长期记忆（MongoDB）
```

### 4.2 实现示例

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class MemoryConsolidationService {
    
    private final ShortMemoryService shortMemoryService;
    private final LongMemoryService longMemoryService;
    private final MemoryExtractor memoryExtractor;
    
    /**
     * 从会话中提取并巩固记忆
     */
    @Async
    public void consolidateSessionMemories(String userId, String sessionId) {
        try {
            // 1. 获取短期记忆（对话历史）
            List<ChatMessage> messages = shortMemoryService.getMessages(sessionId, 50);
            
            // 2. 提取重要信息
            List<UserFact> facts = memoryExtractor.extractFacts(userId, messages);
            List<UserPreference> preferences = memoryExtractor.extractPreferences(userId, messages);
            
            // 3. 验证和清理
            facts = memoryExtractor.validateAndCleanFacts(facts);
            preferences = memoryExtractor.validateAndCleanPreferences(preferences);
            
            // 4. 去重检查
            facts = removeDuplicateFacts(userId, facts);
            preferences = removeDuplicatePreferences(userId, preferences);
            
            // 5. 保存到长期记忆
            if (!facts.isEmpty()) {
                longMemoryService.saveFacts(facts);
            }
            
            if (!preferences.isEmpty()) {
                preferences.forEach(longMemoryService::savePreference);
            }
            
            log.info("记忆巩固完成: userId={}, sessionId={}, facts={}, preferences={}", 
                userId, sessionId, facts.size(), preferences.size());
            
        } catch (Exception e) {
            log.error("记忆巩固失败: userId={}, sessionId={}", userId, sessionId, e);
        }
    }
    
    private List<UserFact> removeDuplicateFacts(String userId, List<UserFact> newFacts) {
        List<UserFact> existingFacts = longMemoryService.getAllFacts(userId);
        
        return newFacts.stream()
            .filter(newFact -> {
                // 检查是否存在相似的事实
                return existingFacts.stream()
                    .noneMatch(existingFact -> 
                        isSimilarFact(existingFact, newFact));
            })
            .collect(Collectors.toList());
    }
    
    private boolean isSimilarFact(UserFact fact1, UserFact fact2) {
        // 简单的相似度检查（实际可以使用更复杂的算法）
        return fact1.getFact().equals(fact2.getFact()) ||
               fact1.getFact().contains(fact2.getFact()) ||
               fact2.getFact().contains(fact1.getFact());
    }
}
```

---

## 五、记忆检索策略

### 5.1 混合检索

```java
@Service
@RequiredArgsConstructor
public class MemoryRetrievalService {
    
    private final ShortMemoryService shortMemoryService;
    private final LongMemoryService longMemoryService;
    
    /**
     * 获取完整的对话上下文（短期 + 长期记忆）
     */
    public ConversationContext getConversationContext(
            String userId, String sessionId, int messageLimit) {
        
        // 1. 获取短期记忆（最近N条消息）
        List<ChatMessage> messages = shortMemoryService.getMessages(sessionId, messageLimit);
        
        // 2. 构建查询关键词（从最近消息中提取）
        String query = buildQueryFromMessages(messages);
        
        // 3. 获取相关长期记忆
        List<UserMemory> relevantMemories = longMemoryService.retrieveRelevantMemories(
            userId, query, 10);
        
        // 4. 获取用户偏好
        List<UserPreference> preferences = longMemoryService.getAllPreferences(userId);
        
        // 5. 构建上下文
        return ConversationContext.builder()
            .userId(userId)
            .sessionId(sessionId)
            .messages(messages)                    // 短期记忆
            .relevantMemories(relevantMemories)     // 相关长期记忆
            .userPreferences(preferences)           // 用户偏好
            .build();
    }
    
    private String buildQueryFromMessages(List<ChatMessage> messages) {
        // 从消息中提取关键词用于检索长期记忆
        return messages.stream()
            .map(ChatMessage::getContent)
            .limit(5)  // 只使用最近5条消息
            .collect(Collectors.joining(" "));
    }
}
```

---

## 六、总结

### 6.1 设计要点

1. **清晰分离**：短期记忆和长期记忆职责明确，互不干扰
2. **自动转换**：通过记忆巩固机制，重要信息自动从短期转为长期
3. **高效检索**：短期记忆快速访问，长期记忆支持复杂查询
4. **容量管理**：短期记忆有容量限制，长期记忆支持扩展

### 6.2 性能指标

- **短期记忆**：读写延迟 < 10ms，支持高并发
- **长期记忆**：检索延迟 < 100ms，支持复杂查询
- **记忆巩固**：异步处理，不影响主流程

### 6.3 扩展性

- **短期记忆**：可以扩展到Redis Cluster支持更大规模
- **长期记忆**：可以添加向量搜索、语义检索等高级功能
- **记忆类型**：可以扩展更多记忆类型（角色记忆、参与者记忆等）

