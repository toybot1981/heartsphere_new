# 记忆系统使用指南

**文档版本**: V1.0  
**编写日期**: 2025-12-28

---

## 一、快速开始

### 1.1 基础使用

#### 1.1.1 保存用户记忆

```java
@RestController
@RequiredArgsConstructor
public class MemoryController {
    
    private final MemoryManager memoryManager;
    
    @PostMapping("/chat")
    public ChatResponse chat(@RequestBody ChatRequest request) {
        String userId = request.getUserId();
        String sessionId = request.getSessionId();
        String message = request.getMessage();
        
        // 1. 保存用户消息
        ChatMessage chatMessage = ChatMessage.builder()
            .id(UUID.randomUUID().toString())
            .sessionId(sessionId)
            .userId(userId)
            .role(MessageRole.USER)
            .content(message)
            .timestamp(System.currentTimeMillis())
            .build();
        
        memoryManager.saveMessage(userId, sessionId, chatMessage);
        
        // 2. 获取对话上下文（包含相关记忆）
        ConversationContext context = memoryManager.getConversationContext(
            userId, sessionId, 20);
        
        // 3. 生成AI回复（使用上下文）
        String response = generateAIResponse(context, message);
        
        // 4. 保存AI回复
        ChatMessage aiMessage = ChatMessage.builder()
            .id(UUID.randomUUID().toString())
            .sessionId(sessionId)
            .userId(userId)
            .role(MessageRole.ASSISTANT)
            .content(response)
            .timestamp(System.currentTimeMillis())
            .build();
        
        memoryManager.saveMessage(userId, sessionId, aiMessage);
        
        // 5. 异步提取记忆（重要信息转为长期记忆）
        memoryManager.extractAndSaveMemories(userId, sessionId);
        
        return ChatResponse.builder()
            .message(response)
            .build();
    }
}
```

### 1.2 角色记忆使用

```java
@Service
@RequiredArgsConstructor
public class CharacterService {
    
    private final CharacterMemoryService characterMemoryService;
    
    public void saveCharacterMemory(String characterId, String userId, String content) {
        // 保存角色与用户的交互记忆
        CharacterInteractionMemory memory = new CharacterInteractionMemory();
        memory.setCharacterId(characterId);
        memory.setUserId(userId);
        memory.setContent(content);
        memory.setType(MemoryType.CONVERSATION_TOPIC);
        memory.setImportance(MemoryImportance.NORMAL);
        memory.setInteractionType(InteractionType.CONVERSATION);
        
        characterMemoryService.saveInteractionMemory(memory);
    }
    
    public List<CharacterInteractionMemory> getCharacterMemories(
            String characterId, String userId) {
        // 获取角色与用户的交互记忆
        return characterMemoryService.getInteractionMemories(characterId, userId);
    }
}
```

---

## 二、最佳实践

### 2.1 记忆提取

#### 2.1.1 何时提取记忆

- **对话结束**：在对话结束时提取重要信息
- **重要事件**：检测到重要事件时立即提取
- **定期批量**：定期批量提取对话中的记忆

```java
// 对话结束时提取
@PostMapping("/conversation/end")
public void endConversation(@RequestBody EndConversationRequest request) {
    memoryManager.extractAndSaveMemories(
        request.getUserId(), 
        request.getSessionId()
    );
}

// 重要事件触发提取
public void handleImportantEvent(String userId, String sessionId, String event) {
    if (isImportantEvent(event)) {
        memoryManager.extractAndSaveMemories(userId, sessionId);
    }
}
```

#### 2.1.2 提取策略

- **重要性阈值**：只提取重要性 > 0.7 的记忆
- **置信度阈值**：只保存置信度 > 0.6 的记忆
- **去重处理**：提取前检查是否已存在相似记忆

### 2.2 记忆检索

#### 2.2.1 检索策略

```java
// 1. 首先从短期记忆检索（最近对话）
List<ChatMessage> recentMessages = shortMemoryService.getMessages(sessionId, 10);

// 2. 然后从长期记忆检索（相关记忆）
List<UserMemory> relevantMemories = memoryManager.retrieveRelevantMemories(
    userId, query, 10);

// 3. 合并结果并去重
List<Memory> allMemories = mergeMemories(recentMessages, relevantMemories);
```

#### 2.2.2 检索优化

- **缓存结果**：缓存常用的检索结果
- **分页查询**：大数据量时使用分页
- **异步处理**：非关键路径使用异步检索

### 2.3 记忆巩固

#### 2.3.1 自动巩固

系统会自动巩固重要记忆，但也可以手动触发：

```java
// 手动巩固特定记忆
@PostMapping("/memories/{memoryId}/consolidate")
public void consolidateMemory(@PathVariable String memoryId) {
    memoryConsolidationService.consolidateMemory(memoryId);
}

// 批量巩固用户的所有记忆
@PostMapping("/users/{userId}/consolidate")
public void batchConsolidate(@PathVariable String userId) {
    memoryConsolidationService.batchConsolidate(userId);
}
```

### 2.4 性能优化

#### 2.4.1 缓存使用

```java
// 使用缓存的服务
@Service
public class CachedMemoryService {
    
    @Cacheable(value = "memories", key = "#memoryId")
    public Memory getMemory(String memoryId) {
        return memoryService.getMemory(memoryId);
    }
    
    @CacheEvict(value = "memories", key = "#memory.id")
    public void updateMemory(Memory memory) {
        memoryService.updateMemory(memory);
    }
}
```

#### 2.4.2 批量操作

```java
// 批量保存记忆
public void batchSaveMemories(List<Memory> memories) {
    memoryService.saveMemories(memories); // 批量保存
}

// 批量检索
public List<Memory> batchRetrieveMemories(List<String> memoryIds) {
    return memoryService.getMemories(memoryIds); // 批量检索
}
```

---

## 三、常见场景

### 3.1 对话系统集成

```java
@Service
@RequiredArgsConstructor
public class EnhancedChatService {
    
    private final MemoryManager memoryManager;
    private final AIService aiService;
    
    public String chat(String userId, String sessionId, String userMessage) {
        // 1. 获取对话上下文（包含相关记忆）
        ConversationContext context = memoryManager.getConversationContext(
            userId, sessionId, 20);
        
        // 2. 构建提示词（包含记忆）
        String prompt = buildPrompt(context, userMessage);
        
        // 3. 生成AI回复
        String response = aiService.generateText(prompt);
        
        // 4. 保存对话
        memoryManager.saveMessage(userId, sessionId, 
            ChatMessage.user(userMessage));
        memoryManager.saveMessage(userId, sessionId, 
            ChatMessage.assistant(response));
        
        // 5. 异步提取记忆
        CompletableFuture.runAsync(() -> {
            memoryManager.extractAndSaveMemories(userId, sessionId);
        });
        
        return response;
    }
    
    private String buildPrompt(ConversationContext context, String userMessage) {
        StringBuilder prompt = new StringBuilder();
        
        // 添加用户偏好
        if (!context.getUserPreferences().isEmpty()) {
            prompt.append("用户偏好：\n");
            context.getUserPreferences().forEach(pref -> {
                prompt.append(String.format("- %s: %s\n", pref.getKey(), pref.getValue()));
            });
        }
        
        // 添加相关记忆
        if (!context.getRelevantMemories().isEmpty()) {
            prompt.append("\n相关记忆：\n");
            context.getRelevantMemories().forEach(memory -> {
                prompt.append(String.format("- %s\n", memory.getContent()));
            });
        }
        
        // 添加对话历史
        prompt.append("\n对话历史：\n");
        context.getMessages().forEach(msg -> {
            prompt.append(String.format("%s: %s\n", msg.getRole(), msg.getContent()));
        });
        
        // 添加当前消息
        prompt.append("\n用户: ").append(userMessage).append("\n");
        prompt.append("助手: ");
        
        return prompt.toString();
    }
}
```

### 3.2 角色记忆集成

```java
@Service
@RequiredArgsConstructor
public class CharacterChatService {
    
    private final CharacterMemoryService characterMemoryService;
    private final MemoryManager memoryManager;
    
    public String chatWithCharacter(
            String characterId, String userId, String sessionId, String eraId, 
            String userMessage) {
        
        // 1. 获取角色与用户的交互记忆
        List<CharacterInteractionMemory> characterMemories = 
            characterMemoryService.getInteractionMemories(characterId, userId, eraId);
        
        // 2. 获取对话上下文
        ConversationContext context = memoryManager.getConversationContext(
            userId, sessionId, 20);
        
        // 3. 构建提示词（包含角色记忆）
        String prompt = buildCharacterPrompt(
            characterId, characterMemories, context, userMessage);
        
        // 4. 生成AI回复
        String response = aiService.generateText(prompt);
        
        // 5. 保存角色交互记忆
        CharacterInteractionMemory memory = new CharacterInteractionMemory();
        memory.setCharacterId(characterId);
        memory.setUserId(userId);
        memory.setEraId(eraId);
        memory.setContent("用户询问：" + userMessage);
        memory.setInteractionType(InteractionType.CONVERSATION);
        characterMemoryService.saveInteractionMemory(memory);
        
        return response;
    }
}
```

### 3.3 多用户场景

```java
@Service
@RequiredArgsConstructor
public class MultiUserService {
    
    private final ParticipantMemoryService participantMemoryService;
    
    public void handleCollaboration(
            String participantId1, String participantId2, 
            String sceneId, String collaborationContent) {
        
        // 1. 保存参与者1的交互记忆
        ParticipantInteractionMemory memory1 = new ParticipantInteractionMemory();
        memory1.setParticipantId(participantId1);
        memory1.setRelatedParticipantId(participantId2);
        memory1.setSceneId(sceneId);
        memory1.setContent(collaborationContent);
        memory1.setInteractionType(InteractionType.COLLABORATION);
        participantMemoryService.saveInteractionMemory(memory1);
        
        // 2. 保存参与者2的交互记忆（对称）
        ParticipantInteractionMemory memory2 = new ParticipantInteractionMemory();
        memory2.setParticipantId(participantId2);
        memory2.setRelatedParticipantId(participantId1);
        memory2.setSceneId(sceneId);
        memory2.setContent(collaborationContent);
        memory2.setInteractionType(InteractionType.COLLABORATION);
        participantMemoryService.saveInteractionMemory(memory2);
        
        // 3. 更新或创建关系
        ParticipantRelationship relationship = 
            participantMemoryService.getRelationship(participantId1, participantId2);
        if (relationship == null) {
            relationship = new ParticipantRelationship();
            relationship.setParticipantId(participantId1);
            relationship.setRelatedParticipantId(participantId2);
            relationship.setRelationshipType(RelationshipType.COLLEAGUE);
            relationship.setStrength(0.5);
        } else {
            // 增强关系强度
            relationship.setStrength(Math.min(1.0, relationship.getStrength() + 0.1));
        }
        participantMemoryService.saveRelationship(relationship);
    }
}
```

---

## 四、注意事项

### 4.1 性能注意事项

1. **异步处理**：记忆提取和巩固等操作应该异步处理，避免阻塞主流程
2. **批量操作**：尽量使用批量操作，减少数据库访问次数
3. **缓存使用**：合理使用缓存，减少数据库查询
4. **分页查询**：大数据量时使用分页，避免一次性加载过多数据

### 4.2 数据一致性

1. **事务处理**：相关操作应该放在事务中，保证数据一致性
2. **错误处理**：记忆操作失败时应该记录日志，不影响主流程
3. **数据验证**：保存记忆前应该验证数据有效性

### 4.3 隐私和安全

1. **数据加密**：敏感记忆数据应该加密存储
2. **访问控制**：确保用户只能访问自己的记忆
3. **数据清理**：定期清理过期和无效记忆

---

## 五、故障排查

### 5.1 常见问题

#### 5.1.1 记忆检索不准确

**原因**：
- 记忆提取不准确
- 检索策略不合理
- 索引未优化

**解决**：
- 提高提取准确率（调整提取策略）
- 优化检索算法（使用语义搜索）
- 优化数据库索引

#### 5.1.2 性能问题

**原因**：
- 未使用缓存
- 查询未优化
- 数据量过大

**解决**：
- 使用多级缓存
- 优化查询语句
- 数据分片或归档

### 5.2 监控和诊断

```java
// 使用监控工具检查系统状态
@GetMapping("/admin/memory/health")
public Map<String, Object> checkHealth() {
    Map<String, Object> health = new HashMap<>();
    
    // 检查数据库连接
    health.put("database", checkDatabase());
    
    // 检查Redis连接
    health.put("redis", checkRedis());
    
    // 检查系统指标
    health.put("metrics", getMetrics());
    
    return health;
}
```

---

## 六、总结

记忆系统的使用应该遵循以下原则：

1. ✅ **异步处理**：非关键路径使用异步处理
2. ✅ **批量操作**：尽量使用批量操作提升性能
3. ✅ **合理缓存**：使用缓存减少数据库访问
4. ✅ **错误处理**：完善的错误处理机制
5. ✅ **监控诊断**：建立完善的监控和诊断系统

通过合理使用记忆系统，可以大大提升AI Agent的智能水平和用户体验。

