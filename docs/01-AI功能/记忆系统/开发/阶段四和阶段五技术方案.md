# 阶段四和阶段五技术方案

**文档版本**: V1.0  
**创建日期**: 2025-12-29  
**目标**: 完成阶段四（高级记忆能力）和阶段五（记忆系统优化）的剩余工作

---

## 一、总体架构

```
┌─────────────────────────────────────────────────────────────┐
│                   阶段四和阶段五架构                          │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌─────────────────────────────────────────────────────┐    │
│  │           REST API 层 (v4/v5)                       │    │
│  │  AdvancedMemoryController | MemoryOptimizationCtrl  │    │
│  └─────────────────────────────────────────────────────┘    │
│                      │                                       │
│  ┌───────────────────▼───────────────────┐                  │
│  │          服务层 (Service Layer)        │                  │
│  │  • VectorSearchService (Embedding集成) │                  │
│  │  • MemoryAssociationService            │                  │
│  │  • MemoryConsolidationService          │                  │
│  │  • IntelligentRetrievalService         │                  │
│  │  • MemoryDecayService                  │                  │
│  │  • MemoryCacheService (新增)           │                  │
│  │  • MemoryCompressionService (新增)     │                  │
│  │  • MemoryArchivingService (新增)       │                  │
│  │  • MemoryMonitoringService (新增)      │                  │
│  └───────────────────────────────────────┘                  │
│                      │                                       │
│  ┌───────────────────▼───────────────────┐                  │
│  │          存储层 (Storage Layer)        │                  │
│  │  • Redis (缓存)                        │                  │
│  │  • MongoDB (持久化)                    │                  │
│  │  • Memory Vector DB (向量存储)         │                  │
│  └───────────────────────────────────────┘                  │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

---

## 二、技术方案详述

### 2.1 Embedding 模型集成方案

#### 2.1.1 方案选择

**方案A：DashScope Embedding API（推荐）**

**优点**：
- 与现有 DashScope 配置集成简单
- 支持中文语义理解
- 模型质量高（text-embedding-v2）
- 向量维度：1536（适合语义搜索）

**缺点**：
- 需要 API 调用（网络延迟）
- 有调用成本

**API 端点**：
```
POST https://dashscope.aliyuncs.com/api/v1/services/embeddings/text-embedding/text-embedding
```

**请求格式**：
```json
{
  "model": "text-embedding-v2",
  "input": {
    "texts": ["文本内容1", "文本内容2"]
  }
}
```

**响应格式**：
```json
{
  "output": {
    "embeddings": [
      {
        "text_index": 0,
        "embedding": [0.123, 0.456, ...]
      }
    ]
  },
  "usage": {
    "total_tokens": 10
  }
}
```

#### 2.1.2 实现方案

**步骤1：创建 DashScopeEmbeddingService**

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class DashScopeEmbeddingService {
    
    @Value("${spring.ai.dashscope.api-key}")
    private String apiKey;
    
    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper;
    
    private static final String EMBEDDING_URL = 
        "https://dashscope.aliyuncs.com/api/v1/services/embeddings/text-embedding/text-embedding";
    private static final String MODEL = "text-embedding-v2";
    private static final int VECTOR_DIMENSION = 1536;
    
    /**
     * 生成单个文本的向量嵌入
     */
    public float[] generateEmbedding(String text) {
        List<String> texts = Collections.singletonList(text);
        List<float[]> results = generateEmbeddings(texts);
        return results.isEmpty() ? null : results.get(0);
    }
    
    /**
     * 批量生成向量嵌入（支持最多25个文本）
     */
    public List<float[]> generateEmbeddings(List<String> texts) {
        // 实现API调用逻辑
    }
}
```

**步骤2：更新 SimpleVectorSearchService**

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class SimpleVectorSearchService implements VectorSearchService {
    
    private final DashScopeEmbeddingService embeddingService; // 新增
    private final MemoryVectorRepository memoryVectorRepository;
    
    @Override
    public float[] generateEmbedding(String text) {
        // 使用真实的 Embedding 服务
        return embeddingService.generateEmbedding(text);
    }
    
    // ... 其他方法保持不变
}
```

**步骤3：配置和错误处理**

- API Key 配置：使用 `spring.ai.dashscope.api-key`
- 错误处理：网络异常、API 限流、降级策略
- 缓存策略：相同文本的向量结果缓存（可选）

#### 2.1.3 降级策略

如果 Embedding API 调用失败：
1. **降级到哈希向量**：使用现有的简单哈希实现
2. **记录日志**：记录失败原因和频率
3. **告警**：超过阈值时发送告警

---

### 2.2 REST API Controller 设计方案

#### 2.2.1 阶段四 API (v4) - AdvancedMemoryController

**基础路径**: `/api/memory/v4`

**API 列表**：

| 方法 | 路径 | 功能 | 说明 |
|------|------|------|------|
| POST | `/vector/embed` | 生成向量嵌入 | 生成文本的向量表示 |
| POST | `/vector/search` | 语义搜索 | 基于向量相似度搜索记忆 |
| GET | `/associations/{memoryId}` | 获取记忆关联 | 获取指定记忆的关联记忆 |
| POST | `/associations/discover` | 发现关联 | 自动发现记忆之间的关联 |
| POST | `/intelligent/search` | 智能检索 | 多维度智能检索 |
| POST | `/consolidation/execute` | 执行巩固 | 手动触发记忆巩固 |
| GET | `/consolidation/stats` | 巩固统计 | 获取记忆巩固统计信息 |

**DTO 设计**：

```java
// 向量搜索请求
public class VectorSearchRequest {
    private String query;
    private String userId;
    private String characterId;
    private String participantId;
    private Integer limit = 10;
    private Double threshold = 0.6;
}

// 智能检索请求
public class IntelligentSearchRequest {
    private String query;
    private String userId;
    private Map<String, Object> context;
    private Integer limit = 10;
    private Double semanticWeight = 0.4;
    private Double keywordWeight = 0.4;
    private Double associationWeight = 0.2;
}
```

#### 2.2.2 阶段五 API (v5) - MemoryOptimizationController

**基础路径**: `/api/memory/v5`

**API 列表**：

| 方法 | 路径 | 功能 | 说明 |
|------|------|------|------|
| POST | `/decay/update` | 更新衰减 | 手动触发记忆衰减更新 |
| GET | `/decay/stats` | 衰减统计 | 获取衰减统计信息 |
| POST | `/cache/warmup` | 缓存预热 | 预热缓存 |
| DELETE | `/cache/clear` | 清理缓存 | 清理指定类型的缓存 |
| GET | `/cache/stats` | 缓存统计 | 获取缓存统计信息 |
| POST | `/compression/compress` | 压缩记忆 | 压缩低频访问的记忆 |
| POST | `/archiving/archive` | 归档记忆 | 归档长期未使用的记忆 |
| GET | `/archiving/list` | 归档列表 | 获取已归档的记忆列表 |
| POST | `/archiving/restore` | 恢复归档 | 从归档中恢复记忆 |
| GET | `/monitoring/metrics` | 性能指标 | 获取系统性能指标 |
| GET | `/monitoring/health` | 健康检查 | 系统健康状态检查 |
| GET | `/monitoring/diagnostics` | 诊断信息 | 获取系统诊断信息 |

---

### 2.3 缓存优化服务设计方案

#### 2.3.1 多级缓存架构

```
┌─────────────────────────────────────┐
│  L1: 内存缓存 (Caffeine)            │
│  • 热点记忆                        │
│  • TTL: 5分钟                      │
│  • 最大容量: 1000条                │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│  L2: Redis 缓存                     │
│  • 常用记忆                        │
│  • TTL: 1小时                      │
│  • 最大容量: 10000条               │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│  L3: MongoDB (持久化)               │
│  • 所有记忆                        │
└─────────────────────────────────────┘
```

#### 2.3.2 接口设计

```java
public interface MemoryCacheService {
    
    /**
     * 获取记忆（多级缓存）
     */
    <T> Optional<T> get(String key, Class<T> type);
    
    /**
     * 保存记忆（写入所有缓存层）
     */
    <T> void put(String key, T value, Duration ttl);
    
    /**
     * 删除记忆（从所有缓存层删除）
     */
    void evict(String key);
    
    /**
     * 缓存预热（将热点数据加载到缓存）
     */
    void warmup(List<String> memoryIds);
    
    /**
     * 清理缓存（按类型）
     */
    void clear(String cacheType);
    
    /**
     * 获取缓存统计
     */
    CacheStats getStats();
}
```

#### 2.3.3 实现细节

**L1 缓存（Caffeine）**：

```java
private final Cache<String, Object> localCache = Caffeine.newBuilder()
    .maximumSize(1000)
    .expireAfterWrite(5, TimeUnit.MINUTES)
    .recordStats()
    .build();
```

**L2 缓存（Redis）**：

```java
// 使用 RedisTemplate
redisTemplate.opsForValue().set(key, value, 1, TimeUnit.HOURS);
```

**缓存键设计**：

```
memory:{memoryId}                    # 记忆内容
memory:vector:{memoryId}             # 记忆向量
memory:associations:{memoryId}       # 记忆关联
user:memories:{userId}:{type}        # 用户记忆列表
```

---

### 2.4 压缩归档服务设计方案

#### 2.4.1 记忆压缩服务

**压缩策略**：

1. **识别低频访问记忆**：
   - 访问频率 < 阈值（如：30天未访问）
   - 重要性 < 阈值（如：< 0.3）

2. **压缩算法**：
   - 使用 GZIP 压缩内容
   - 保留元数据和索引信息
   - 压缩率目标：50-70%

3. **压缩后存储**：
   - 原始内容压缩后存储
   - 保留解压后的摘要信息用于检索

**接口设计**：

```java
public interface MemoryCompressionService {
    
    /**
     * 压缩记忆
     */
    CompressionResult compress(String memoryId);
    
    /**
     * 批量压缩记忆
     */
    List<CompressionResult> compressBatch(List<String> memoryIds);
    
    /**
     * 解压缩记忆
     */
    String decompress(String memoryId);
    
    /**
     * 获取压缩统计
     */
    CompressionStats getStats();
}
```

#### 2.4.2 记忆归档服务

**归档策略**：

1. **归档条件**：
   - 创建时间 > 阈值（如：90天前）
   - 最后访问时间 > 阈值（如：60天前）
   - 重要性 < 阈值（如：< 0.2）

2. **归档存储**：
   - 移动到归档集合：`memory_archived`
   - 添加归档时间戳和原因
   - 保留原始ID用于恢复

3. **归档恢复**：
   - 从归档集合恢复到原始集合
   - 恢复关联和索引

**接口设计**：

```java
public interface MemoryArchivingService {
    
    /**
     * 归档记忆
     */
    ArchiveResult archive(String memoryId, String reason);
    
    /**
     * 批量归档记忆
     */
    List<ArchiveResult> archiveBatch(List<String> memoryIds, String reason);
    
    /**
     * 获取归档列表
     */
    Page<ArchivedMemory> listArchived(Pageable pageable);
    
    /**
     * 恢复归档记忆
     */
    void restore(String archivedMemoryId);
    
    /**
     * 永久删除归档记忆
     */
    void deletePermanently(String archivedMemoryId);
    
    /**
     * 获取归档统计
     */
    ArchiveStats getStats();
}
```

**数据模型**：

```java
@Document(collection = "memory_archived")
public class ArchivedMemory {
    private String id;
    private String originalMemoryId;
    private String userId;
    private MemoryType memoryType;
    private String content; // 压缩后的内容
    private Map<String, Object> metadata;
    private Instant archivedAt;
    private String archiveReason;
    private Instant createdAt; // 原始创建时间
}
```

---

### 2.5 监控诊断系统设计方案

#### 2.5.1 监控指标

**性能指标**：
- 响应时间（P50, P95, P99）
- QPS（每秒查询数）
- 错误率
- 缓存命中率

**存储指标**：
- 记忆总数
- 存储大小
- 压缩率
- 归档数量

**系统指标**：
- Redis 连接数
- MongoDB 连接数
- 内存使用率
- CPU 使用率

#### 2.5.2 接口设计

```java
public interface MemoryMonitoringService {
    
    /**
     * 获取性能指标
     */
    PerformanceMetrics getPerformanceMetrics(Instant startTime, Instant endTime);
    
    /**
     * 获取存储指标
     */
    StorageMetrics getStorageMetrics();
    
    /**
     * 获取系统指标
     */
    SystemMetrics getSystemMetrics();
    
    /**
     * 健康检查
     */
    HealthStatus healthCheck();
    
    /**
     * 诊断信息
     */
    DiagnosticsInfo diagnose();
}
```

**DTO 设计**：

```java
public class PerformanceMetrics {
    private Double p50ResponseTime;
    private Double p95ResponseTime;
    private Double p99ResponseTime;
    private Long qps;
    private Double errorRate;
    private Double cacheHitRate;
    private Map<String, Long> operationCounts;
}

public class HealthStatus {
    private String status; // HEALTHY, DEGRADED, DOWN
    private Map<String, ComponentHealth> components;
    private List<String> issues;
}

public class DiagnosticsInfo {
    private HealthStatus health;
    private PerformanceMetrics performance;
    private StorageMetrics storage;
    private List<String> recommendations;
}
```

---

### 2.6 测试方案

#### 2.6.1 单元测试

**VectorSearchService 测试**：
- 测试 Embedding 生成
- 测试向量搜索
- 测试相似度计算
- 测试降级策略

**MemoryCacheService 测试**：
- 测试多级缓存读写
- 测试缓存失效
- 测试缓存预热
- 测试缓存统计

**MemoryCompressionService 测试**：
- 测试压缩和解压缩
- 测试压缩率
- 测试批量压缩

**MemoryArchivingService 测试**：
- 测试归档和恢复
- 测试批量归档
- 测试归档列表查询

#### 2.6.2 集成测试

- API 集成测试（使用 MockMvc）
- 服务间集成测试
- 数据库集成测试（使用 Testcontainers）

#### 2.6.3 性能测试

- 向量搜索性能测试
- 缓存性能测试
- 压缩性能测试
- 并发测试

---

## 三、实施计划

### 3.1 第一阶段：核心功能（预计 6-8 小时）

1. ✅ Embedding 模型集成（2-3 小时）
   - 创建 DashScopeEmbeddingService
   - 更新 SimpleVectorSearchService
   - 测试和验证

2. ✅ REST API Controllers（3-4 小时）
   - 创建 AdvancedMemoryController (v4)
   - 创建 MemoryOptimizationController (v5)
   - API 文档和测试

3. ✅ 基础测试（1 小时）
   - 单元测试
   - API 测试

### 3.2 第二阶段：性能优化（预计 4-5 小时）

1. ✅ 缓存优化服务（2 小时）
   - MemoryCacheService 实现
   - 多级缓存集成
   - 缓存预热和清理

2. ✅ 压缩归档服务（2-3 小时）
   - MemoryCompressionService 实现
   - MemoryArchivingService 实现
   - 测试和验证

### 3.3 第三阶段：监控和测试（预计 3-4 小时）

1. ✅ 监控诊断系统（2 小时）
   - MemoryMonitoringService 实现
   - 指标收集
   - 健康检查

2. ✅ 完整测试（1-2 小时）
   - 集成测试
   - 性能测试
   - 文档完善

**总计预计时间**：13-17 小时

---

## 四、技术风险与应对

### 4.1 Embedding API 依赖

**风险**：API 调用失败或限流

**应对**：
- 实现降级策略（哈希向量）
- 增加重试机制
- 实现本地缓存

### 4.2 缓存一致性问题

**风险**：多级缓存数据不一致

**应对**：
- 实现缓存更新策略
- 使用消息队列同步（可选）
- 定期清理过期缓存

### 4.3 压缩解压缩性能

**风险**：压缩解压缩耗时过长

**应对**：
- 使用异步压缩
- 压缩阈值可配置
- 监控压缩性能

---

## 五、配置项

### 5.1 application.yml 配置

```yaml
heartsphere:
  memory:
    # Embedding 配置
    embedding:
      enabled: true
      model: text-embedding-v2
      dimension: 1536
      batch-size: 10
      cache-enabled: true
      fallback-enabled: true
    
    # 缓存配置
    cache:
      l1:
        enabled: true
        max-size: 1000
        ttl: 5m
      l2:
        enabled: true
        ttl: 1h
        max-size: 10000
    
    # 压缩配置
    compression:
      enabled: true
      threshold-days: 30
      min-importance: 0.3
    
    # 归档配置
    archiving:
      enabled: true
      threshold-days: 90
      access-threshold-days: 60
      min-importance: 0.2
```

---

## 六、下一步行动

1. ✅ **评审技术方案**：确认方案可行性和完整性
2. ⏭️ **开始实施**：按计划逐步实施
3. ⏭️ **代码审查**：每个阶段完成后进行代码审查
4. ⏭️ **测试验证**：确保功能正确性和性能指标

---

**技术方案完成！准备开始实施。** ✅



