# 大模型统一接入层需求分析文档

**文档版本**: V1.0  
**编写日期**: 2025-12-22  
**功能模块**: 大模型统一接入层  
**目标**: 在后端建立统一的大模型接入服务，为后续计费、监控、限流等功能奠定基础

---

## 一、需求概述

### 1.1 背景

当前系统存在的问题：
1. **前端直接调用AI模型**：前端代码直接调用Gemini、OpenAI等API，无法统一管理和控制
2. **缺乏统一接口**：没有统一的服务层管理所有AI模型调用
3. **无法实现计费**：前端直接调用无法记录使用量，无法实现精确计费
4. **安全问题**：API Key暴露在前端，存在安全风险
5. **难以监控**：无法统一监控API调用情况、失败率、响应时间等

**新模式需求**：
系统需要支持**双模式**运行，让用户根据自己的需求选择：
- **本地配置模式**：用户自己申请API Key，直接调用模型，自己承担费用（降低系统成本）
- **统一接入模式**：调用后端统一接入接口，使用系统的API Key，由系统计费和管理

### 1.2 核心目标

- ✅ **双模式支持**：支持本地配置模式和统一接入模式，用户可自由选择
- ✅ **统一接入**：后端统一管理所有AI模型调用（统一接入模式）
- ✅ **本地直连**：前端可直接调用AI模型（本地配置模式）
- ✅ **接口标准化**：提供统一的REST API接口（统一接入模式）
- ✅ **多模型支持**：支持Gemini、OpenAI、通义千问、豆包等
- ✅ **多模态支持**：支持文本生成、图片生成、语音处理、视频生成
- ✅ **易于扩展**：易于添加新的模型提供商
- ✅ **为计费铺路**：统一接入模式为后续计费系统提供接入点
- ✅ **灵活配置**：用户可在客户端配置选择使用哪种模式

### 1.3 设计原则

1. **统一接口**：所有AI调用都通过统一的服务层
2. **适配器模式**：使用适配器模式支持不同模型
3. **异步非阻塞**：支持异步调用，不阻塞主流程
4. **容错机制**：支持失败重试、降级、熔断
5. **可观测性**：完整的日志、监控、追踪

---

## 二、架构设计

### 2.1 整体架构

系统支持两种运行模式，由用户在前端配置选择：

#### 模式一：统一接入模式（后端代理）

```
┌─────────────────────────────────────────────────────────┐
│                    前端应用层                             │
│  - AI服务调用层（统一接口）                              │
│  - 根据配置选择调用模式                                  │
└───────┬───────────────────────────────┬─────────────────┘
        │ 模式：统一接入                  │ 模式：本地配置
        │ HTTP/REST                     │ 直接HTTP调用
        │                               │
┌───────▼───────────────────────────────┐│
│                API网关层               ││
│  - 请求认证                            ││
│  - 参数验证                            ││
│  - 限流控制                            ││
│  - 配额检查（未来）                    ││
└───────┬───────────────────────────────┘│
        │                                │
┌───────▼───────────────────────────────┐│
│     AI统一服务层 (AIService)           ││
│  - 统一的服务接口                      ││
│  - 请求路由                            ││
│  - 参数转换                            ││
│  - 响应统一                            ││
│  - 使用量记录（计费）                  ││
└───────┬───────────────────────────────┘│
        │                                │
┌───────▼───────────────────────────────┐│
│    模型适配器层 (ModelAdapter)         ││
│  ┌──────────┐  ┌──────────┐          ││
│  │ Gemini   │  │ OpenAI   │  ...     ││
│  │ Adapter  │  │ Adapter  │          ││
│  └──────────┘  └──────────┘          ││
└───────┬───────────────────────────────┘│
        │                                │
┌───────▼───────────────────────────────▼┐
│           第三方AI服务                  │
│  - Google Gemini API                   │
│  - OpenAI API                          │
│  - 阿里云通义千问 API                  │
│  - 字节跳动豆包 API                    │
└────────────────────────────────────────┘
```

**模式特点**：
- ✅ 使用系统API Key，用户无需配置
- ✅ 系统统一计费和管理
- ✅ 支持配额限制和计费
- ✅ 更好的安全性和监控

#### 模式二：本地配置模式（前端直连）

**模式特点**：
- ✅ 用户自己配置API Key
- ✅ 直接调用AI服务，不经过后端
- ✅ 用户自己承担费用
- ✅ 降低系统成本
- ✅ 更好的隐私保护（API Key只存在本地）

**注意事项**：
- ⚠️ API Key存储在客户端（LocalStorage/加密存储）
- ⚠️ 无法进行统一监控和限流
- ⚠️ 不支持系统计费和配额管理

### 2.2 模块划分

#### 2.2.1 API接口层

**位置**: `backend/src/main/java/com/heartsphere/controller/AIServiceController.java`

**职责**:
- 提供统一的REST API接口
- 处理HTTP请求和响应
- 参数验证和转换
- 错误处理和响应格式化

#### 2.2.2 服务层

**位置**: `backend/src/main/java/com/heartsphere/service/ai/`

**核心服务**:
- `AIService.java` - 统一AI服务接口
- `AIServiceImpl.java` - AI服务实现
- `ModelAdapterManager.java` - 模型适配器管理
- `AIConfigService.java` - AI配置管理

#### 2.2.3 适配器层

**位置**: `backend/src/main/java/com/heartsphere/service/ai/adapter/`

**适配器**:
- `ModelAdapter.java` - 适配器接口
- `GeminiAdapter.java` - Gemini适配器
- `OpenAIAdapter.java` - OpenAI适配器
- `QwenAdapter.java` - 通义千问适配器
- `DoubaoAdapter.java` - 豆包适配器

#### 2.2.4 模型层

**位置**: `backend/src/main/java/com/heartsphere/dto/ai/`

**DTO类**:
- `TextGenerationRequest.java` - 文本生成请求
- `TextGenerationResponse.java` - 文本生成响应
- `ImageGenerationRequest.java` - 图片生成请求
- `ImageGenerationResponse.java` - 图片生成响应
- `AudioRequest.java` - 音频处理请求
- `AudioResponse.java` - 音频处理响应

---

## 三、功能需求

### 3.1 文本生成服务

#### 3.1.1 功能描述

支持多种模型的文本生成，包括聊天对话、内容生成等。

#### 3.1.2 API接口

**接口**: `POST /api/ai/text/generate`

**请求体**:
```json
{
  "provider": "gemini",  // 可选：gemini, openai, qwen, doubao，不指定则使用用户配置
  "model": "gemini-2.0-flash-exp",  // 可选：指定模型名称，不指定则使用默认模型
  "prompt": "用户输入的文本",
  "systemInstruction": "系统指令（可选）",
  "messages": [  // 可选：对话历史
    {
      "role": "user",
      "content": "你好"
    },
    {
      "role": "assistant",
      "content": "你好！有什么可以帮助你的吗？"
    }
  ],
  "temperature": 0.7,  // 可选：0-1，默认0.7
  "maxTokens": 2048,  // 可选：最大输出Token数
  "stream": false  // 可选：是否流式返回，默认false
}
```

**响应体**:
```json
{
  "code": 200,
  "message": "成功",
  "data": {
    "content": "生成的文本内容",
    "provider": "gemini",
    "model": "gemini-2.0-flash-exp",
    "usage": {
      "inputTokens": 100,
      "outputTokens": 200,
      "totalTokens": 300
    },
    "finishReason": "stop"
  },
  "timestamp": "2025-12-22T10:30:00"
}
```

**流式响应** (当stream=true时):

使用Server-Sent Events (SSE):
```
data: {"content": "生成的", "done": false}
data: {"content": "文本", "done": false}
data: {"content": "内容", "done": true, "usage": {...}}
```

#### 3.1.3 实现要求

1. **模式判断**:
   - 前端根据用户配置决定调用后端接口还是直接调用AI服务
   - 统一接入模式：调用后端 `/api/ai/text/generate` 接口
   - 本地配置模式：前端直接调用AI服务API，不经过后端
   - 后端接口只处理统一接入模式的请求

2. **模型选择逻辑**（统一接入模式）:
   - 优先使用请求中指定的provider和model
   - 如果未指定，使用用户的默认配置（从数据库读取）
   - 如果用户未配置，使用系统默认配置
   - 支持自动降级（如果指定模型失败，尝试其他模型）

3. **本地配置模式的模型选择**:
   - 使用用户在客户端配置的API Key和模型
   - 如果未配置API Key，提示用户配置
   - 支持在客户端切换不同的provider和model

4. **参数标准化**:
   - 不同模型的参数名称不同，需要在适配器中统一转换
   - 例如：Gemini使用`temperature`，OpenAI也使用`temperature`，但有些参数需要转换
   - 前端本地调用时也需要进行参数转换

5. **响应统一**:
   - 两种模式都返回统一的响应格式
   - 统一Token使用量统计格式
   - 统一错误格式
   - 统一响应结构

#### 3.1.4 数据模型

```sql
-- AI模型配置表（用户级别）
CREATE TABLE user_ai_config (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id BIGINT NOT NULL COMMENT '用户ID',
  text_provider VARCHAR(50) COMMENT '文本生成提供商：gemini, openai, qwen, doubao',
  text_model VARCHAR(100) COMMENT '文本生成模型名称',
  image_provider VARCHAR(50) COMMENT '图片生成提供商',
  image_model VARCHAR(100) COMMENT '图片生成模型名称',
  audio_provider VARCHAR(50) COMMENT '音频处理提供商',
  audio_model VARCHAR(100) COMMENT '音频处理模型名称',
  video_provider VARCHAR(50) COMMENT '视频生成提供商',
  video_model VARCHAR(100) COMMENT '视频生成模型名称',
  enable_fallback BOOLEAN DEFAULT TRUE COMMENT '是否启用降级',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id),
  UNIQUE KEY uk_user_id (user_id)
);

-- 系统默认AI模型配置表
CREATE TABLE system_ai_config (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  config_key VARCHAR(100) NOT NULL COMMENT '配置键：default_text_provider',
  config_value VARCHAR(500) NOT NULL COMMENT '配置值',
  description VARCHAR(500) COMMENT '描述',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY uk_config_key (config_key)
);
```

### 3.2 图片生成服务

#### 3.2.1 功能描述

支持多种模型的图片生成。

#### 3.2.2 API接口

**接口**: `POST /api/ai/image/generate`

**请求体**:
```json
{
  "provider": "gemini",  // 可选
  "model": "imagen-3.0-generate-001",  // 可选
  "prompt": "生成图片的提示词",
  "negativePrompt": "负面提示词（可选）",
  "width": 1024,  // 可选：图片宽度，默认1024
  "height": 1024,  // 可选：图片高度，默认1024
  "aspectRatio": "1:1",  // 可选：宽高比
  "numberOfImages": 1,  // 可选：生成图片数量，默认1
  "style": "photographic"  // 可选：图片风格
}
```

**响应体**:
```json
{
  "code": 200,
  "message": "成功",
  "data": {
    "images": [
      {
        "url": "https://...",  // 图片URL
        "base64": "..."  // Base64编码（可选）
      }
    ],
    "provider": "gemini",
    "model": "imagen-3.0-generate-001",
    "usage": {
      "imagesGenerated": 1
    }
  },
  "timestamp": "2025-12-22T10:30:00"
}
```

### 3.3 音频处理服务

#### 3.3.1 功能描述

支持文本转语音(TTS)和语音转文本(STT)。

#### 3.3.2 API接口

**文本转语音**: `POST /api/ai/audio/tts`

**请求体**:
```json
{
  "provider": "gemini",
  "model": "gemini-2.0-flash-exp",
  "text": "要转换为语音的文本",
  "voice": "zh-CN-Standard-A",  // 可选：语音类型
  "speed": 1.0,  // 可选：语速
  "pitch": 1.0  // 可选：音调
}
```

**响应体**:
```json
{
  "code": 200,
  "message": "成功",
  "data": {
    "audioUrl": "https://...",  // 音频文件URL
    "audioBase64": "...",  // Base64编码（可选）
    "duration": 5.2,  // 音频时长（秒）
    "provider": "gemini",
    "model": "gemini-2.0-flash-exp"
  }
}
```

**语音转文本**: `POST /api/ai/audio/stt`

**请求体** (multipart/form-data):
- `audioFile`: 音频文件
- `provider`: 提供商（可选）
- `model`: 模型名称（可选）
- `language`: 语言（可选）

**响应体**:
```json
{
  "code": 200,
  "message": "成功",
  "data": {
    "text": "识别出的文本",
    "provider": "gemini",
    "model": "gemini-2.0-flash-exp",
    "confidence": 0.95,  // 置信度
    "duration": 5.2  // 音频时长
  }
}
```

### 3.4 视频生成服务

#### 3.4.1 功能描述

支持AI生成视频（未来功能）。

#### 3.4.2 API接口

**接口**: `POST /api/ai/video/generate`

**请求体**:
```json
{
  "provider": "gemini",
  "model": "veo-2",
  "prompt": "生成视频的提示词",
  "duration": 5,  // 视频时长（秒）
  "resolution": "1080p"  // 分辨率
}
```

**响应体**:
```json
{
  "code": 200,
  "message": "成功",
  "data": {
    "videoUrl": "https://...",
    "videoId": "video_123",  // 视频ID（异步生成时使用）
    "status": "completed",  // completed, processing
    "provider": "gemini",
    "model": "veo-2",
    "duration": 5
  }
}
```

---

## 四、模型适配器实现

### 4.1 适配器接口设计

```java
package com.heartsphere.service.ai.adapter;

import com.heartsphere.dto.ai.*;

/**
 * 大模型适配器接口
 * 所有模型适配器必须实现此接口
 */
public interface ModelAdapter {
    
    /**
     * 获取适配器类型（提供商名称）
     */
    String getProviderType();
    
    /**
     * 是否支持文本生成
     */
    boolean supportsTextGeneration();
    
    /**
     * 是否支持图片生成
     */
    boolean supportsImageGeneration();
    
    /**
     * 是否支持文本转语音
     */
    boolean supportsTextToSpeech();
    
    /**
     * 是否支持语音转文本
     */
    boolean supportsSpeechToText();
    
    /**
     * 是否支持视频生成
     */
    boolean supportsVideoGeneration();
    
    /**
     * 生成文本
     */
    TextGenerationResponse generateText(TextGenerationRequest request);
    
    /**
     * 流式生成文本
     */
    void generateTextStream(TextGenerationRequest request, 
                           StreamResponseHandler<TextGenerationResponse> handler);
    
    /**
     * 生成图片
     */
    ImageGenerationResponse generateImage(ImageGenerationRequest request);
    
    /**
     * 文本转语音
     */
    AudioResponse textToSpeech(AudioRequest request);
    
    /**
     * 语音转文本
     */
    AudioResponse speechToText(AudioRequest request);
    
    /**
     * 生成视频
     */
    VideoGenerationResponse generateVideo(VideoGenerationRequest request);
    
    /**
     * 获取支持的模型列表
     */
    List<String> getSupportedModels(String capability);  // capability: text, image, audio, video
}
```

### 4.2 Gemini适配器实现

```java
package com.heartsphere.service.ai.adapter.impl;

import com.heartsphere.service.ai.adapter.ModelAdapter;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class GeminiAdapter implements ModelAdapter {
    
    @Value("${ai.gemini.api-key:}")
    private String apiKey;
    
    @Value("${ai.gemini.base-url:https://generativelanguage.googleapis.com/v1beta}")
    private String baseUrl;
    
    @Override
    public String getProviderType() {
        return "gemini";
    }
    
    @Override
    public boolean supportsTextGeneration() {
        return true;
    }
    
    @Override
    public TextGenerationResponse generateText(TextGenerationRequest request) {
        // 调用Gemini API
        // 转换参数格式
        // 解析响应
        // 返回统一格式
    }
    
    // 其他方法实现...
}
```

### 4.3 OpenAI适配器实现

```java
@Component
public class OpenAIAdapter implements ModelAdapter {
    
    @Value("${ai.openai.api-key:}")
    private String apiKey;
    
    @Value("${ai.openai.base-url:https://api.openai.com/v1}")
    private String baseUrl;
    
    @Override
    public String getProviderType() {
        return "openai";
    }
    
    // 实现方法...
}
```

### 4.4 适配器管理

```java
@Service
public class ModelAdapterManager {
    
    private final Map<String, ModelAdapter> adapters = new HashMap<>();
    
    @Autowired
    public ModelAdapterManager(List<ModelAdapter> adapterList) {
        for (ModelAdapter adapter : adapterList) {
            adapters.put(adapter.getProviderType(), adapter);
        }
    }
    
    public ModelAdapter getAdapter(String provider) {
        ModelAdapter adapter = adapters.get(provider);
        if (adapter == null) {
            throw new IllegalArgumentException("Unsupported provider: " + provider);
        }
        return adapter;
    }
    
    public List<String> getAvailableProviders(String capability) {
        return adapters.values().stream()
            .filter(adapter -> supportsCapability(adapter, capability))
            .map(ModelAdapter::getProviderType)
            .collect(Collectors.toList());
    }
    
    private boolean supportsCapability(ModelAdapter adapter, String capability) {
        switch (capability) {
            case "text": return adapter.supportsTextGeneration();
            case "image": return adapter.supportsImageGeneration();
            case "audio": return adapter.supportsTextToSpeech() || adapter.supportsSpeechToText();
            case "video": return adapter.supportsVideoGeneration();
            default: return false;
        }
    }
}
```

---

## 五、服务层实现

### 5.1 AIService接口

```java
package com.heartsphere.service.ai;

import com.heartsphere.dto.ai.*;

public interface AIService {
    
    /**
     * 生成文本
     */
    TextGenerationResponse generateText(Long userId, TextGenerationRequest request);
    
    /**
     * 流式生成文本
     */
    void generateTextStream(Long userId, TextGenerationRequest request, 
                           StreamResponseHandler<TextGenerationResponse> handler);
    
    /**
     * 生成图片
     */
    ImageGenerationResponse generateImage(Long userId, ImageGenerationRequest request);
    
    /**
     * 文本转语音
     */
    AudioResponse textToSpeech(Long userId, AudioRequest request);
    
    /**
     * 语音转文本
     */
    AudioResponse speechToText(Long userId, AudioRequest request);
    
    /**
     * 生成视频
     */
    VideoGenerationResponse generateVideo(Long userId, VideoGenerationRequest request);
    
    /**
     * 获取用户AI配置
     */
    UserAIConfig getUserConfig(Long userId);
    
    /**
     * 更新用户AI配置
     */
    void updateUserConfig(Long userId, UserAIConfig config);
}
```

### 5.2 AIService实现

```java
@Service
@Slf4j
public class AIServiceImpl implements AIService {
    
    private final ModelAdapterManager adapterManager;
    private final AIConfigService configService;
    private final AIUsageRecordService usageRecordService;  // 未来用于记录使用量
    
    @Autowired
    public AIServiceImpl(ModelAdapterManager adapterManager,
                        AIConfigService configService,
                        AIUsageRecordService usageRecordService) {
        this.adapterManager = adapterManager;
        this.configService = configService;
        this.usageRecordService = usageRecordService;
    }
    
    @Override
    public TextGenerationResponse generateText(Long userId, TextGenerationRequest request) {
        // 1. 获取用户配置（决定使用哪个provider和model）
        UserAIConfig userConfig = configService.getUserConfig(userId);
        
        // 2. 确定provider和model
        String provider = request.getProvider() != null ? 
            request.getProvider() : userConfig.getTextProvider();
        String model = request.getModel() != null ? 
            request.getModel() : userConfig.getTextModel();
        
        // 3. 获取适配器
        ModelAdapter adapter = adapterManager.getAdapter(provider);
        
        // 4. 调用适配器生成文本
        TextGenerationResponse response;
        try {
            response = adapter.generateText(request);
            
            // 5. 记录使用量（未来用于计费）
            // usageRecordService.recordTextGeneration(userId, provider, model, response.getUsage());
            
            return response;
        } catch (Exception e) {
            log.error("Text generation failed for user {} with provider {}", userId, provider, e);
            
            // 6. 如果失败且启用降级，尝试其他provider
            if (userConfig.isEnableFallback()) {
                return tryFallback(userId, request, provider, "text");
            }
            
            throw new AIServiceException("Text generation failed", e);
        }
    }
    
    private TextGenerationResponse tryFallback(Long userId, TextGenerationRequest request, 
                                               String failedProvider, String capability) {
        // 获取其他可用的providers
        List<String> availableProviders = adapterManager.getAvailableProviders(capability);
        availableProviders.remove(failedProvider);
        
        for (String provider : availableProviders) {
            try {
                ModelAdapter adapter = adapterManager.getAdapter(provider);
                return adapter.generateText(request);
            } catch (Exception e) {
                log.warn("Fallback to {} also failed", provider, e);
            }
        }
        
        throw new AIServiceException("All providers failed for text generation");
    }
    
    // 其他方法实现类似...
}
```

---

## 六、API控制器实现

### 6.1 AIServiceController

```java
@RestController
@RequestMapping("/api/ai")
@RequiredArgsConstructor
@Slf4j
public class AIServiceController {
    
    private final AIService aiService;
    
    /**
     * 生成文本
     */
    @PostMapping("/text/generate")
    public ResponseEntity<ApiResponse<TextGenerationResponse>> generateText(
            @RequestBody TextGenerationRequest request,
            Authentication authentication) {
        
        if (authentication == null || authentication.getPrincipal() == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
        }
        
        UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
        Long userId = userDetails.getId();
        
        try {
            TextGenerationResponse response = aiService.generateText(userId, request);
            return ResponseEntity.ok(ApiResponse.success(response));
        } catch (Exception e) {
            log.error("Text generation failed", e);
            return ResponseEntity.ok(ApiResponse.error(e.getMessage()));
        }
    }
    
    /**
     * 流式生成文本
     */
    @PostMapping("/text/generate/stream")
    public ResponseEntity<SseEmitter> generateTextStream(
            @RequestBody TextGenerationRequest request,
            Authentication authentication) {
        
        if (authentication == null || authentication.getPrincipal() == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
        }
        
        UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
        Long userId = userDetails.getId();
        
        SseEmitter emitter = new SseEmitter(30000L);  // 30秒超时
        
        aiService.generateTextStream(userId, request, (response, done) -> {
            try {
                emitter.send(SseEmitter.event()
                    .data(response)
                    .name(done ? "done" : "data"));
                
                if (done) {
                    emitter.complete();
                }
            } catch (IOException e) {
                emitter.completeWithError(e);
            }
        });
        
        return ResponseEntity.ok(emitter);
    }
    
    /**
     * 生成图片
     */
    @PostMapping("/image/generate")
    public ResponseEntity<ApiResponse<ImageGenerationResponse>> generateImage(
            @RequestBody ImageGenerationRequest request,
            Authentication authentication) {
        // 实现类似...
    }
    
    /**
     * 文本转语音
     */
    @PostMapping("/audio/tts")
    public ResponseEntity<ApiResponse<AudioResponse>> textToSpeech(
            @RequestBody AudioRequest request,
            Authentication authentication) {
        // 实现...
    }
    
    /**
     * 语音转文本
     */
    @PostMapping("/audio/stt")
    public ResponseEntity<ApiResponse<AudioResponse>> speechToText(
            @RequestParam("audioFile") MultipartFile audioFile,
            @RequestParam(value = "provider", required = false) String provider,
            @RequestParam(value = "model", required = false) String model,
            Authentication authentication) {
        // 实现...
    }
    
    /**
     * 获取用户AI配置
     */
    @GetMapping("/config")
    public ResponseEntity<ApiResponse<UserAIConfig>> getUserConfig(Authentication authentication) {
        // 实现...
    }
    
    /**
     * 更新用户AI配置
     */
    @PutMapping("/config")
    public ResponseEntity<ApiResponse<Void>> updateUserConfig(
            @RequestBody UserAIConfig config,
            Authentication authentication) {
        // 实现...
    }
}
```

---

## 七、配置管理

### 7.1 配置文件

**说明**: 配置文件仅用于统一接入模式，本地配置模式的API Key由用户在前端配置。

**application.yml**:
```yaml
ai:
  # 默认模式（仅影响首次使用或未配置用户）
  default-mode: unified  # unified | local
  
  # Gemini配置（统一接入模式使用）
  gemini:
    api-key: ${GEMINI_API_KEY:}
    base-url: https://generativelanguage.googleapis.com/v1beta
    default-model: gemini-2.0-flash-exp
  
  # OpenAI配置
  openai:
    api-key: ${OPENAI_API_KEY:}
    base-url: https://api.openai.com/v1
    default-model: gpt-4
  
  # 通义千问配置
  qwen:
    api-key: ${QWEN_API_KEY:}
    base-url: https://dashscope.aliyuncs.com/compatible-mode/v1
    default-model: qwen-max
  
  # 豆包配置
  doubao:
    api-key: ${DOUBAO_API_KEY:}
    base-url: https://ark.cn-beijing.volces.com/api/v3
    default-model: doubao-pro-4k
  
  # 默认配置
  default:
    text-provider: gemini
    text-model: gemini-2.0-flash-exp
    image-provider: gemini
    image-model: imagen-3.0-generate-001
    enable-fallback: true
```

### 7.2 配置类

```java
@Configuration
@ConfigurationProperties(prefix = "ai")
@Data
public class AIConfiguration {
    
    private GeminiConfig gemini;
    private OpenAIConfig openai;
    private QwenConfig qwen;
    private DoubaoConfig doubao;
    private DefaultConfig defaultConfig;
    
    @Data
    public static class GeminiConfig {
        private String apiKey;
        private String baseUrl;
        private String defaultModel;
    }
    
    // 其他配置类...
}
```

---

## 八、错误处理

### 8.1 统一异常类

```java
public class AIServiceException extends RuntimeException {
    private final String provider;
    private final String model;
    private final String errorCode;
    
    public AIServiceException(String message, String provider, String model) {
        super(message);
        this.provider = provider;
        this.model = model;
        this.errorCode = "AI_SERVICE_ERROR";
    }
}

public class UnsupportedModelException extends AIServiceException {
    public UnsupportedModelException(String provider, String model) {
        super("Unsupported model: " + model + " for provider: " + provider, 
              provider, model);
    }
}
```

### 8.2 全局异常处理

```java
@RestControllerAdvice
public class AIExceptionHandler {
    
    @ExceptionHandler(AIServiceException.class)
    public ResponseEntity<ApiResponse<Object>> handleAIServiceException(AIServiceException e) {
        return ResponseEntity.ok(ApiResponse.error(e.getMessage()));
    }
    
    @ExceptionHandler(UnsupportedModelException.class)
    public ResponseEntity<ApiResponse<Object>> handleUnsupportedModel(UnsupportedModelException e) {
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
            .body(ApiResponse.error("不支持的模型: " + e.getModel()));
    }
}
```

---

## 九、实施计划

### 9.1 第一阶段：基础框架（1周）

- [ ] 创建项目结构和包
- [ ] 定义适配器接口和DTO类
- [ ] 实现Gemini适配器（文本生成）
- [ ] 实现AIService和Controller基础框架
- [ ] 实现配置管理

### 9.2 第二阶段：多模型支持（1-2周）

- [ ] 实现OpenAI适配器
- [ ] 实现Qwen适配器
- [ ] 实现Doubao适配器
- [ ] 实现模型适配器管理
- [ ] 实现降级机制

### 9.3 第三阶段：多模态支持（1-2周）

- [ ] 实现图片生成适配器
- [ ] 实现音频处理适配器
- [ ] 实现视频生成适配器（如支持）
- [ ] 完善错误处理

### 9.4 第四阶段：流式支持和优化（1周）

- [ ] 实现流式文本生成（SSE）
- [ ] 性能优化
- [ ] 日志和监控
- [ ] 文档完善

---

## 十、前端改造

### 10.1 移除直接API调用

**改造前**:
```typescript
// 前端直接调用Gemini API
const response = await fetch('https://generativelanguage.googleapis.com/...', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${apiKey}`,  // API Key暴露在前端
  },
  body: JSON.stringify({...})
});
```

**改造后**:
```typescript
// 调用后端统一API
const response = await apiService.post('/api/ai/text/generate', {
  prompt: '...',
  systemInstruction: '...',
  // provider和model可选，使用用户配置
});
```

### 10.2 创建AI服务封装

```typescript
// frontend/services/aiService.ts
export class AIService {
  /**
   * 生成文本
   */
  async generateText(request: TextGenerationRequest): Promise<TextGenerationResponse> {
    return apiService.post('/api/ai/text/generate', request);
  }
  
  /**
   * 流式生成文本
   */
  async generateTextStream(
    request: TextGenerationRequest,
    onChunk: (chunk: string) => void
  ): Promise<void> {
    const eventSource = new EventSource('/api/ai/text/generate/stream', {
      method: 'POST',
      body: JSON.stringify(request)
    });
    
    eventSource.onmessage = (event) => {
      const data = JSON.parse(event.data);
      onChunk(data.content);
      if (data.done) {
        eventSource.close();
      }
    };
  }
  
  // 其他方法...
}
```

---

## 十一、测试计划

### 11.1 单元测试

- [ ] 测试各适配器的参数转换
- [ ] 测试响应解析
- [ ] 测试错误处理
- [ ] 测试降级机制

### 11.2 集成测试

- [ ] 测试完整API调用流程
- [ ] 测试多模型切换
- [ ] 测试流式响应
- [ ] 测试并发调用

### 11.3 性能测试

- [ ] 响应时间测试
- [ ] 并发能力测试
- [ ] 内存使用测试

---

## 十二、后续扩展

### 12.1 计费集成

在统一接入层基础上，可以轻松添加：
- 使用量记录
- 配额检查
- 费用计算

### 12.2 监控和限流

- API调用监控
- 限流控制
- 熔断机制

### 12.3 缓存优化

- 常用请求结果缓存
- 减少API调用成本

---

## 十三、双模式对比

### 13.1 功能对比

| 功能特性 | 统一接入模式 | 本地配置模式 |
|---------|------------|------------|
| API Key管理 | 系统管理，用户无需配置 | 用户自己配置和管理 |
| 费用承担 | 系统承担，用户付费使用 | 用户自己承担 |
| 配额管理 | 支持配额限制和计费 | 不支持，无限制 |
| 使用统计 | 系统统一统计和监控 | 无法统计 |
| 安全性 | API Key在后端，更安全 | API Key在客户端 |
| 隐私保护 | 请求经过后端 | 直接调用，更私密 |
| 限流控制 | 支持系统限流 | 不支持 |
| 降级机制 | 支持自动降级 | 不支持 |
| 成本控制 | 系统可控 | 用户自行控制 |

### 13.2 使用场景

**统一接入模式适用于**:
- 不想自己申请API Key的用户
- 需要配额管理和使用统计的用户
- 希望系统统一管理的用户
- 愿意付费使用服务的用户

**本地配置模式适用于**:
- 已有API Key的用户
- 希望自己承担费用的用户
- 对隐私要求较高的用户
- 不想受配额限制的用户

### 13.3 实施建议

1. **默认模式**：建议默认使用统一接入模式，降低系统成本
2. **模式切换**：提供清晰的切换界面和说明
3. **配置引导**：本地配置模式下，提供清晰的配置引导
4. **API Key验证**：本地配置模式下，可选验证API Key有效性
5. **模式提示**：在界面上清晰显示当前使用的模式

---

## 十四、总结

大模型统一接入层支持**双模式运行**，为用户提供灵活的选择：

1. **统一接入模式**：
   - 后端统一管理所有AI调用
   - API Key在后端，更安全
   - 支持配额管理和计费
   - 为后续计费系统提供基础

2. **本地配置模式**：
   - 用户自己配置API Key
   - 直接调用AI服务，不经过后端
   - 用户自己承担费用
   - 降低系统成本
   - 更好的隐私保护

通过适配器模式和统一的服务接口，系统可以灵活支持两种模式，满足不同用户的需求。同时，统一接入模式为后续的计费、监控、限流等功能提供了良好的基础。

本需求文档提供了完整的设计方案和实施计划，可以按照阶段逐步实施。

---

**文档维护**: 本文档应随系统开发进展持续更新和完善。

