# 跨时空信箱架构设计文档

**文档版本**: V1.0  
**编写日期**: 2025-12-30  
**功能模块**: 跨时空信箱  
**目标**: 设计统一的跨时空信箱系统架构，支持E-SOUL来信、共鸣消息、系统消息和用户对话

---

## 一、架构概述

### 1.1 系统定位

跨时空信箱是HeartSphere的核心通信系统，提供统一的消息管理平台，整合来自多个来源的消息：
- **E-SOUL来信**：AI生成的角色主动来信
- **共鸣消息**：来自其他心域的互动消息
- **系统消息**：系统通知和反馈
- **用户消息**：用户间对话

### 1.2 架构原则

1. **统一收件箱**：所有消息通过统一的数据模型和接口管理
2. **模块化设计**：不同消息类型通过模块化服务实现
3. **可扩展性**：易于添加新的消息类型和功能
4. **性能优化**：支持大量消息的高效查询和管理
5. **实时性**：支持实时消息推送和提醒

### 1.3 技术栈

**后端**:
- Spring Boot 3.x
- JPA / Hibernate
- MySQL 8.0+
- WebSocket (可选，用于实时推送)

**前端**:
- React + TypeScript
- Vite
- Tailwind CSS

---

## 二、系统架构

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────┐
│                     前端层 (Frontend)                     │
├─────────────────────────────────────────────────────────┤
│  MailboxModal  │  MessageList  │  ConversationView      │
│  (收件箱界面)    │  (消息列表)    │  (对话界面)            │
└─────────────────────────────────────────────────────────┘
                            │
                            │ HTTP/WebSocket
                            ▼
┌─────────────────────────────────────────────────────────┐
│                    API层 (Controllers)                    │
├─────────────────────────────────────────────────────────┤
│  MailboxController  │  ConversationController           │
│  (消息管理)          │  (对话管理)                        │
└─────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────┐
│                   服务层 (Services)                       │
├─────────────────────────────────────────────────────────┤
│  MailboxService          │  统一消息服务                  │
│  ├─ MessageService       │  - 消息CRUD                   │
│  ├─ ESoulLetterService   │  - 消息分类                   │
│  ├─ ResonanceService     │  - 消息提醒                   │
│  ├─ SystemMessageService │                              │
│  └─ ConversationService  │  对话服务                     │
│                          │  - 对话管理                   │
│                          │  - 消息发送                   │
└─────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────┐
│                   数据访问层 (Repository)                  │
├─────────────────────────────────────────────────────────┤
│  MailboxMessageRepository    │  ConversationRepository   │
│  ConversationMessageRepository│ NotificationSettingsRepo │
└─────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────┐
│                   数据层 (Database)                       │
├─────────────────────────────────────────────────────────┤
│  mailbox_messages          │  mailbox_conversations      │
│  mailbox_conversation_msgs │  mailbox_notification_sets  │
└─────────────────────────────────────────────────────────┘
```

### 2.2 模块划分

#### 2.2.1 消息模块 (Message Module)

**职责**：
- 统一的消息数据模型
- 消息的创建、查询、更新、删除
- 消息分类和筛选
- 消息状态管理（已读、重要、收藏等）

**核心类**：
- `MailboxMessage` (实体)
- `MailboxMessageRepository` (数据访问)
- `MailboxMessageService` (业务逻辑)
- `MailboxMessageController` (API接口)

#### 2.2.2 E-SOUL来信模块 (ESoul Letter Module)

**职责**：
- E-SOUL来信的生成（AI生成）
- 来信触发条件判断
- 来信内容个性化

**核心类**：
- `ESoulLetterService`
- `ESoulLetterGenerator` (AI生成器)

**依赖**：
- AI服务 (AIService)
- 记忆系统 (MemoryService)
- 用户信息 (UserService)
- **情绪服务 (EmotionService)** ⭐

#### 2.2.3 共鸣消息模块 (Resonance Module)

**职责**：
- 处理来自其他心域的互动消息
- 消息聚合和展示 ⭐
- 与心域连接系统的集成

**核心类**：
- `ResonanceMessageService`
- `ResonanceMessageHandler`
- `ResonanceMessageAggregator` ⭐（消息聚合器）

**依赖**：
- 心域连接服务 (HeartConnectService)

**消息聚合策略** ⭐：
1. **聚合维度**：
   - 相同来源（sender_id + sender_type）
   - 相同类型（message_type）
   - 时间范围（如1小时内）

2. **聚合规则**：
   - 相同来源 + 相同类型 + 1小时内 → 聚合显示
   - 聚合消息显示：`X个人点赞了你的内容`、`Y条新评论`等
   - 支持展开查看聚合消息详情

3. **实现方式**：
   ```java
   public class ResonanceMessageAggregator {
       /**
        * 聚合消息列表
        * @param messages 原始消息列表
        * @return 聚合后的消息列表（包含聚合消息和独立消息）
        */
       public List<AggregatedMessage> aggregateMessages(List<MailboxMessage> messages) {
           // 1. 按来源+类型+时间分组
           Map<String, List<MailboxMessage>> grouped = groupMessages(messages);
           
           // 2. 对每组进行聚合判断
           List<AggregatedMessage> result = new ArrayList<>();
           for (Map.Entry<String, List<MailboxMessage>> entry : grouped.entrySet()) {
               if (shouldAggregate(entry.getValue())) {
                   // 创建聚合消息
                   AggregatedMessage aggregated = createAggregatedMessage(entry.getValue());
                   result.add(aggregated);
               } else {
                   // 保持独立显示
                   result.addAll(convertToAggregated(entry.getValue()));
               }
           }
           return result;
       }
   }
   ```

4. **聚合消息数据结构**：
   - 在 `content_data` JSON字段中保存聚合信息：
     ```json
     {
       "aggregated": true,
       "count": 5,
       "source_type": "like",
       "related_ids": [101, 102, 103, 104, 105],
       "preview_items": [...]
     }
     ```

5. **前端展示**：
   - 聚合消息卡片显示聚合统计（如"5个人点赞了你的心域"）
   - 点击展开可查看详细信息列表
   - 支持批量操作（如批量感谢回复）

#### 2.2.4 系统消息模块 (System Message Module)

**职责**：
- 系统通知的发送
- 系统反馈的收集
- 系统对话的处理

**核心类**：
- `SystemMessageService`
- `SystemMessageHandler`

#### 2.2.5 对话模块 (Conversation Module)

**职责**：
- 用户间对话管理
- 对话消息的发送和接收
- 对话状态管理（置顶、免打扰等）

**核心类**：
- `Conversation` (实体)
- `ConversationMessage` (实体)
- `ConversationService`
- `ConversationController`

**对话消息与收件箱的关系** ⭐：
- **策略**：对话消息**不在**统一收件箱中显示，只在对话界面显示
- **原因**：
  1. 避免收件箱消息过多，影响用户体验
  2. 对话是持续性的，单独管理更清晰
  3. 减少数据冗余和查询复杂度

- **实现方式**：
  1. 对话消息存储在 `mailbox_conversation_messages` 表
  2. 收件箱（`mailbox_messages`）不包含对话消息
  3. 当用户A向用户B发起新对话时：
     - 创建对话（`mailbox_conversations`）
     - 发送第一条消息（`mailbox_conversation_messages`）
     - **可选**：在收件箱创建一条通知消息，类型为 `user_message`，提醒用户有新对话
     - 用户在收件箱看到通知后，点击进入对话界面查看完整对话

- **用户通知机制**：
  - 当有新对话或对话有新消息时：
    - 在对话列表中显示未读数量
    - 如果用户开启了用户消息提醒，显示浏览器通知
    - 不在统一收件箱中重复显示

#### 2.2.6 提醒模块 (Notification Module)

**职责**：
- 消息提醒设置
- 未读消息统计
- 实时提醒推送 ⭐（必需功能）
- **浏览器通知** ⭐（必需功能）

**核心类**：
- `NotificationSettings` (实体)
- `NotificationService`
- `BrowserNotificationService` ⭐（浏览器通知服务）

**浏览器通知实现** ⭐：
1. **前端实现**：
   - 请求浏览器通知权限（Notification API）
   - 监听新消息事件
   - 显示桌面通知

2. **后端支持**：
   - WebSocket推送新消息事件（可选，第一阶段可轮询）
   - 通知内容格式化

3. **通知内容**：
   ```typescript
   interface BrowserNotification {
     title: string;        // 消息标题
     body: string;         // 消息预览
     icon?: string;        // 发送者头像
     badge?: string;       // 应用图标
     tag?: string;         // 消息分类标签
     data?: any;           // 关联数据（消息ID等）
   }
   ```

4. **通知规则**：
   - 检查用户提醒设置（是否启用、免打扰时间）
   - 根据消息类型判断是否需要通知
   - 避免重复通知（相同来源的消息在短时间内只通知一次）

5. **实现步骤**：
   - 第一阶段：基础浏览器通知（新消息时显示）
   - 第二阶段：WebSocket实时推送（减少延迟）
   - 第三阶段：通知聚合和智能去重

---

## 三、数据模型设计

### 3.1 消息表 (mailbox_messages)

```sql
CREATE TABLE mailbox_messages (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    receiver_id BIGINT NOT NULL COMMENT '接收者用户ID',
    
    -- 发送者信息
    sender_type VARCHAR(50) NOT NULL COMMENT '发送者类型：esoul/heartsphere/system/user',
    sender_id BIGINT COMMENT '发送者ID（E-SOUL ID/心域ID/系统ID/用户ID）',
    sender_name VARCHAR(255) COMMENT '发送者名称',
    sender_avatar VARCHAR(1000) COMMENT '发送者头像URL',
    
    -- 消息信息
    message_type VARCHAR(50) NOT NULL COMMENT '消息类型（详见枚举）',
    message_category VARCHAR(50) NOT NULL COMMENT '消息分类：esoul_letter/resonance/system/user_message',
    title VARCHAR(500) COMMENT '消息标题',
    content TEXT NOT NULL COMMENT '消息内容',
    content_data TEXT COMMENT '消息扩展数据（JSON格式）',
    
    -- 状态标识
    is_read BOOLEAN DEFAULT FALSE COMMENT '是否已读',
    is_important BOOLEAN DEFAULT FALSE COMMENT '是否重要',
    is_starred BOOLEAN DEFAULT FALSE COMMENT '是否收藏',
    
    -- 关联信息
    related_id BIGINT COMMENT '关联对象ID',
    related_type VARCHAR(50) COMMENT '关联对象类型',
    reply_to_id BIGINT COMMENT '回复的消息ID',
    
    -- 时间戳
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    read_at DATETIME COMMENT '阅读时间',
    deleted_at DATETIME COMMENT '删除时间（软删除）',
    
    FOREIGN KEY (receiver_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_receiver (receiver_id, created_at),
    INDEX idx_category (message_category, created_at),
    INDEX idx_sender (sender_type, sender_id),
    INDEX idx_read (receiver_id, is_read),
    INDEX idx_related (related_type, related_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 3.2 对话表 (mailbox_conversations)

```sql
CREATE TABLE mailbox_conversations (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    participant1_id BIGINT NOT NULL COMMENT '参与者1用户ID',
    participant2_id BIGINT NOT NULL COMMENT '参与者2用户ID（或系统ID）',
    conversation_type VARCHAR(50) NOT NULL COMMENT '对话类型：user_to_user/user_to_system',
    
    -- 最后消息信息
    last_message_id BIGINT COMMENT '最后一条消息ID',
    last_message_at DATETIME COMMENT '最后消息时间',
    
    -- 参与者1的状态
    unread_count_1 INT DEFAULT 0 COMMENT '参与者1的未读数量',
    is_pinned_1 BOOLEAN DEFAULT FALSE COMMENT '参与者1是否置顶',
    is_muted_1 BOOLEAN DEFAULT FALSE COMMENT '参与者1是否免打扰',
    
    -- 参与者2的状态
    unread_count_2 INT DEFAULT 0 COMMENT '参与者2的未读数量',
    is_pinned_2 BOOLEAN DEFAULT FALSE COMMENT '参与者2是否置顶',
    is_muted_2 BOOLEAN DEFAULT FALSE COMMENT '参与者2是否免打扰',
    
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (participant1_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (participant2_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_participant1 (participant1_id, last_message_at),
    INDEX idx_participant2 (participant2_id, last_message_at),
    INDEX idx_participants (participant1_id, participant2_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 3.3 对话消息表 (mailbox_conversation_messages)

```sql
CREATE TABLE mailbox_conversation_messages (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    conversation_id BIGINT NOT NULL COMMENT '对话ID',
    
    -- 发送者信息
    sender_id BIGINT NOT NULL COMMENT '发送者ID',
    sender_type VARCHAR(50) NOT NULL COMMENT '发送者类型：user/system',
    
    -- 消息内容
    message_type VARCHAR(50) NOT NULL COMMENT '消息类型：text/image/voice/emoji等',
    content TEXT NOT NULL COMMENT '消息内容',
    content_data TEXT COMMENT '消息扩展数据（JSON格式）',
    
    -- 回复信息
    reply_to_id BIGINT COMMENT '回复的消息ID',
    
    -- 状态
    is_edited BOOLEAN DEFAULT FALSE COMMENT '是否已编辑',
    is_deleted BOOLEAN DEFAULT FALSE COMMENT '是否已删除',
    
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (conversation_id) REFERENCES mailbox_conversations(id) ON DELETE CASCADE,
    INDEX idx_conversation (conversation_id, created_at),
    INDEX idx_sender (sender_id, created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 3.4 提醒设置表 (mailbox_notification_settings)

```sql
CREATE TABLE mailbox_notification_settings (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL UNIQUE COMMENT '用户ID',
    
    -- 总开关
    enable_notifications BOOLEAN DEFAULT TRUE COMMENT '是否启用提醒',
    
    -- 分类开关
    esoul_letter_enabled BOOLEAN DEFAULT TRUE COMMENT 'E-SOUL来信提醒',
    resonance_enabled BOOLEAN DEFAULT TRUE COMMENT '共鸣消息提醒',
    system_message_enabled BOOLEAN DEFAULT TRUE COMMENT '系统消息提醒',
    user_message_enabled BOOLEAN DEFAULT TRUE COMMENT '用户消息提醒',
    
    -- 免打扰时间
    quiet_hours_start TIME COMMENT '免打扰开始时间',
    quiet_hours_end TIME COMMENT '免打扰结束时间',
    
    -- 其他设置
    sound_enabled BOOLEAN DEFAULT TRUE COMMENT '是否启用声音',
    
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_user (user_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 3.5 数据迁移策略

**与现有表的关系**：

现有 `chronos_letters` 表主要用于存储旧的用户反馈和管理员回复。新架构中：
- **保留** `chronos_letters` 表用于向后兼容
- **迁移**：提供数据迁移脚本，将旧数据迁移到新表
- **统一**：前端统一使用新的API接口，内部可兼容旧数据

---

## 四、核心服务设计

### 4.1 消息服务 (MailboxMessageService)

**核心方法**：

```java
public interface MailboxMessageService {
    // 消息查询
    Page<MailboxMessage> getMessages(Long userId, MessageQueryRequest request);
    MailboxMessage getMessageById(Long messageId, Long userId);
    UnreadCountResponse getUnreadCount(Long userId);
    
    // 消息操作
    MailboxMessage createMessage(CreateMessageRequest request);
    MailboxMessage markAsRead(Long messageId, Long userId);
    MailboxMessage markAsImportant(Long messageId, Long userId, boolean important);
    MailboxMessage markAsStarred(Long messageId, Long userId, boolean starred);
    void deleteMessage(Long messageId, Long userId);
    void batchDeleteMessages(List<Long> messageIds, Long userId);
    
    // 消息搜索
    Page<MailboxMessage> searchMessages(Long userId, String keyword, MessageQueryRequest request);
}
```

### 4.2 E-SOUL来信服务 (ESoulLetterService)

**核心方法**：

```java
public interface ESoulLetterService {
    // 触发来信
    MailboxMessage triggerLetter(Long userId, ESoulLetterTrigger trigger);
    
    // 生成来信内容
    ESoulLetterContent generateLetterContent(Long userId, Long esoulId, ESoulLetterType type);
    
    // 检查触发条件
    boolean shouldTriggerLetter(Long userId);
    
    // 获取来信历史
    List<MailboxMessage> getLetterHistory(Long userId, Long esoulId);
}
```

**来信触发条件**：
1. 用户离线时间超过阈值（如60秒）
2. 每日首次使用
3. 检测到用户情绪波动
4. 长时间未收到来信

**来信生成流程**：
```
1. 检查触发条件
2. 选择发件人（E-SOUL）
   - 优先：最近聊过的角色
   - 备选：第一个场景的第一个角色
3. 收集上下文
   - 用户日记
   - 对话历史
   - 用户情绪状态（通过EmotionService获取）⭐
4. 根据情绪状态选择来信类型和语调
   - 获取用户当前情绪（EmotionService.analyzeEmotion）
   - 根据情绪匹配来信类型：
     * 负面情绪 → 关怀型来信（ESoulLetterType.CARE）
     * 正面情绪 → 分享型来信（ESoulLetterType.SHARE）
     * 中性情绪 → 问候型来信（ESoulLetterType.GREETING）
5. 调用AI生成来信内容（传入情绪上下文）
6. 创建消息并保存
7. 发送提醒（如果需要）
8. 记录交互历史（可选，用于优化后续来信）
```

**情绪服务集成说明** ⭐：
```java
@Service
public class ESoulLetterService {
    private final EmotionService emotionService;
    
    /**
     * 获取用户当前情绪状态并匹配来信类型
     */
    private ESoulLetterType determineLetterTypeByEmotion(Long userId) {
        try {
            // 获取用户最近的情绪分析结果
            EmotionAnalysisResponse emotion = emotionService.getLatestEmotion(userId);
            
            if (emotion == null) {
                return ESoulLetterType.GREETING; // 默认问候
            }
            
            // 根据情绪倾向选择来信类型
            if (emotion.getEmotionScore() < -0.3) {
                // 负面情绪，发送关怀型来信
                return ESoulLetterType.CARE;
            } else if (emotion.getEmotionScore() > 0.3) {
                // 正面情绪，发送分享型来信
                return ESoulLetterType.SHARE;
            } else {
                // 中性情绪，发送问候型来信
                return ESoulLetterType.GREETING;
            }
        } catch (Exception e) {
            log.warn("获取用户情绪失败，使用默认来信类型", e);
            return ESoulLetterType.GREETING;
        }
    }
    
    /**
     * 在AI生成提示词中包含情绪信息
     */
    private String buildLetterPrompt(Long userId, ESoulLetterType type, EmotionAnalysisResponse emotion) {
        String emotionContext = "";
        if (emotion != null) {
            emotionContext = String.format(
                "用户当前情绪：%s（得分：%.2f）。请根据用户情绪调整来信的语调和内容，",
                emotion.getEmotionLabel(), 
                emotion.getEmotionScore()
            );
        }
        // ... 其他提示词内容
        return emotionContext + "...";
    }
}
```

### 4.3 共鸣消息服务 (ResonanceMessageService)

**核心方法**：

```java
public interface ResonanceMessageService {
    // 创建共鸣消息
    MailboxMessage createResonanceMessage(CreateResonanceMessageRequest request);
    
    // 处理点赞
    MailboxMessage handleLike(Long userId, Long heartSphereId, Long contentId);
    
    // 处理评论
    MailboxMessage handleComment(Long userId, Long heartSphereId, Long contentId, String comment);
    
    // 处理留言
    MailboxMessage handleWarmMessage(Long userId, Long heartSphereId, String message);
    
    // 处理分享
    MailboxMessage handleShare(Long userId, Long heartSphereId, Long contentId);
    
    // 处理连接请求
    MailboxMessage handleConnectionRequest(Long requesterId, Long heartSphereOwnerId, String requestMessage);
    
    // 获取聚合后的消息列表 ⭐
    List<AggregatedMessage> getAggregatedMessages(Long userId, MessageQueryRequest request);
    
    // 展开聚合消息 ⭐
    List<MailboxMessage> expandAggregatedMessage(Long aggregatedMessageId, Long userId);
}
```

**消息聚合实现** ⭐：

```java
@Service
public class ResonanceMessageAggregator {
    
    /**
     * 判断消息是否应该聚合
     */
    private boolean shouldAggregate(List<MailboxMessage> messages) {
        if (messages.size() < 2) {
            return false; // 少于2条不聚合
        }
        
        // 检查时间范围（1小时内）
        LocalDateTime earliest = messages.stream()
            .map(MailboxMessage::getCreatedAt)
            .min(LocalDateTime::compareTo)
            .orElse(LocalDateTime.now());
        LocalDateTime latest = messages.stream()
            .map(MailboxMessage::getCreatedAt)
            .max(LocalDateTime::compareTo)
            .orElse(LocalDateTime.now());
        
        return ChronoUnit.HOURS.between(earliest, latest) <= 1;
    }
    
    /**
     * 创建聚合消息
     */
    private AggregatedMessage createAggregatedMessage(List<MailboxMessage> messages) {
        String messageType = messages.get(0).getMessageType();
        String senderType = messages.get(0).getSenderType();
        
        // 统计信息
        Map<String, Object> aggregationData = new HashMap<>();
        aggregationData.put("count", messages.size());
        aggregationData.put("message_type", messageType);
        aggregationData.put("source_ids", messages.stream()
            .map(MailboxMessage::getSenderId)
            .collect(Collectors.toList()));
        aggregationData.put("preview", messages.stream()
            .limit(3)
            .map(this::createPreview)
            .collect(Collectors.toList()));
        
        // 生成聚合标题
        String title = generateAggregatedTitle(messageType, messages.size());
        
        // 创建聚合消息（第一条消息作为基础）
        MailboxMessage baseMessage = messages.get(0);
        MailboxMessage aggregated = new MailboxMessage();
        aggregated.setReceiverId(baseMessage.getReceiverId());
        aggregated.setSenderType(senderType);
        aggregated.setMessageType(messageType + "_aggregated");
        aggregated.setMessageCategory("resonance");
        aggregated.setTitle(title);
        aggregated.setContent(generateAggregatedContent(messages));
        aggregated.setContentData(JSON.toJSONString(aggregationData));
        
        return new AggregatedMessage(aggregated, messages);
    }
}
```

### 4.4 系统消息服务 (SystemMessageService)

**核心方法**：

```java
public interface SystemMessageService {
    // 发送系统通知
    MailboxMessage sendNotification(Long userId, String title, String content, boolean important);
    
    // 发送系统反馈请求
    MailboxMessage sendFeedbackRequest(Long userId, FeedbackRequestType type);
    
    // 处理系统对话
    SystemDialogueResponse handleSystemDialogue(Long userId, String userMessage);
    
    // 发送系统对话消息
    MailboxMessage sendSystemDialogue(Long userId, String content);
}
```

### 4.5 对话服务 (ConversationService)

**核心方法**：

```java
public interface ConversationService {
    // 对话管理
    Page<Conversation> getConversations(Long userId, ConversationQueryRequest request);
    Conversation getConversationById(Long conversationId, Long userId);
    Conversation createConversation(Long userId1, Long userId2);
    
    // 消息发送
    ConversationMessage sendMessage(Long conversationId, Long senderId, SendMessageRequest request);
    
    // 消息查询
    Page<ConversationMessage> getMessages(Long conversationId, Long userId, MessageQueryRequest request);
    
    // 对话状态
    Conversation markAsRead(Long conversationId, Long userId);
    Conversation pinConversation(Long conversationId, Long userId, boolean pinned);
    Conversation muteConversation(Long conversationId, Long userId, boolean muted);
    
    // 删除对话
    void deleteConversation(Long conversationId, Long userId);
    
    // 创建对话时，可选创建收件箱通知 ⭐
    /**
     * 创建新对话，并可选地在收件箱创建通知
     * @param userId1 发起者ID
     * @param userId2 接收者ID
     * @param initialMessage 初始消息
     * @param createMailboxNotification 是否在收件箱创建通知
     * @return 创建的对话
     */
    Conversation createConversationWithNotification(
        Long userId1, 
        Long userId2, 
        String initialMessage,
        boolean createMailboxNotification
    );
}
```

**对话消息处理策略** ⭐：

```java
@Service
public class ConversationService {
    
    /**
     * 发送对话消息
     * 注意：对话消息只在对话界面显示，不在统一收件箱显示
     */
    public ConversationMessage sendMessage(Long conversationId, Long senderId, SendMessageRequest request) {
        // 1. 验证对话和权限
        Conversation conversation = getConversationById(conversationId, senderId);
        
        // 2. 创建对话消息（存储在 mailbox_conversation_messages 表）
        ConversationMessage message = new ConversationMessage();
        message.setConversationId(conversationId);
        message.setSenderId(senderId);
        message.setContent(request.getContent());
        // ... 其他字段设置
        
        message = conversationMessageRepository.save(message);
        
        // 3. 更新对话的最后消息信息
        conversation.setLastMessageId(message.getId());
        conversation.setLastMessageAt(LocalDateTime.now());
        
        // 4. 更新接收者的未读数量
        Long receiverId = conversation.getParticipant1Id().equals(senderId) 
            ? conversation.getParticipant2Id() 
            : conversation.getParticipant1Id();
        updateUnreadCount(conversation, receiverId, 1);
        
        conversationRepository.save(conversation);
        
        // 5. 发送浏览器通知（如果接收者开启了提醒）
        notificationService.notifyNewConversationMessage(receiverId, message);
        
        // 注意：不创建 mailbox_messages 记录
        // 对话消息只在 mailbox_conversation_messages 中
        
        return message;
    }
}
```

---

## 五、API接口设计

### 5.1 消息接口

**基础路径**: `/api/mailbox/messages`

| 方法 | 路径 | 功能 | 说明 |
|------|------|------|------|
| GET | `/` | 获取消息列表 | 支持分类、筛选、分页 |
| GET | `/{id}` | 获取消息详情 | 包含关联内容 |
| PUT | `/{id}/read` | 标记已读 | |
| PUT | `/{id}/important` | 标记重要 | |
| PUT | `/{id}/star` | 收藏/取消收藏 | |
| DELETE | `/{id}` | 删除消息 | |
| DELETE | `/batch` | 批量删除 | |
| GET | `/unread/count` | 获取未读数量 | |

### 5.2 E-SOUL来信接口

**基础路径**: `/api/mailbox/esoul-letters`

| 方法 | 路径 | 功能 | 说明 |
|------|------|------|------|
| POST | `/` | 触发来信（内部） | 系统内部调用 |
| POST | `/{messageId}/reply` | 回复来信 | 创建对话或直接回复 |

### 5.3 共鸣消息接口

**基础路径**: `/api/mailbox/resonance-messages`

| 方法 | 路径 | 功能 | 说明 |
|------|------|------|------|
| POST | `/` | 创建共鸣消息（内部） | 系统内部调用 |
| POST | `/{messageId}/reply` | 回复共鸣消息 | |

### 5.4 系统消息接口

**基础路径**: `/api/mailbox/system-messages`

| 方法 | 路径 | 功能 | 说明 |
|------|------|------|------|
| POST | `/` | 发送系统消息（内部） | 系统内部调用 |
| POST | `/{messageId}/reply` | 回复系统消息 | 用于系统对话 |

### 5.5 对话接口

**基础路径**: `/api/mailbox/conversations`

| 方法 | 路径 | 功能 | 说明 |
|------|------|------|------|
| GET | `/` | 获取对话列表 | |
| POST | `/` | 创建对话 | |
| GET | `/{id}` | 获取对话详情 | |
| GET | `/{id}/messages` | 获取对话消息 | 支持分页 |
| POST | `/{id}/messages` | 发送消息 | |
| PUT | `/{id}/read` | 标记已读 | |
| PUT | `/{id}/pin` | 置顶/取消置顶 | |
| PUT | `/{id}/mute` | 免打扰设置 | |
| DELETE | `/{id}` | 删除对话 | |

### 5.6 提醒设置接口

**基础路径**: `/api/mailbox/notification-settings`

| 方法 | 路径 | 功能 | 说明 |
|------|------|------|------|
| GET | `/` | 获取提醒设置 | |
| PUT | `/` | 更新提醒设置 | |

---

## 六、前端架构设计

### 6.1 组件结构

```
MailboxModal (主入口)
├── MailboxHeader (头部：搜索、设置)
├── MailboxSidebar (侧边栏：分类导航)
├── MessageList (消息列表)
│   ├── MessageCard (消息卡片)
│   └── MessageFilter (消息筛选)
├── MessageDetail (消息详情)
│   ├── MessageContent (消息内容)
│   ├── RelatedContent (关联内容)
│   └── MessageActions (操作按钮)
├── ConversationList (对话列表)
│   └── ConversationItem (对话项)
├── ConversationView (对话界面)
│   ├── MessageBubble (消息气泡)
│   └── MessageInput (输入框)
├── NotificationBadge (提醒徽章)
└── NewMessageNotification ⭐ (新消息弹窗)
```

### 6.2 状态管理

**使用Context API管理状态**：

```typescript
interface MailboxContextType {
  // 消息列表
  messages: MailboxMessage[];
  loading: boolean;
  
  // 当前选中的消息/对话
  selectedMessage: MailboxMessage | null;
  selectedConversation: Conversation | null;
  
  // 筛选和分类
  currentCategory: MessageCategory;
  filters: MessageFilters;
  
  // 未读统计
  unreadCount: UnreadCount;
  
  // 操作方法
  loadMessages: () => Promise<void>;
  markAsRead: (messageId: number) => Promise<void>;
  deleteMessage: (messageId: number) => Promise<void>;
  // ...
}
```

### 6.3 API服务

**统一API服务类**：

```typescript
class MailboxApi {
  // 消息相关
  getMessages(query: MessageQueryRequest): Promise<Page<MailboxMessage>>;
  getMessageById(id: number): Promise<MailboxMessage>;
  markAsRead(id: number): Promise<void>;
  deleteMessage(id: number): Promise<void>;
  
  // E-SOUL来信
  replyToESoulLetter(messageId: number, content: string): Promise<void>;
  
  // 对话相关
  getConversations(): Promise<Conversation[]>;
  getConversationMessages(conversationId: number): Promise<ConversationMessage[]>;
  sendMessage(conversationId: number, content: string): Promise<ConversationMessage>;
  
  // 提醒设置
  getNotificationSettings(): Promise<NotificationSettings>;
  updateNotificationSettings(settings: NotificationSettings): Promise<void>;
}
```

### 6.4 浏览器通知服务 ⭐（必需功能）

**浏览器通知实现**：

```typescript
class BrowserNotificationService {
  // 请求通知权限
  async requestPermission(): Promise<NotificationPermission>;
  
  // 显示通知
  showNotification(notification: BrowserNotification): void;
  
  // 关闭通知
  closeNotification(tag: string): void;
  
  // 检查是否支持通知
  isSupported(): boolean;
  
  // 检查是否有权限
  hasPermission(): boolean;
}

// 使用示例
const notificationService = new BrowserNotificationService();

// 在应用初始化时请求权限
if (notificationService.isSupported()) {
  await notificationService.requestPermission();
}

// 收到新消息时显示通知
notificationService.showNotification({
  title: '新消息',
  body: `${message.senderName}: ${message.title}`,
  icon: message.senderAvatar,
  tag: `message-${message.id}`,
  data: { messageId: message.id }
});
```

### 6.5 实时更新（可选，后续优化）

**WebSocket集成**：

```typescript
class MailboxWebSocket {
  connect(): void;
  disconnect(): void;
  onNewMessage(callback: (message: MailboxMessage) => void): void;
  onMessageRead(callback: (messageId: number) => void): void;
}
```

---

## 七、性能优化

### 7.1 数据库优化

1. **索引优化**：
   - 为常用查询字段建立复合索引
   - 定期分析慢查询日志

2. **分页优化**：
   - 使用游标分页替代offset分页（大数据量时）
   - 限制每页最大数量

3. **缓存策略**：
   - 未读数量缓存（Redis，5分钟过期）
   - 消息列表缓存（按用户，1分钟过期）

### 7.2 查询优化

1. **懒加载**：
   - 消息详情按需加载关联内容
   - 对话消息按需分页加载

2. **批量操作**：
   - 批量标记已读
   - 批量删除消息

3. **异步处理**：
   - 消息生成异步化（E-SOUL来信）
   - 提醒推送异步化

### 7.3 前端优化

1. **虚拟滚动**：
   - 消息列表使用虚拟滚动（长列表）

2. **防抖节流**：
   - 搜索输入防抖
   - 滚动加载节流

3. **数据预加载**：
   - 预加载下一页消息
   - 预加载消息详情

---

## 八、安全设计

### 8.1 权限控制

1. **消息访问控制**：
   - 用户只能访问自己的消息
   - 对话参与者验证

2. **操作权限**：
   - 仅发送者或接收者可删除消息
   - 仅接收者可标记已读

### 8.2 内容安全

1. **内容审核**：
   - 用户消息内容审核（敏感词过滤）
   - AI生成内容验证

2. **防滥用**：
   - 消息发送频率限制
   - 批量操作限制

### 8.3 数据保护

1. **敏感信息**：
   - 消息内容加密存储（可选）
   - 用户隐私保护

2. **数据备份**：
   - 定期数据备份
   - 软删除机制（支持恢复）

---

## 九、扩展性设计

### 9.1 消息类型扩展

通过枚举和策略模式支持新的消息类型：

```java
public enum MessageType {
    // E-SOUL来信
    ESOUL_GREETING,
    ESOUL_CARE,
    ESOUL_SHARE,
    ESOUL_REMINDER,
    
    // 共鸣消息
    RESONANCE_LIKE,
    RESONANCE_COMMENT,
    // ... 可扩展
}
```

### 9.2 提醒方式扩展

支持多种提醒方式：
- 界面提醒（已实现）✅
- **浏览器通知（必需功能）** ⭐
- 邮件通知（可选，后续优化）
- 移动推送（可选，后续优化）
- WebSocket实时推送（可选，后续优化）

### 9.3 消息内容扩展

通过 `content_data` JSON字段支持扩展内容：
- 富文本
- 图片
- 语音
- 视频
- 链接预览

---

## 十、测试策略

### 10.1 单元测试

- 服务层方法单元测试
- 数据访问层测试
- 工具类测试

### 10.2 集成测试

- API接口集成测试
- 数据库操作测试
- 消息流程测试

### 10.3 性能测试

- 消息列表查询性能
- 并发消息发送性能
- 大数据量测试

### 10.4 前端测试

- 组件渲染测试
- 交互测试
- 响应式测试

---

## 十一、部署和运维

### 11.1 数据库迁移

提供Flyway迁移脚本：
- 创建新表
- 数据迁移（从chronos_letters）
- 索引优化

### 11.2 监控指标

- 消息创建速率
- 消息查询延迟
- 未读消息数量
- 错误率

### 11.3 日志记录

- 消息操作日志
- 错误日志
- 性能日志

---

## 十二、后续优化方向

1. **实时推送**：WebSocket实时消息推送
2. **消息搜索**：全文搜索（Elasticsearch）
3. **智能分类**：AI自动分类和标签
4. **消息推荐**：基于用户行为的消息推荐
5. **多设备同步**：跨设备消息同步
6. **消息导出**：导出消息为PDF或其他格式

---

---

## 十三、关键设计决策说明 ⭐

### 13.1 情绪服务集成

**决策**：E-SOUL来信需要根据用户当前情绪状态匹配来信类型和语调。

**实现**：
- 集成 `EmotionService` 获取用户最新情绪分析结果
- 根据情绪得分选择来信类型（关怀/分享/问候）
- 在AI生成提示词中包含情绪上下文

**优势**：让来信更加贴心和个性化，增强用户情感连接。

---

### 13.2 对话消息与收件箱分离

**决策**：对话消息不在统一收件箱中显示，只在对话界面显示。

**原因**：
1. 避免收件箱消息过多，影响用户体验
2. 对话是持续性的，单独管理更清晰
3. 减少数据冗余和查询复杂度

**实现**：
- 对话消息存储在 `mailbox_conversation_messages` 表
- 收件箱（`mailbox_messages`）不包含对话消息
- 可选：新对话时在收件箱创建一条通知消息

**优势**：收件箱专注于一次性消息，对话专注于持续沟通。

---

### 13.3 共鸣消息聚合策略

**决策**：相同来源、相同类型、1小时内的共鸣消息进行聚合显示。

**实现**：
- 实现 `ResonanceMessageAggregator` 服务
- 查询时自动聚合，前端支持展开查看详情
- 聚合信息存储在 `content_data` JSON字段

**优势**：
- 减少界面混乱，提升用户体验
- 重要消息不会被淹没
- 支持批量操作（如批量感谢回复）

---

### 13.4 浏览器通知为必需功能

**决策**：浏览器通知作为第一阶段实现的必需功能，而非可选功能。

**实现**：
- 前端实现 `BrowserNotificationService`
- 应用初始化时请求通知权限
- 新消息到达时显示桌面通知
- 根据用户设置判断是否通知

**优势**：及时提醒用户新消息，提升用户参与度。

---

**文档状态**: 架构设计已完成 ✅（已补充关键设计决策）

