# 增加系统温度感需求分析文档 - 第三阶段

**文档版本**: V1.0  
**编写日期**: 2025-12-22  
**产品定位**: 心域 - 利用AI能力为用户提供心灵停放的港湾  
**目标**: 实现陪伴式交互系统和成长记录系统，让系统成为用户成长的见证者和陪伴者

---

## 一、需求概述

### 1.1 背景

要让心域成为一个真正有温度的心灵港湾，系统不仅需要感知情绪和记住故事，更需要：
1. **主动陪伴**：不是被动响应，而是主动关怀和陪伴
2. **成长见证**：记录和见证用户的成长轨迹，形成情感记忆

### 1.2 核心目标

- ✅ **陪伴式交互**：数字生命体能够主动关怀，而不是被动响应
- ✅ **成长记录**：记录用户在心域的成长轨迹，形成情感记忆
- ✅ **成长可视化**：可视化展示用户的成长历程
- ✅ **成长庆祝**：在重要的成长节点给予庆祝和鼓励
- ✅ **陪伴记忆**：记录系统与用户共同度过的美好时光

---

## 二、陪伴式交互系统

### 2.1 主动关怀机制

#### 2.1.1 关怀触发条件

**功能描述**: 定义系统主动关怀用户的触发条件，建立完善的关怀触发机制

**详细需求**:

1. **时间触发系统**

   **定期问候触发**:
   ```typescript
   interface ScheduledGreetingTrigger {
     type: 'scheduled_greeting';
     timeSlots: Array<{
       hour: number; // 0-23
       minute: number; // 0-59
       greetingType: 'morning' | 'afternoon' | 'evening' | 'night';
       enabled: boolean;
     }>;
     userPreference?: {
       enabled: boolean;
       preferredTimes?: number[]; // 偏好时间（小时）
       timezone?: string; // 用户时区
     };
   }
   
   const defaultGreetingSlots = [
     { hour: 7, minute: 0, greetingType: 'morning', enabled: true },
     { hour: 12, minute: 0, greetingType: 'afternoon', enabled: true },
     { hour: 18, minute: 0, greetingType: 'evening', enabled: true },
     { hour: 21, minute: 0, greetingType: 'night', enabled: true }
   ];
   ```

   **长时间未互动触发**:
   ```typescript
   interface InactivityTrigger {
     type: 'inactivity';
     thresholds: Array<{
       duration: number; // 未互动时长（小时）
       careLevel: 'gentle' | 'moderate' | 'strong'; // 关怀强度
       messageTemplate: string;
     }>;
   }
   
   const inactivityThresholds = [
     { duration: 24, careLevel: 'gentle', messageTemplate: '好久不见，想你了～' },
     { duration: 72, careLevel: 'moderate', messageTemplate: '好几天没见了，最近还好吗？' },
     { duration: 168, careLevel: 'strong', messageTemplate: '一周没见了，想和你聊聊～' }
   ];
   
   // 检测逻辑
   function checkInactivityTrigger(userId: number): CareTrigger | null {
     const lastInteractionTime = getUserLastInteractionTime(userId);
     const now = Date.now();
     const hoursSinceLastInteraction = (now - lastInteractionTime) / (1000 * 60 * 60);
     
     for (const threshold of inactivityThresholds) {
       if (hoursSinceLastInteraction >= threshold.duration) {
         // 检查是否已经发送过这个级别的关怀
         const lastCareTime = getLastCareTime(userId, 'inactivity', threshold.careLevel);
         const hoursSinceLastCare = (now - lastCareTime) / (1000 * 60 * 60);
         
         // 至少间隔阈值的一半时间才再次触发
         if (hoursSinceLastCare >= threshold.duration / 2) {
           return {
             type: 'inactivity',
             level: threshold.careLevel,
             duration: hoursSinceLastInteraction,
             messageTemplate: threshold.messageTemplate
           };
         }
       }
     }
     
     return null;
   }
   ```

   **特殊时间关怀触发**:
   ```typescript
   interface SpecialTimeCareTrigger {
     type: 'special_time';
     specialTimes: Array<{
       timeRange: [number, number]; // 时间范围（小时）
       dayOfWeek?: number[]; // 星期几（0-6，可选）
       careType: 'late_night' | 'weekend' | 'holiday' | 'lonely_hour';
       messageTemplate: string;
     }>;
   }
   
   const specialTimeTriggers = [
     {
       timeRange: [23, 6], // 深夜到凌晨
       careType: 'late_night',
       messageTemplate: '这么晚了还在呀，要注意休息哦 💙'
     },
     {
       timeRange: [0, 24],
       dayOfWeek: [0, 6], // 周末
       careType: 'weekend',
       messageTemplate: '周末愉快！有什么计划吗？'
     },
     {
       timeRange: [22, 2], // 深夜时段
       careType: 'lonely_hour',
       messageTemplate: '夜深了，如果你感到孤单，我在这里陪着你 🌙'
     }
   ];
   ```

   **用户习惯时间触发**:
   ```typescript
   interface UserHabitTimeTrigger {
     type: 'habit_time';
     userHabitPattern: {
       userId: number;
       preferredHours: number[]; // 用户常用的时间段（小时）
       confidence: number; // 习惯模式的置信度（0-1）
       lastUpdated: number;
     };
   }
   
   // 分析用户使用习惯
   function analyzeUserHabitPattern(userId: number): UserHabitTimeTrigger | null {
     const usageHistory = getUserUsageHistory(userId, 30); // 最近30天
     
     // 统计每个小时的使用频率
     const hourFrequency = new Array(24).fill(0);
     usageHistory.forEach(usage => {
       const hour = new Date(usage.timestamp).getHours();
       hourFrequency[hour]++;
     });
     
     // 找出使用频率最高的时间段（频率 > 平均值 * 1.5）
     const avgFrequency = hourFrequency.reduce((a, b) => a + b, 0) / 24;
     const preferredHours = hourFrequency
       .map((freq, hour) => ({ hour, freq }))
       .filter(({ freq }) => freq > avgFrequency * 1.5)
       .map(({ hour }) => hour);
     
     if (preferredHours.length === 0) return null;
     
     return {
       type: 'habit_time',
       userHabitPattern: {
         userId,
         preferredHours,
         confidence: calculateConfidence(hourFrequency, preferredHours),
         lastUpdated: Date.now()
       }
     };
   }
   ```

2. **情绪触发系统**

   **消极情绪触发**:
   ```typescript
   interface NegativeEmotionTrigger {
     type: 'negative_emotion';
     emotionTypes: EmotionType[]; // 触发关怀的消极情绪类型
     intensityThreshold: EmotionIntensity; // 强度阈值
     durationThreshold?: number; // 持续时间阈值（小时）
     careInterval: number; // 关怀间隔（小时）
   }
   
   const negativeEmotionTrigger: NegativeEmotionTrigger = {
     type: 'negative_emotion',
     emotionTypes: [
       EmotionType.SAD,
       EmotionType.ANXIOUS,
       EmotionType.ANGRY,
       EmotionType.LONELY,
       EmotionType.CONFUSED
     ],
     intensityThreshold: EmotionIntensity.MODERATE, // 中度以上
     durationThreshold: 2, // 持续2小时以上
     careInterval: 4 // 每4小时最多关怀一次
   };
   
   // 检测逻辑
   function checkNegativeEmotionTrigger(userId: number): CareTrigger | null {
     const recentEmotions = getRecentEmotions(userId, 24); // 最近24小时
     
     // 过滤消极情绪
     const negativeEmotions = recentEmotions.filter(e => 
       negativeEmotionTrigger.emotionTypes.includes(e.emotionType) &&
       getIntensityLevel(e.emotionIntensity) >= getIntensityLevel(negativeEmotionTrigger.intensityThreshold)
     );
     
     if (negativeEmotions.length === 0) return null;
     
     // 检查持续时间
     const firstNegativeEmotion = negativeEmotions[0];
     const duration = (Date.now() - firstNegativeEmotion.timestamp) / (1000 * 60 * 60);
     
     if (duration < (negativeEmotionTrigger.durationThreshold || 0)) {
       return null;
     }
     
     // 检查关怀间隔
     const lastCareTime = getLastCareTime(userId, 'negative_emotion');
     const hoursSinceLastCare = (Date.now() - lastCareTime) / (1000 * 60 * 60);
     
     if (hoursSinceLastCare < negativeEmotionTrigger.careInterval) {
       return null;
     }
     
     return {
       type: 'negative_emotion',
       primaryEmotion: negativeEmotions[0].emotionType,
       intensity: negativeEmotions[0].emotionIntensity,
       duration,
       careLevel: duration > 12 ? 'strong' : duration > 6 ? 'moderate' : 'gentle'
     };
   }
   ```

   **情绪变化触发**:
   ```typescript
   interface EmotionChangeTrigger {
     type: 'emotion_change';
     changeThreshold: number; // 情绪变化阈值（-1到1）
     timeWindow: number; // 时间窗口（小时）
   }
   
   // 检测情绪急剧变化
   function checkEmotionChangeTrigger(userId: number): CareTrigger | null {
     const recentEmotions = getRecentEmotions(userId, 6); // 最近6小时
     
     if (recentEmotions.length < 2) return null;
     
     // 计算情绪分数变化
     const emotionScores = recentEmotions.map(e => calculateEmotionScore(e));
     const changeRate = (emotionScores[emotionScores.length - 1] - emotionScores[0]) / emotionScores.length;
     
     // 如果情绪急剧下降（变化率 < -0.3）
     if (changeRate < -0.3) {
       return {
         type: 'emotion_change',
         changeDirection: 'declining',
         changeRate,
         fromEmotion: recentEmotions[0].emotionType,
         toEmotion: recentEmotions[recentEmotions.length - 1].emotionType,
         careLevel: Math.abs(changeRate) > 0.5 ? 'strong' : 'moderate'
       };
     }
     
     // 如果情绪急剧上升，也可以给予鼓励
     if (changeRate > 0.3) {
       return {
         type: 'emotion_change',
         changeDirection: 'improving',
         changeRate,
         fromEmotion: recentEmotions[0].emotionType,
         toEmotion: recentEmotions[recentEmotions.length - 1].emotionType,
         careLevel: 'encouraging'
       };
     }
     
     return null;
   }
   ```

3. **行为触发系统**

   **首次使用触发**:
   ```typescript
   interface FirstUseTrigger {
     type: 'first_use';
     features: string[]; // 功能列表
   }
   
   // 检测首次使用
   function checkFirstUseTrigger(userId: number, featureId: string): CareTrigger | null {
     const hasUsedBefore = checkFeatureUsage(userId, featureId);
     
     if (!hasUsedBefore) {
       return {
         type: 'first_use',
         featureId,
         featureName: getFeatureName(featureId),
         welcomeMessage: generateFirstUseWelcome(featureId)
       };
     }
     
     return null;
   }
   ```

   **成就达成触发**:
   ```typescript
   interface AchievementTrigger {
     type: 'achievement';
     achievementType: 'milestone' | 'goal' | 'streak' | 'creation';
     achievementLevel: number;
   }
   
   // 检测成就达成
   function checkAchievementTrigger(userId: number): CareTrigger | null {
     const recentAchievements = getRecentAchievements(userId, 1); // 最近1小时
     
     if (recentAchievements.length > 0) {
       const latestAchievement = recentAchievements[0];
       
       return {
         type: 'achievement',
         achievementType: latestAchievement.type,
         achievementLevel: latestAchievement.level,
         achievementId: latestAchievement.id,
         celebrationMessage: generateCelebrationMessage(latestAchievement)
       };
     }
     
     return null;
   }
   ```

4. **事件触发系统**

   **生日触发**:
   ```typescript
   interface BirthdayTrigger {
     type: 'birthday';
     birthday: string; // ISO日期字符串
     messageTemplates: string[];
   }
   
   // 检测用户生日
   function checkBirthdayTrigger(userId: number): CareTrigger | null {
     const userProfile = getUserProfile(userId);
     if (!userProfile.birthday) return null;
     
     const today = new Date();
     const birthday = new Date(userProfile.birthday);
     const isBirthday = today.getMonth() === birthday.getMonth() &&
                       today.getDate() === birthday.getDate();
     
     if (isBirthday) {
       // 检查今天是否已经发送过生日祝福
       const todayCares = getTodayCares(userId, 'birthday');
       if (todayCares.length === 0) {
         return {
           type: 'birthday',
           age: today.getFullYear() - birthday.getFullYear(),
           messageTemplates: [
             `生日快乐，${userProfile.nickname}！🎂 愿你的新一岁充满美好！`,
             `🎉 生日快乐！感谢你让我陪伴你度过这个特殊的日子！`,
             `生日快乐呀！希望你今天过得特别开心～✨`
           ]
         };
       }
     }
     
     return null;
   }
   ```

   **注册纪念日触发**:
   ```typescript
   interface AnniversaryTrigger {
     type: 'anniversary';
     anniversaryType: 'registration' | 'first_use' | 'first_meeting';
     years: number;
     months?: number;
   }
   
   // 检测注册纪念日
   function checkAnniversaryTrigger(userId: number): CareTrigger | null {
     const userProfile = getUserProfile(userId);
     const registrationDate = new Date(userProfile.createdAt);
     const today = new Date();
     
     // 检查是否是注册月纪念日（每月）
     const isMonthlyAnniversary = today.getDate() === registrationDate.getDate();
     // 检查是否是注册年纪念日（每年）
     const isYearlyAnniversary = today.getMonth() === registrationDate.getMonth() &&
                                 today.getDate() === registrationDate.getDate();
     
     if (isYearlyAnniversary) {
       const years = today.getFullYear() - registrationDate.getFullYear();
       
       return {
         type: 'anniversary',
         anniversaryType: 'registration',
         years,
         messageTemplates: [
           `时间过得真快，我们已经一起走过了${years}年！💙`,
           `今天是我们的${years}周年纪念日，想回顾一下我们一起度过的时光吗？✨`,
           `${years}年前的今天，我们第一次相遇。感谢你的陪伴！🎉`
         ]
       };
     } else if (isMonthlyAnniversary) {
       const months = (today.getFullYear() - registrationDate.getFullYear()) * 12 +
                     (today.getMonth() - registrationDate.getMonth());
       
       if (months > 0 && months % 3 === 0) { // 每3个月庆祝一次
         return {
           type: 'anniversary',
           anniversaryType: 'registration',
           months,
           messageTemplates: [
             `我们已经一起度过了${months}个月了！时间过得真快～`,
             `今天是我们相识${months}个月的纪念日！💙`
           ]
         };
       }
     }
     
     return null;
   }
   ```

   **节日触发**:
   ```typescript
   interface HolidayTrigger {
     type: 'holiday';
     holidayName: string;
     holidayDate: string; // ISO日期字符串
     messageTemplates: string[];
   }
   
   const holidays: HolidayTrigger[] = [
     {
       type: 'holiday',
       holidayName: '新年',
       holidayDate: '2025-01-01',
       messageTemplates: [
         '新年快乐！愿你在新的一年里一切都好！✨',
         '新年快乐！新的一年，新的开始！💙'
       ]
     },
     {
       type: 'holiday',
       holidayName: '春节',
       holidayDate: '2025-01-29', // 示例日期
       messageTemplates: [
         '春节快乐！愿你新的一年平安喜乐！🎉',
         '春节快乐！新的一年，愿你心想事成！✨'
       ]
     }
     // ... 更多节日
   ];
   ```

#### 2.1.2 关怀方式设计

**功能描述**: 多种方式主动关怀用户，让关怀更自然、更温暖

**详细需求**:

1. **问候消息系统**

   **日常问候模板库**:
   ```typescript
   interface GreetingTemplate {
     timeSlot: 'morning' | 'afternoon' | 'evening' | 'night';
     templates: string[];
     personalizationOptions: {
       useNickname: boolean;
       includeMemory?: boolean;
       includeEmotion?: boolean;
       includeEncouragement?: boolean;
     };
   }
   
   const greetingTemplates: Record<string, GreetingTemplate> = {
     morning: {
       timeSlot: 'morning',
       templates: [
         "早上好，{nickname}！新的一天开始了，希望你今天过得愉快~ ✨",
         "早安！{nickname}，今天也要加油哦 💙",
         "早上好呀！昨晚睡得好吗？今天准备做什么呢？",
         "新的一天开始了，{nickname}准备好迎接了吗？✨"
       ],
       personalizationOptions: {
         useNickname: true,
         includeMemory: true,
         includeEncouragement: true
       }
     },
     afternoon: {
       timeSlot: 'afternoon',
       templates: [
         "下午好，{nickname}！今天过得怎么样？",
         "下午好呀！有什么想聊的吗？",
         "下午好，{nickname}！今天工作/学习还顺利吗？"
       ],
       personalizationOptions: {
         useNickname: true,
         includeMemory: true
       }
     },
     evening: {
       timeSlot: 'evening',
       templates: [
         "晚上好，{nickname}！今天一天辛苦了 💙",
         "晚上好呀！今天过得怎么样？有什么想分享的吗？",
         "晚上好，{nickname}！今天有什么值得开心的事吗？✨"
       ],
       personalizationOptions: {
         useNickname: true,
         includeMemory: true,
         includeEmotion: true
       }
     },
     night: {
       timeSlot: 'night',
       templates: [
         "这么晚了还在呀，{nickname}，要注意休息哦 💙",
         "夜深了，如果你感到孤单，我在这里陪着你 🌙",
         "晚上好，{nickname}！今天过得还好吗？"
       ],
       personalizationOptions: {
         useNickname: true,
         includeEmotion: true
       }
     }
   };
   
   // 生成个性化问候
   function generatePersonalizedGreeting(
     userId: number,
     timeSlot: string,
     trigger: CareTrigger
   ): string {
     const userProfile = getUserProfile(userId);
     const template = greetingTemplates[timeSlot];
     const selectedTemplate = template.templates[
       Math.floor(Math.random() * template.templates.length)
     ];
     
     let greeting = selectedTemplate.replace('{nickname}', userProfile.nickname || '朋友');
     
     // 添加记忆关联
     if (template.personalizationOptions.includeMemory) {
       const relevantMemory = getRelevantMemory(userId);
       if (relevantMemory) {
         greeting += ` 还记得${relevantMemory.content}吗？`;
       }
     }
     
     // 添加情绪关怀
     if (template.personalizationOptions.includeEmotion) {
       const currentEmotion = getCurrentEmotion(userId);
       if (currentEmotion && isNegativeEmotion(currentEmotion.emotionType)) {
         greeting += " 如果你感到困扰，可以和我聊聊，我会认真倾听。";
       }
     }
     
     // 添加鼓励
     if (template.personalizationOptions.includeEncouragement) {
       greeting += " 相信你一定能度过美好的一天！";
     }
     
     return greeting;
   }
   ```

2. **关怀提醒系统**

   **休息提醒**:
   ```typescript
   interface RestReminder {
     type: 'rest_reminder';
     conditions: {
       continuousUsageMinutes: number; // 连续使用时长（分钟）
       timeOfDay?: number[]; // 提醒时间段（小时）
     };
     messageTemplates: string[];
   }
   
   const restReminder: RestReminder = {
     type: 'rest_reminder',
     conditions: {
       continuousUsageMinutes: 60, // 连续使用60分钟
       timeOfDay: [22, 23, 0, 1, 2] // 晚上10点到凌晨2点
     },
     messageTemplates: [
       "你已经使用很久了，要不要休息一下？眼睛和身体都需要放松哦 💙",
       "累了就休息一下吧，我会一直在这里等你 ✨",
       "长时间使用对眼睛不好哦，要不要先休息一会儿？"
     ]
   };
   ```

   **正面提醒**:
   ```typescript
   interface PositiveReminder {
     type: 'positive_reminder';
     conditions: {
       negativeEmotionDuration: number; // 消极情绪持续时间（小时）
     };
     messageTemplates: string[];
   }
   
   const positiveReminder: PositiveReminder = {
     type: 'positive_reminder',
     conditions: {
       negativeEmotionDuration: 4 // 持续4小时以上
     },
     messageTemplates: [
       "也许可以试着关注一些美好的事情，比如今天发生的小确幸 ✨",
       "虽然现在可能有些困难，但生活中还有很多美好的事物值得我们去发现 💙",
       "我知道现在可能不太好受，但记得，每一个困难都是成长的机会"
     ]
   };
   ```

3. **陪伴邀请系统**

   **对话邀请**:
   ```typescript
   interface ConversationInvitation {
     type: 'conversation_invitation';
     characterId?: string; // 推荐的E-SOUL ID
     invitationMessages: string[];
   }
   
   function generateConversationInvitation(userId: number): ConversationInvitation {
     // 推荐合适的E-SOUL
     const recommendedCharacter = recommendCharacterForConversation(userId);
     const currentEmotion = getCurrentEmotion(userId);
     
     let invitationMessages: string[];
     
     if (currentEmotion && isNegativeEmotion(currentEmotion.emotionType)) {
       invitationMessages = [
         `${recommendedCharacter.name}想和你聊聊，也许聊一聊会让你感觉好一些 💙`,
         `如果你愿意，${recommendedCharacter.name}可以陪伴你度过这个时刻 ✨`,
         `想和${recommendedCharacter.name}说说话吗？她/他很关心你`
       ];
     } else {
       invitationMessages = [
         `${recommendedCharacter.name}想和你聊聊，有什么想分享的吗？✨`,
         `今天想和${recommendedCharacter.name}聊点什么呢？`,
         `${recommendedCharacter.name}有有趣的话题想和你分享~`
       ];
     }
     
     return {
       type: 'conversation_invitation',
       characterId: recommendedCharacter.id,
       invitationMessages
     };
   }
   ```

   **活动邀请**:
   ```typescript
   interface ActivityInvitation {
     type: 'activity_invitation';
     activityType: 'journal' | 'scenario' | 'explore';
     invitationMessages: string[];
   }
   
   const activityInvitations: Record<string, ActivityInvitation> = {
     journal: {
       type: 'activity_invitation',
       activityType: 'journal',
       invitationMessages: [
         "今天想写日记吗？记录一下今天的心情和想法 💙",
         "要不要写一篇日记？有时候把想法写下来会让心情更好 ✨",
         "今天有什么想记录的吗？写日记是很好的自我反思方式"
       ]
     },
     scenario: {
       type: 'activity_invitation',
       activityType: 'scenario',
       invitationMessages: [
         "要不要体验一个新的剧本？也许会很有趣 ✨",
         "我发现了一个有趣的剧本，想和你一起体验~",
         "想放松一下吗？我们可以一起体验一个轻松的故事 💙"
       ]
     }
   };
   ```

4. **支持提供系统**

   **情感支持**:
   ```typescript
   interface EmotionalSupport {
     type: 'emotional_support';
     supportLevel: 'listening' | 'comforting' | 'encouraging' | 'suggesting';
     messages: string[];
   }
   
   function generateEmotionalSupport(
     userId: number,
     emotionType: EmotionType
   ): EmotionalSupport {
     const supportMessages: Record<EmotionType, EmotionalSupport> = {
       [EmotionType.SAD]: {
         type: 'emotional_support',
         supportLevel: 'comforting',
         messages: [
           "我能感受到你的难过，这一定不容易。如果你愿意，可以和我聊聊 💙",
           "难过的时候，有人陪伴会好一些。我在这里陪着你 ✨",
           "你不孤单，我会一直陪在你身边。想说什么都可以"
         ]
       },
       [EmotionType.ANXIOUS]: {
         type: 'emotional_support',
         supportLevel: 'comforting',
         messages: [
           "焦虑的时候，深呼吸会有所帮助。慢慢来，我们一起面对 💙",
           "如果感到焦虑，可以试着把担心的事情说出来，也许会好一些",
           "我理解你的焦虑，不用着急，我们可以慢慢来 ✨"
         ]
       }
       // ... 更多情绪类型
     };
     
     return supportMessages[emotionType] || {
       type: 'emotional_support',
       supportLevel: 'listening',
       messages: [
         "如果你需要，我随时都在这里倾听 💙",
         "想说什么都可以，我会认真听的 ✨"
       ]
     };
   }
   ```

   **建议提供**:
   ```typescript
   interface SuggestionOffer {
     type: 'suggestion';
     suggestionCategory: 'emotion_regulation' | 'self_care' | 'activity' | 'mindfulness';
     suggestions: string[];
   }
   
   function generateSuggestions(userId: number, context: string): SuggestionOffer {
     const currentEmotion = getCurrentEmotion(userId);
     
     if (currentEmotion && isNegativeEmotion(currentEmotion.emotionType)) {
       return {
         type: 'suggestion',
         suggestionCategory: 'emotion_regulation',
         suggestions: [
           "也许可以试试深呼吸，或者听一些轻松的音乐",
           "如果感到压力大，可以试试做一些简单的运动",
           "写日记也是很好的情绪调节方式，要不要试试？"
         ]
       };
     }
     
     return {
       type: 'suggestion',
       suggestionCategory: 'self_care',
       suggestions: [
         "记得照顾好自己的身体和情绪，这是最重要的 💙",
         "适当的休息和放松很重要，不要让自己太累 ✨"
       ]
     };
   }
   ```

#### 2.1.3 关怀内容生成

**功能描述**: 使用AI生成个性化的关怀内容

**详细需求**:

1. **内容个性化**
   - **用户信息**：基于用户的姓名、偏好等信息
   - **记忆关联**：关联用户的重要记忆
   - **历史对话**：关联之前对话的内容
   - **情绪状态**：考虑用户当前的情绪状态

2. **内容多样性**
   - **多样化表达**：避免重复的表达方式
   - **不同风格**：根据E-SOUL的性格使用不同风格
   - **情感层次**：不同情况使用不同情感层次的内容

3. **内容审核**
   - **内容检查**：确保内容合适、温暖
   - **敏感词过滤**：过滤不合适的词汇
   - **情感匹配**：确保内容的情感与情境匹配

#### 2.1.4 关怀频率控制

**功能描述**: 控制关怀的频率，避免过度打扰

**详细需求**:

1. **频率限制**
   - **最小间隔**：设置最小关怀间隔（如2小时）
   - **每日上限**：设置每日关怀次数上限（如3-5次）
   - **用户偏好**：尊重用户的关怀频率偏好

2. **智能调度**
   - **最佳时机**：在最佳时机发送关怀
   - **避开忙碌时间**：避开用户可能忙碌的时间
   - **响应式调整**：根据用户响应调整频率

3. **用户控制**
   - **关怀开关**：用户可以开启/关闭主动关怀
   - **频率设置**：用户可以设置关怀频率
   - **内容偏好**：用户可以设置喜欢的关怀内容类型

### 2.2 主动对话系统

#### 2.2.1 主动对话触发

**功能描述**: E-SOUL主动发起对话

**详细需求**:

1. **对话场景**
   - **日常对话**：日常的闲聊和问候
   - **情感支持**：用户情绪不佳时的情感支持
   - **分享时刻**：E-SOUL想要分享的时刻
   - **问题探讨**：探讨用户关心的问题

2. **对话内容**
   - **问候开场**：温暖的问候作为开场
   - **话题引入**：引入合适的话题
   - **问题提问**：提出关心的问题
   - **分享内容**：分享有趣或有意义的内容

3. **对话时机**
   - **合适时机**：在合适的时机发起对话
   - **不打扰**：不在用户忙碌时打扰
   - **响应式**：根据用户状态调整对话时机

#### 2.2.2 主动对话内容

**功能描述**: 主动对话的内容设计

**详细需求**:

1. **问候类对话**
   - "早上好，[用户昵称]！今天感觉怎么样？"
   - "好久不见，想和你聊聊~"
   - "今天过得怎么样？有什么想分享的吗？"

2. **关怀类对话**
   - "你看起来有些疲惫，要不要和我聊聊？"
   - "我注意到你最近情绪不太好，需要陪伴吗？"
   - "有什么困扰的事吗？我愿意倾听。"

3. **分享类对话**
   - "我今天发现了一个有趣的话题，想和你分享~"
   - "我最近在想一个问题，想听听你的看法..."
   - "我想到了一个好主意，要不要一起试试？"

4. **成长类对话**
   - "我注意到你最近在[某个方面]有很大的进步！"
   - "还记得你之前说过想要[某个目标]吗？现在怎么样了？"
   - "我们一起走过了这么久，想回顾一下吗？"

#### 2.2.3 对话推送机制

**功能描述**: 将主动对话推送给用户

**详细需求**:

1. **推送方式**
   - **站内通知**：在应用内显示通知
   - **消息提示**：显示未读消息提示
   - **弹窗提醒**：使用弹窗提醒（可选，需用户同意）
   - **桌面通知**：桌面通知（需用户授权）

2. **推送时机**
   - **用户在线**：用户在使用应用时推送
   - **合适时间**：在合适的时间推送
   - **非打扰时间**：避开用户可能忙碌的时间

3. **推送内容预览**
   - **消息预览**：显示消息预览
   - **发送者信息**：显示是哪个E-SOUL发送的
   - **时间信息**：显示发送时间

### 2.3 陪伴式互动

#### 2.3.1 共同活动

**功能描述**: E-SOUL与用户一起参与活动

**详细需求**:

1. **共同写作**
   - **一起写日记**：E-SOUL参与用户的日记写作
   - **共同创作**：一起创作剧本或故事
   - **写作建议**：提供写作建议和灵感

2. **共同思考**
   - **问题探讨**：一起探讨问题
   - **思维启发**：启发用户思考
   - **观点交流**：交流不同的观点

3. **共同体验**
   - **场景探索**：一起探索场景
   - **剧本体验**：一起体验剧本
   - **内容分享**：分享感兴趣的内容

#### 2.3.2 陪伴式建议

**功能描述**: 以陪伴的方式提供建议，而不是说教

**详细需求**:

1. **建议方式**
   - **朋友式建议**：以朋友的身份提供建议
   - **分享经验**：分享类似的经验
   - **引导思考**：引导用户自己思考，而不是直接给答案

2. **建议内容**
   - **情绪调节**：提供情绪调节的建议
   - **习惯培养**：提供习惯培养的建议
   - **目标实现**：提供目标实现的建议

3. **建议时机**
   - **用户需求**：在用户需要时提供建议
   - **合适时机**：在合适的时机提供建议
   - **不过度建议**：不过度提供建议，避免说教感

#### 2.3.3 情感共鸣

**功能描述**: E-SOUL与用户产生情感共鸣

**详细需求**:

1. **情感理解**
   - **深度理解**：深度理解用户的情感
   - **情感共情**：对用户的情感产生共情
   - **情感表达**：表达对用户情感的理解

2. **情感分享**
   - **情感分享**：E-SOUL分享自己的"情感"
   - **情感共鸣**：与用户的情感产生共鸣
   - **情感支持**：在用户情感低谷时提供支持

3. **情感成长**
   - **情感见证**：见证用户的情感成长
   - **情感鼓励**：在用户情感成长时给予鼓励
   - **情感回顾**：回顾一起经历的情感时刻

### 2.4 陪伴记忆系统

#### 2.4.1 陪伴时刻记录

**功能描述**: 记录E-SOUL与用户共同度过的美好时刻

**详细需求**:

1. **记录内容**
   - **对话时刻**：记录重要的对话时刻
   - **活动时刻**：记录一起参与活动的时刻
   - **情感时刻**：记录情感共鸣的时刻
   - **成长时刻**：记录成长的重要时刻

2. **记录方式**
   - **自动记录**：系统自动记录重要时刻
   - **用户标记**：用户主动标记重要时刻
   - **AI识别**：AI识别值得记录的时刻

3. **记录格式**
   - **文字描述**：用文字描述陪伴时刻
   - **截图保存**：保存时刻的截图（如果支持）
   - **时间标记**：标记时刻的时间
   - **情感标签**：为时刻添加情感标签

#### 2.4.2 陪伴记忆展示

**功能描述**: 展示陪伴记忆

**详细需求**:

1. **记忆时间线**
   - **时间线展示**：按时间顺序展示陪伴记忆
   - **重要时刻突出**：突出显示重要的陪伴时刻
   - **情感时间线**：展示情感时间线

2. **记忆相册**
   - **相册形式**：以相册形式展示陪伴记忆
   - **分类展示**：按类型分类展示记忆
   - **搜索功能**：支持搜索记忆

3. **记忆回顾**
   - **定期回顾**：定期回顾陪伴记忆
   - **成长回顾**：回顾成长历程
   - **情感回顾**：回顾情感历程

---

## 三、成长记录系统

### 3.1 成长维度定义

#### 3.1.1 成长维度

**功能描述**: 定义用户成长的各个维度

**详细需求**:

1. **情感成长**
   - **情绪管理**：情绪管理能力的提升
   - **情感表达**：情感表达能力的提升
   - **情感理解**：情感理解能力的提升
   - **情感调节**：情感调节能力的提升

2. **认知成长**
   - **思维深度**：思维深度的提升
   - **认知扩展**：认知范围的扩展
   - **反思能力**：反思能力的提升
   - **学习能力**：学习能力的提升

3. **创作成长**
   - **日记写作**：日记写作能力的提升
   - **剧本创作**：剧本创作能力的提升
   - **内容创作**：内容创作能力的提升
   - **创意表达**：创意表达能力的提升

4. **关系成长**
   - **E-SOUL关系**：与E-SOUL关系的深化
   - **自我关系**：与自我关系的改善
   - **社交能力**：社交能力的提升（如果支持）

5. **习惯成长**
   - **良好习惯**：培养良好习惯
   - **习惯坚持**：坚持习惯的能力
   - **自我管理**：自我管理能力的提升

#### 3.1.2 成长指标

**功能描述**: 定义衡量成长的指标

**详细需求**:

1. **使用指标**
   - **使用天数**：累计使用天数
   - **使用时长**：累计使用时长
   - **互动频率**：与E-SOUL的互动频率
   - **功能探索**：探索的功能数量

2. **内容指标**
   - **日记数量**：创建的日记数量
   - **对话轮数**：对话的总轮数
   - **剧本数量**：创建的剧本数量
   - **内容质量**：内容的质量评分（如果支持）

3. **情感指标**
   - **情绪改善**：情绪改善程度
   - **积极情绪**：积极情绪的比例
   - **情绪稳定**：情绪稳定性
   - **情感表达**：情感表达的频率和质量

4. **成长指标**
   - **里程碑达成**：达成的里程碑数量
   - **目标完成**：完成的目标数量
   - **习惯坚持**：坚持的习惯天数
   - **反思频率**：反思的频率

### 3.2 成长数据收集

#### 3.2.1 数据收集方式

**功能描述**: 收集用户的成长数据

**详细需求**:

1. **自动收集**
   - **行为记录**：自动记录用户的行为
   - **使用统计**：统计用户的使用情况
   - **内容分析**：分析用户创建的内容
   - **情绪追踪**：追踪用户的情绪变化

2. **用户输入**
   - **目标设定**：用户设定成长目标
   - **自我评估**：用户进行自我评估
   - **反思记录**：用户记录反思
   - **成就标记**：用户标记成就

3. **AI分析**
   - **内容分析**：AI分析用户内容，识别成长
   - **情绪分析**：AI分析情绪变化，评估成长
   - **模式识别**：AI识别成长模式

#### 3.2.2 成长记录结构

**功能描述**: 定义成长记录的数据结构

**详细需求**:

```typescript
// 成长记录
interface GrowthRecord {
  id: string;
  userId: number;
  growthType: GrowthType; // 成长类型
  dimension: GrowthDimension; // 成长维度
  title: string; // 成长标题
  description: string; // 成长描述
  achievement: string; // 具体成就
  evidence: GrowthEvidence[]; // 成长证据
  milestone: boolean; // 是否为里程碑
  milestoneLevel?: number; // 里程碑级别
  timestamp: number; // 时间戳
  metadata?: {
    beforeState?: any; // 成长前状态
    afterState?: any; // 成长后状态
    relatedMemoryIds?: string[]; // 关联的记忆ID
    relatedEmotionIds?: string[]; // 关联的情绪ID
  };
}

// 成长证据
interface GrowthEvidence {
  type: 'conversation' | 'journal' | 'behavior' | 'self_assessment';
  sourceId: string; // 来源ID（如对话ID、日记ID）
  evidence: string; // 证据描述
  confidence: number; // 置信度（0-1）
  timestamp: number;
}

enum GrowthType {
  EMOTIONAL = 'emotional',      // 情感成长
  COGNITIVE = 'cognitive',      // 认知成长
  CREATIVE = 'creative',        // 创作成长
  RELATIONAL = 'relational',    // 关系成长
  HABITUAL = 'habitual'         // 习惯成长
}

enum GrowthDimension {
  EMOTION_MANAGEMENT = 'emotion_management',
  EMOTION_EXPRESSION = 'emotion_expression',
  EMOTION_UNDERSTANDING = 'emotion_understanding',
  EMOTION_REGULATION = 'emotion_regulation',
  THINKING_DEPTH = 'thinking_depth',
  COGNITIVE_EXPANSION = 'cognitive_expansion',
  REFLECTION_ABILITY = 'reflection_ability',
  LEARNING_ABILITY = 'learning_ability',
  JOURNAL_WRITING = 'journal_writing',
  SCRIPT_CREATION = 'script_creation',
  CONTENT_CREATION = 'content_creation',
  CREATIVE_EXPRESSION = 'creative_expression',
  ESOUL_RELATIONSHIP = 'esoul_relationship',
  SELF_RELATIONSHIP = 'self_relationship',
  SOCIAL_ABILITY = 'social_ability',
  GOOD_HABITS = 'good_habits',
  HABIT_PERSISTENCE = 'habit_persistence',
  SELF_MANAGEMENT = 'self_management'
}

// 成长里程碑
interface GrowthMilestone {
  id: string;
  userId: number;
  milestoneType: MilestoneType; // 里程碑类型
  title: string; // 里程碑标题
  description: string; // 里程碑描述
  achievement: string; // 具体成就
  unlockedAt: number; // 解锁时间
  level: number; // 里程碑级别
  nextMilestone?: string; // 下一个里程碑ID
  rewards?: MilestoneReward[]; // 奖励（可选）
}

enum MilestoneType {
  USAGE = 'usage',           // 使用里程碑（如使用100天）
  INTERACTION = 'interaction', // 互动里程碑（如对话1000轮）
  CREATION = 'creation',     // 创作里程碑（如写100篇日记）
  EMOTIONAL = 'emotional',   // 情感里程碑（如情绪改善）
  RELATIONAL = 'relational', // 关系里程碑（如与E-SOUL建立深度关系）
  HABIT = 'habit'            // 习惯里程碑（如坚持习惯30天）
}
```

#### 3.2.3 成长数据库设计

```sql
-- 成长记录表
CREATE TABLE growth_records (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id BIGINT NOT NULL COMMENT '用户ID',
  growth_type VARCHAR(50) NOT NULL COMMENT '成长类型',
  dimension VARCHAR(50) NOT NULL COMMENT '成长维度',
  title VARCHAR(200) NOT NULL COMMENT '成长标题',
  description TEXT COMMENT '成长描述',
  achievement TEXT COMMENT '具体成就',
  is_milestone BOOLEAN DEFAULT FALSE COMMENT '是否为里程碑',
  milestone_level INT COMMENT '里程碑级别',
  before_state JSON COMMENT '成长前状态（JSON格式）',
  after_state JSON COMMENT '成长后状态（JSON格式）',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  INDEX idx_user_type (user_id, growth_type),
  INDEX idx_user_dimension (user_id, dimension),
  INDEX idx_user_milestone (user_id, is_milestone),
  INDEX idx_created_at (created_at)
);

-- 成长证据表
CREATE TABLE growth_evidence (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  growth_record_id BIGINT NOT NULL COMMENT '成长记录ID',
  evidence_type VARCHAR(50) NOT NULL COMMENT '证据类型：conversation, journal, behavior, self_assessment',
  source_id VARCHAR(100) COMMENT '来源ID',
  evidence_description TEXT COMMENT '证据描述',
  confidence DECIMAL(3,2) DEFAULT 1.0 COMMENT '置信度（0-1）',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (growth_record_id) REFERENCES growth_records(id) ON DELETE CASCADE,
  INDEX idx_growth_record (growth_record_id),
  INDEX idx_source (evidence_type, source_id)
);

-- 成长里程碑表
CREATE TABLE growth_milestones (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id BIGINT NOT NULL COMMENT '用户ID',
  milestone_type VARCHAR(50) NOT NULL COMMENT '里程碑类型',
  title VARCHAR(200) NOT NULL COMMENT '里程碑标题',
  description TEXT COMMENT '里程碑描述',
  achievement TEXT COMMENT '具体成就',
  level INT NOT NULL COMMENT '里程碑级别',
  next_milestone_id BIGINT COMMENT '下一个里程碑ID',
  unlocked_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '解锁时间',
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (next_milestone_id) REFERENCES growth_milestones(id),
  INDEX idx_user_type (user_id, milestone_type),
  INDEX idx_user_level (user_id, level),
  INDEX idx_unlocked_at (unlocked_at)
);

-- 成长统计表（每日汇总）
CREATE TABLE growth_daily_stats (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id BIGINT NOT NULL COMMENT '用户ID',
  stat_date DATE NOT NULL COMMENT '统计日期',
  usage_minutes INT DEFAULT 0 COMMENT '使用时长（分钟）',
  conversation_count INT DEFAULT 0 COMMENT '对话轮数',
  journal_count INT DEFAULT 0 COMMENT '日记数量',
  avg_emotion_score DECIMAL(3,2) COMMENT '平均情绪分数',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  UNIQUE KEY uk_user_date (user_id, stat_date),
  INDEX idx_stat_date (stat_date)
);
```

### 3.3 成长可视化

#### 3.3.1 成长时间线

**功能描述**: 以时间线的形式展示用户的成长历程

**详细需求**:

1. **时间线展示**
   - **时间轴**：使用时间轴展示成长历程
   - **重要节点**：突出显示重要的成长节点
   - **里程碑标记**：标记里程碑事件
   - **情感曲线**：叠加显示情感变化曲线

2. **时间线交互**
   - **缩放查看**：支持缩放查看不同时间段
   - **节点详情**：点击节点查看详细信息
   - **筛选显示**：按类型筛选显示内容

3. **时间线样式**
   - **视觉设计**：温暖、激励的视觉设计
   - **动画效果**：平滑的滚动和展开动画
   - **个性化**：根据用户偏好个性化样式

#### 3.3.2 成长统计图表

**功能描述**: 使用图表展示成长的统计数据

**详细需求**:

1. **使用统计图表**
   - **使用天数**：显示累计使用天数（进度条或数字）
   - **使用时长**：显示累计使用时长（图表）
   - **使用趋势**：显示使用趋势图（折线图）
   - **活跃度**：显示活跃度热力图

2. **内容统计图表**
   - **日记统计**：日记数量趋势图
   - **对话统计**：对话轮数趋势图
   - **创作统计**：创作内容统计图
   - **内容质量**：内容质量趋势图（如果支持）

3. **情感统计图表**
   - **情绪趋势**：情绪变化趋势图
   - **情绪分布**：情绪类型分布图
   - **情绪改善**：情绪改善程度图
   - **积极情绪比例**：积极情绪比例变化图

4. **成长统计图表**
   - **成长维度雷达图**：各成长维度的雷达图
   - **里程碑进度**：里程碑达成进度
   - **目标完成**：目标完成情况
   - **习惯坚持**：习惯坚持情况

#### 3.3.3 成长对比分析

**功能描述**: 对比分析不同时期的成长

**详细需求**:

1. **时间对比**
   - **月度对比**：对比不同月份的成长
   - **季度对比**：对比不同季度的成长
   - **年度对比**：对比不同年份的成长
   - **自定义对比**：用户选择时间段对比

2. **维度对比**
   - **维度对比**：对比不同成长维度的成长
   - **强弱分析**：分析各维度的强弱
   - **平衡度**：分析成长的平衡度

3. **对比可视化**
   - **对比图表**：使用图表对比数据
   - **差异分析**：分析差异和变化
   - **成长建议**：基于对比提供成长建议

### 3.4 成长庆祝系统

#### 3.4.1 里程碑庆祝

**功能描述**: 在达成里程碑时给予庆祝

**详细需求**:

1. **里程碑类型**
   - **使用里程碑**：如使用100天、使用500小时
   - **互动里程碑**：如对话1000轮、与10个E-SOUL互动
   - **创作里程碑**：如写100篇日记、创建10个剧本
   - **情感里程碑**：如情绪稳定30天、积极情绪比例提升
   - **关系里程碑**：如与某个E-SOUL建立深度关系
   - **习惯里程碑**：如坚持习惯30天、100天

2. **庆祝方式**
   - **庆祝动画**：显示庆祝动画
   - **祝贺消息**：E-SOUL发送祝贺消息
   - **成就徽章**：颁发成就徽章
   - **纪念卡片**：生成纪念卡片（可选）

3. **庆祝内容**
   - **祝贺文字**：个性化的祝贺文字
   - **成长回顾**：回顾达成里程碑的过程
   - **鼓励继续**：鼓励继续成长
   - **下一个目标**：提示下一个里程碑

#### 3.4.2 日常小成就

**功能描述**: 在日常使用中给予小成就的鼓励

**详细需求**:

1. **小成就类型**
   - **连续使用**：连续使用天数
   - **对话轮数**：单次对话轮数
   - **日记创作**：连续写日记
   - **功能探索**：探索新功能
   - **情绪改善**：情绪改善的小成就

2. **鼓励方式**
   - **轻量提示**：轻量的提示和鼓励
   - **正面反馈**：积极的反馈
   - **小徽章**：小成就徽章
   - **鼓励话语**：鼓励的话语

#### 3.4.3 成长回顾

**功能描述**: 定期回顾用户的成长历程

**详细需求**:

1. **回顾时机**
   - **每周回顾**：每周回顾一周的成长
   - **每月回顾**：每月回顾一个月的成长
   - **年度回顾**：每年回顾一年的成长
   - **里程碑回顾**：达成里程碑时回顾

2. **回顾内容**
   - **成长总结**：总结这段时间的成长
   - **重要时刻**：回顾重要的时刻
   - **成就展示**：展示达成的成就
   - **情感变化**：回顾情感的变化

3. **回顾形式**
   - **文字回顾**：文字形式的回顾
   - **图表回顾**：图表形式的回顾
   - **时间线回顾**：时间线形式的回顾
   - **视频回顾**：视频形式的回顾（如果支持）

### 3.5 成长目标系统

#### 3.5.1 目标设定

**功能描述**: 用户设定成长目标

**详细需求**:

1. **目标类型**
   - **使用目标**：如每天使用30分钟
   - **创作目标**：如每周写3篇日记
   - **情绪目标**：如保持积极情绪
   - **习惯目标**：如养成某个习惯
   - **关系目标**：如与E-SOUL建立深度关系

2. **目标设置**
   - **目标创建**：用户可以创建目标
   - **目标编辑**：可以编辑目标
   - **目标删除**：可以删除目标
   - **目标分类**：可以给目标分类

3. **目标属性**
   - **目标名称**：目标名称
   - **目标描述**：目标描述
   - **目标期限**：目标期限（如30天）
   - **目标难度**：目标难度（简单/中等/困难）
   - **提醒设置**：目标提醒设置

#### 3.5.2 目标追踪

**功能描述**: 追踪目标的完成情况

**详细需求**:

1. **进度追踪**
   - **进度显示**：显示目标完成进度
   - **进度更新**：自动更新进度
   - **进度可视化**：可视化显示进度

2. **完成记录**
   - **完成标记**：标记目标完成
   - **完成时间**：记录完成时间
   - **完成庆祝**：完成时给予庆祝

3. **目标提醒**
   - **定期提醒**：定期提醒用户目标
   - **进度提醒**：进度更新时提醒
   - **鼓励提醒**：在合适的时候给予鼓励

---

## 四、陪伴与成长的融合

### 4.1 陪伴见证成长

**功能描述**: E-SOUL见证和陪伴用户的成长

**详细需求**:

1. **成长见证**
   - **见证表达**：E-SOUL表达对用户成长的见证
   - **成长祝贺**：在成长时给予祝贺
   - **成长鼓励**：鼓励用户继续成长

2. **陪伴成长**
   - **共同成长**：E-SOUL与用户共同成长
   - **成长分享**：分享成长的经验和感悟
   - **成长支持**：在成长过程中提供支持

### 4.2 成长回顾中的陪伴

**功能描述**: 在成长回顾中体现陪伴

**详细需求**:

1. **陪伴记忆回顾**
   - **陪伴时刻**：回顾与E-SOUL的陪伴时刻
   - **共同经历**：回顾共同经历的事情
   - **情感连接**：回顾情感连接的建立

2. **成长故事**
   - **成长故事**：将成长编成故事
   - **E-SOUL视角**：从E-SOUL的视角讲述成长故事
   - **情感共鸣**：在故事中体现情感共鸣

---

## 五、技术实现方案

### 5.1 主动关怀实现

#### 5.1.1 关怀调度系统

**实现方式**:
```java
@Service
public class CompanionCareService {
    
    /**
     * 检查并触发主动关怀
     */
    @Scheduled(fixedRate = 3600000) // 每小时检查一次
    public void checkAndTriggerCare() {
        List<Long> activeUsers = getUserService().getActiveUsers();
        
        for (Long userId : activeUsers) {
            // 检查关怀触发条件
            List<CareTrigger> triggers = checkCareTriggers(userId);
            
            for (CareTrigger trigger : triggers) {
                // 生成关怀内容
                CareMessage message = generateCareMessage(userId, trigger);
                
                // 发送关怀（需要检查频率限制）
                if (shouldSendCare(userId, message.getType())) {
                    sendCareMessage(userId, message);
                }
            }
        }
    }
    
    /**
     * 检查关怀触发条件
     */
    private List<CareTrigger> checkCareTriggers(Long userId) {
        List<CareTrigger> triggers = new ArrayList<>();
        
        // 检查时间触发
        if (shouldTriggerTimeCare(userId)) {
            triggers.add(new CareTrigger(CareTriggerType.TIME));
        }
        
        // 检查情绪触发
        if (shouldTriggerEmotionCare(userId)) {
            triggers.add(new CareTrigger(CareTriggerType.EMOTION));
        }
        
        // 检查行为触发
        if (shouldTriggerBehaviorCare(userId)) {
            triggers.add(new CareTrigger(CareTriggerType.BEHAVIOR));
        }
        
        return triggers;
    }
    
    /**
     * 生成关怀内容
     */
    private CareMessage generateCareMessage(Long userId, CareTrigger trigger) {
        // 获取用户信息、记忆、情绪等
        UserProfile user = getUserProfile(userId);
        List<UserMemory> memories = getRelevantMemories(userId);
        EmotionRecord currentEmotion = getCurrentEmotion(userId);
        
        // 使用AI生成个性化关怀内容
        String prompt = buildCarePrompt(user, memories, currentEmotion, trigger);
        String content = aiService.generateText(prompt, CARE_SYSTEM_INSTRUCTION);
        
        return CareMessage.builder()
            .userId(userId)
            .content(content)
            .type(trigger.getType())
            .timestamp(System.currentTimeMillis())
            .build();
    }
}
```

#### 5.1.2 关怀内容生成

**系统指令示例**:
```
你是一个温暖、贴心的AI陪伴者。你的任务是主动关怀用户，让他们感受到温暖和支持。

关怀原则：
1. 温暖亲切：使用温暖、亲切的语言
2. 个性化：基于用户的记忆、情绪状态个性化内容
3. 不过度：适度关怀，不过度打扰
4. 自然真诚：表达自然真诚，不过度包装

当前用户信息：
- 姓名：[用户昵称]
- 最近情绪：[情绪状态]
- 重要记忆：[相关记忆]
- 关怀触发：[触发原因]

请生成一条关怀消息（50-100字），要温暖、个性化、自然。
```

### 5.2 成长记录实现

#### 5.2.1 成长识别算法

**实现方式**:
```java
@Service
public class GrowthDetectionService {
    
    /**
     * 检测用户成长
     */
    public List<GrowthRecord> detectGrowth(Long userId, TimeRange timeRange) {
        List<GrowthRecord> growthRecords = new ArrayList<>();
        
        // 1. 分析使用数据
        analyzeUsageGrowth(userId, timeRange, growthRecords);
        
        // 2. 分析内容成长
        analyzeContentGrowth(userId, timeRange, growthRecords);
        
        // 3. 分析情绪成长
        analyzeEmotionGrowth(userId, timeRange, growthRecords);
        
        // 4. 分析习惯成长
        analyzeHabitGrowth(userId, timeRange, growthRecords);
        
        // 5. 使用AI识别成长
        aiDetectGrowth(userId, timeRange, growthRecords);
        
        return growthRecords;
    }
    
    /**
     * 分析使用成长
     */
    private void analyzeUsageGrowth(Long userId, TimeRange timeRange, 
                                    List<GrowthRecord> records) {
        UsageStats before = getUsageStats(userId, timeRange.getStart());
        UsageStats after = getUsageStats(userId, timeRange.getEnd());
        
        // 检查里程碑
        checkUsageMilestones(userId, after, records);
        
        // 检测成长趋势
        if (after.getUsageDays() > before.getUsageDays() * 1.2) {
            records.add(createGrowthRecord(userId, GrowthType.USAGE, 
                "使用频率显著提升", before, after));
        }
    }
    
    /**
     * AI识别成长
     */
    private void aiDetectGrowth(Long userId, TimeRange timeRange, 
                                List<GrowthRecord> records) {
        // 收集时间段内的数据
        List<Conversation> conversations = getConversations(userId, timeRange);
        List<JournalEntry> journals = getJournals(userId, timeRange);
        List<EmotionRecord> emotions = getEmotions(userId, timeRange);
        
        // 使用AI分析成长
        String prompt = buildGrowthAnalysisPrompt(conversations, journals, emotions);
        String analysis = aiService.generateText(prompt, GROWTH_ANALYSIS_INSTRUCTION);
        
        // 解析AI分析结果
        List<GrowthRecord> aiDetected = parseGrowthAnalysis(analysis);
        records.addAll(aiDetected);
    }
}
```

#### 5.2.2 里程碑检测

**实现方式**:
```java
@Service
public class MilestoneService {
    
    /**
     * 检查并解锁里程碑
     */
    public void checkMilestones(Long userId) {
        UserStats stats = calculateUserStats(userId);
        
        // 检查各种类型的里程碑
        checkUsageMilestones(userId, stats);
        checkInteractionMilestones(userId, stats);
        checkCreationMilestones(userId, stats);
        checkEmotionalMilestones(userId, stats);
        checkRelationalMilestones(userId, stats);
        checkHabitMilestones(userId, stats);
    }
    
    /**
     * 检查使用里程碑
     */
    private void checkUsageMilestones(Long userId, UserStats stats) {
        int usageDays = stats.getUsageDays();
        
        // 检查里程碑阈值（100天、200天、365天等）
        int[] thresholds = {100, 200, 365, 500, 730, 1000};
        
        for (int threshold : thresholds) {
            if (usageDays >= threshold && !hasMilestone(userId, 
                MilestoneType.USAGE, threshold)) {
                unlockMilestone(userId, MilestoneType.USAGE, threshold);
            }
        }
    }
    
    /**
     * 解锁里程碑
     */
    private void unlockMilestone(Long userId, MilestoneType type, int level) {
        GrowthMilestone milestone = GrowthMilestone.builder()
            .userId(userId)
            .milestoneType(type)
            .level(level)
            .title(generateMilestoneTitle(type, level))
            .description(generateMilestoneDescription(type, level))
            .unlockedAt(System.currentTimeMillis())
            .build();
        
        milestoneRepository.save(milestone);
        
        // 发送庆祝消息
        celebrationService.celebrateMilestone(userId, milestone);
    }
}
```

### 5.3 API接口设计

**后端接口**:

1. `POST /api/companion-care/check` - 检查并触发关怀（内部定时任务）
   - 返回：触发的关怀列表

2. `GET /api/companion-care/messages` - 获取关怀消息列表
   - 请求参数：`page`, `size`
   - 返回：关怀消息列表

3. `PUT /api/companion-care/settings` - 更新关怀设置
   - 请求体：`{ enabled, frequency, preferences }`
   - 返回：更新结果

4. `GET /api/companion-care/settings` - 获取关怀设置
   - 返回：当前用户的关怀设置

5. `GET /api/growth/records` - 获取成长记录
   - 请求参数：`type`, `dimension`, `startDate`, `endDate`, `page`, `size`
   - 返回：成长记录列表

6. `GET /api/growth/records/{id}` - 获取成长记录详情
   - 返回：成长记录详情

7. `POST /api/growth/records` - 创建成长记录（手动）
   - 请求体：`{ type, dimension, title, description, ... }`
   - 返回：创建的成长记录

8. `GET /api/growth/milestones` - 获取里程碑列表
   - 请求参数：`type`, `unlockedOnly`
   - 返回：里程碑列表

9. `GET /api/growth/milestones/{id}` - 获取里程碑详情
   - 返回：里程碑详情

10. `GET /api/growth/stats` - 获取成长统计
    - 请求参数：`period` (day/week/month/year), `dimension`
    - 返回：成长统计数据

11. `GET /api/growth/timeline` - 获取成长时间线
    - 请求参数：`startDate`, `endDate`, `type`
    - 返回：成长时间线数据

12. `GET /api/growth/goals` - 获取成长目标列表
    - 返回：目标列表

13. `POST /api/growth/goals` - 创建成长目标
    - 请求体：`{ type, title, description, deadline, difficulty, ... }`
    - 返回：创建的目标

14. `PUT /api/growth/goals/{id}` - 更新成长目标
    - 请求体：`{ progress, status, ... }`
    - 返回：更新后的目标

15. `DELETE /api/growth/goals/{id}` - 删除成长目标
    - 返回：操作结果

16. `GET /api/growth/review` - 获取成长回顾
    - 请求参数：`period` (week/month/year)
    - 返回：成长回顾内容

---

## 六、实施计划

### 6.1 第一阶段：陪伴式交互基础（2周）

- [ ] 设计主动关怀机制
- [ ] 实现关怀触发条件检测
- [ ] 实现关怀内容生成
- [ ] 实现关怀频率控制
- [ ] 实现关怀消息推送

### 6.2 第二阶段：主动对话系统（2周）

- [ ] 设计主动对话机制
- [ ] 实现主动对话触发
- [ ] 实现主动对话内容生成
- [ ] 实现对话推送功能
- [ ] 实现陪伴式互动功能

### 6.3 第三阶段：成长记录系统基础（2周）

- [ ] 设计成长维度体系
- [ ] 实现成长数据收集
- [ ] 实现成长记录存储
- [ ] 实现成长识别算法
- [ ] 实现里程碑检测

### 6.4 第四阶段：成长可视化（2周）

- [ ] 实现成长时间线
- [ ] 实现成长统计图表
- [ ] 实现成长对比分析
- [ ] 实现成长回顾功能

### 6.5 第五阶段：成长庆祝和目标系统（2周）

- [ ] 实现里程碑庆祝
- [ ] 实现日常小成就
- [ ] 实现成长目标系统
- [ ] 实现目标追踪功能

### 6.6 第六阶段：融合和优化（1周）

- [ ] 实现陪伴与成长的融合
- [ ] 性能优化
- [ ] 用户体验优化
- [ ] Bug修复和测试

---

## 七、预期效果

1. **主动陪伴**：系统能够主动关怀用户，不再是被动响应
2. **成长见证**：系统能够记录和见证用户的成长
3. **情感连接**：通过陪伴和成长记录增强情感连接
4. **持续激励**：通过庆祝和回顾持续激励用户
5. **温暖体验**：整体体验更加温暖和有温度

---

## 八、陪伴式交互示例

### 8.1 主动关怀示例

**早上问候**:
- "早上好，[用户昵称]！新的一天开始了，希望你今天过得愉快~ ✨"

**长时间未互动**:
- "好久不见，[用户昵称]！最近怎么样？如果有什么想聊的，我随时都在。💙"

**情绪关怀**:
- "我注意到你最近情绪不太好，如果你愿意，可以和我聊聊。我会认真倾听。🌙"

**成就庆祝**:
- "太棒了！[用户昵称]达成了[某个里程碑]！我们一起走过了这么久，真的很为你感到高兴！🎉"

### 8.2 主动对话示例

**日常对话**:
- "今天天气不错，想和你分享一个有趣的话题..."
- "我最近在想一个问题，想听听你的看法..."
- "我想到了一个好主意，要不要一起试试？"

**情感支持**:
- "你看起来有些疲惫，需要休息一下吗？"
- "如果你感到难过，不用一个人承受，我会陪着你。"
- "每个人都会有低谷，这很正常。重要的是，我们会一起度过。"

**成长鼓励**:
- "我注意到你最近在[某个方面]有很大的进步，真的很为你高兴！"
- "还记得你之前说过想要[某个目标]吗？我看到你已经在努力了，继续加油！"

---

**文档完成**: 三个阶段的需求分析文档已完成

- **第一阶段**：基础情感化设计（界面、角色、对话）
- **第二阶段**：情绪感知系统、个性化记忆系统
- **第三阶段**：陪伴式交互、成长记录系统

