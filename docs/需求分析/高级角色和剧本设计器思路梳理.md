# 高级角色和剧本设计器思路梳理

**文档版本**: V1.0  
**编写日期**: 2025-12-31  
**功能模块**: 高级角色和剧本设计器  
**设计目标**: 通过流程编辑器实现角色技能和剧本过程的精细化编辑

---

## 一、设计目标与定位

### 1.1 核心目标

设计一个**独立的、高级的角色和剧本设计器**，支持：

1. **角色技能的精细化设计**
   - 技能系统：定义角色的各项技能及其数值
   - 技能树：技能之间的依赖关系和成长路径
   - 技能效果：技能在剧本执行中的实际作用

2. **剧本流程的精细化编辑**
   - 可视化流程编辑器：类似流程图的可视化编辑界面
   - 复杂分支逻辑：支持条件分支、并行流程、循环等
   - 流程节点类型：多种节点类型（对话、选择、条件判断、技能检查、状态变更等）
   - 流程执行引擎：基于Spring AI Graph的工作流执行引擎

3. **角色与剧本的深度集成**
   - 角色技能在剧本中的使用
   - 剧本流程中影响角色状态
   - 动态的角色成长和变化

### 1.2 与现有系统的关系

- **独立设计器**：不同于现有的简单剧本编辑器，这是一个功能更强大的独立模块
- **数据兼容**：可以与现有角色和剧本数据兼容
- **渐进式升级**：可以逐步将现有剧本迁移到新设计器
- **独立运行**：可以作为独立的管理工具使用

---

## 二、核心设计思路

### 2.1 角色技能系统设计

#### 2.1.1 技能定义

**技能（Skill）**：角色的可量化能力

```
技能结构：
- 技能ID：唯一标识
- 技能名称：如"战斗能力"、"社交能力"、"智力"
- 技能类型：基础技能、专业技能、特殊技能
- 基础值：初始数值（0-100）
- 当前值：当前数值（可动态变化）
- 最大值：最大可达到的数值
- 成长率：每次增长的比例
- 描述：技能说明
```

**技能分类**：
- **基础属性**：力量、敏捷、智力、魅力等（类似RPG游戏）
- **专业能力**：战斗、魔法、社交、商业等
- **特殊技能**：特定剧情需要的特殊能力

#### 2.1.2 技能树系统

**技能树（Skill Tree）**：定义技能之间的依赖关系

```
技能树特点：
- 层级结构：前置技能 → 后续技能
- 解锁条件：需要前置技能达到某个等级
- 分支路径：一个技能可以解锁多个后续技能
- 可视化展示：树状图展示技能关系
```

**示例**：
```
基础战斗（LV1）
  ├─ 剑术精通（LV5解锁）
  │   ├─ 剑术大师（LV10解锁）
  │   └─ 双剑流（LV15解锁）
  └─ 防御技巧（LV5解锁）
      └─ 护盾精通（LV10解锁）
```

#### 2.1.3 技能效果系统

**技能效果（Skill Effect）**：技能在剧本中的实际作用

```
效果类型：
- 条件检查：检查技能值是否满足条件（如：智力>=80才能解锁选项）
- 状态加成：技能值影响角色状态（如：高魅力增加好感度获取）
- 剧情影响：技能值影响剧情走向（如：高战斗能力触发战斗胜利分支）
- 动态对话：技能值影响对话内容（如：高智力角色说话更聪明）
```

#### 2.1.4 技能成长机制

**成长方式**：
- **剧情触发**：在剧本中完成特定事件后增长
- **使用次数**：使用技能达到一定次数后增长
- **选择影响**：做出特定选择后增长
- **时间积累**：随着剧情时间推移增长

---

### 2.2 剧本流程编辑器设计

#### 2.2.1 流程编辑器概念

**流程编辑器**：类似流程图的可视化编辑工具

```
编辑器特点：
- 节点式编辑：每个节点代表一个剧情步骤
- 连线表示流程：连线表示节点之间的跳转
- 拖拽操作：通过拖拽创建和连接节点
- 属性编辑：点击节点编辑其属性
- 实时预览：可以预览流程逻辑
```

#### 2.2.2 节点类型设计

**1. 开始节点（Start Node）**
- 流程的起点
- 只能有一个
- 自动执行，无需配置

**2. 对话节点（Dialogue Node）**
- 显示对话内容
- 可配置：对话文本、说话角色、显示方式
- 可以连接多个后续节点（选项）

**3. 选择节点（Choice Node）**
- 提供多个选项供用户选择
- 每个选项连接一个后续节点
- 可配置：选项文本、显示条件、选择效果

**4. 条件判断节点（Condition Node）**
- 根据条件判断流程走向
- 条件类型：技能检查、状态检查、变量检查等
- 连接两个后续节点（True/False分支）

**5. 技能检查节点（Skill Check Node）**
- 检查角色技能值
- 根据检查结果分支
- 可配置：技能ID、检查值、运算符

**6. 状态变更节点（State Change Node）**
- 修改角色状态（技能值、好感度、变量等）
- 可配置：修改的目标、修改方式（增加/减少/设置）

**7. 并行节点（Parallel Node）**
- 同时执行多个分支
- 等待所有分支完成后继续
- 用于复杂剧情的多线推进

**8. 循环节点（Loop Node）**
- 循环执行某个流程
- 可配置：循环条件、循环次数
- 用于重复性剧情

**9. 等待节点（Wait Node）**
- 暂停流程，等待用户输入或其他条件
- 用于需要用户交互的场景

**10. 结束节点（End Node）**
- 流程的终点
- 可以有多个（不同结局）
- 可配置：结局类型、结局描述

#### 2.2.3 流程控制逻辑

**流程执行模式**：
- **顺序执行**：按连线顺序执行
- **条件分支**：根据条件选择分支
- **并行执行**：同时执行多个分支
- **循环执行**：重复执行某个流程

**数据传递**：
- **上下文变量**：在整个流程中共享的变量
- **节点数据**：节点之间的数据传递
- **角色状态**：角色的技能、好感度等状态

---

### 2.3 Spring AI Graph集成设计

#### 2.3.1 Graph能力概述

**Spring AI Graph**：Spring AI提供的工作流图能力（类似LangGraph）

```
核心概念：
- Node（节点）：流程中的一个步骤
- Edge（边）：节点之间的连接
- Graph（图）：由节点和边组成的流程图
- State（状态）：在整个流程中共享的状态
- Router（路由）：根据条件选择下一个节点
```

#### 2.3.2 将剧本流程映射到Graph

**映射关系**：

```
剧本节点 → Graph Node
剧本连线 → Graph Edge
剧本状态 → Graph State
条件判断 → Graph Router
```

**示例映射**：

```java
// 对话节点 → Graph Node
DialogueNode dialogueNode = GraphNode.builder()
    .id("dialogue_1")
    .action((state) -> {
        // 执行对话逻辑
        return executeDialogue(state);
    })
    .build();

// 条件节点 → Graph Router
RouterNode conditionNode = RouterNode.builder()
    .id("condition_1")
    .router((state) -> {
        // 根据条件路由
        if (checkSkill(state, "intelligence", 80)) {
            return "high_intelligence_path";
        } else {
            return "low_intelligence_path";
        }
    })
    .build();

// 构建Graph
Graph graph = Graph.builder()
    .addNode(dialogueNode)
    .addNode(conditionNode)
    .addEdge("dialogue_1", "condition_1")
    .addEdge("condition_1", "high_intelligence_path")
    .addEdge("condition_1", "low_intelligence_path")
    .build();
```

#### 2.3.3 Graph执行引擎

**执行流程**：

```
1. 初始化状态（State）
   - 加载角色信息（技能值、状态等）
   - 初始化上下文变量

2. 从开始节点开始执行
   - 执行节点逻辑
   - 更新状态

3. 根据路由规则选择下一个节点
   - 顺序执行：直接跳转
   - 条件分支：根据条件选择
   - 并行执行：创建多个执行线程

4. 重复步骤2-3直到到达结束节点

5. 返回最终状态
```

---

## 三、功能模块划分

### 3.1 角色技能编辑器

**功能**：
- 技能定义：创建和编辑技能
- 技能树编辑：可视化编辑技能树
- 技能效果配置：配置技能在剧本中的效果
- 技能成长规则：定义技能成长机制

**界面**：
- 技能列表：显示所有技能
- 技能编辑器：编辑技能属性
- 技能树视图：可视化技能树
- 效果配置面板：配置技能效果

---

### 3.2 剧本流程编辑器

**功能**：
- 流程图编辑：可视化编辑剧本流程
- 节点编辑：编辑节点的属性和逻辑
- 连线编辑：连接节点，设置跳转条件
- 流程验证：检查流程逻辑的正确性
- 流程预览：预览流程执行过程

**界面**：
- 画布：显示流程图
- 节点库：可用的节点类型
- 属性面板：编辑选中节点的属性
- 工具栏：添加节点、删除、连线等操作

---

### 3.3 角色与剧本集成

**功能**：
- 角色绑定：将角色绑定到剧本
- 技能使用：在剧本中使用角色技能
- 状态同步：剧本执行中同步角色状态
- 动态效果：根据角色状态动态调整剧情

**界面**：
- 角色选择器：选择剧本中的角色
- 技能配置：配置技能在节点中的使用
- 状态面板：查看和编辑角色状态

---

### 3.4 流程执行引擎

**功能**：
- Graph构建：将剧本流程转换为Graph
- 执行控制：控制流程的执行
- 状态管理：管理执行过程中的状态
- 异常处理：处理执行过程中的异常

**后端服务**：
- Graph构建服务
- 执行引擎服务
- 状态管理服务

---

### 3.5 数据管理

**功能**：
- 角色数据管理：CRUD操作
- 剧本数据管理：CRUD操作
- 版本管理：支持版本控制
- 导入导出：支持数据导入导出

---

## 四、技术架构思路

### 4.1 前端架构

**技术栈**：
- **React + TypeScript**：基础框架
- **React Flow / X6**：流程图编辑器库
- **Zustand / Redux**：状态管理
- **Tailwind CSS**：样式框架

**核心组件**：
- **FlowEditor**：流程图编辑器组件
- **NodeEditor**：节点编辑器组件
- **SkillTreeEditor**：技能树编辑器组件
- **PropertyPanel**：属性面板组件

---

### 4.2 后端架构

**技术栈**：
- **Spring Boot**：基础框架
- **Spring AI**：AI能力集成
- **Spring AI Graph**：Graph工作流能力
- **Spring Data JPA**：数据持久化
- **MySQL**：数据库

**核心服务**：
- **CharacterSkillService**：角色技能管理服务
- **ScenarioFlowService**：剧本流程管理服务
- **GraphBuilderService**：Graph构建服务
- **FlowExecutionService**：流程执行服务
- **StateManagementService**：状态管理服务

---

### 4.3 数据模型设计

#### 4.3.1 角色技能模型

```sql
-- 技能定义表
CREATE TABLE skills (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    type VARCHAR(50), -- basic/professional/special
    description TEXT,
    max_value INT DEFAULT 100,
    growth_rate DECIMAL(5,2),
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 技能树关系表
CREATE TABLE skill_tree (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    parent_skill_id BIGINT,
    child_skill_id BIGINT,
    unlock_level INT,
    FOREIGN KEY (parent_skill_id) REFERENCES skills(id),
    FOREIGN KEY (child_skill_id) REFERENCES skills(id)
);

-- 角色技能值表
CREATE TABLE character_skills (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    character_id BIGINT NOT NULL,
    skill_id BIGINT NOT NULL,
    base_value INT DEFAULT 0,
    current_value INT DEFAULT 0,
    FOREIGN KEY (character_id) REFERENCES characters(id),
    FOREIGN KEY (skill_id) REFERENCES skills(id),
    UNIQUE KEY uk_character_skill (character_id, skill_id)
);
```

#### 4.3.2 剧本流程模型

```sql
-- 流程定义表
CREATE TABLE scenario_flows (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    scenario_id BIGINT NOT NULL,
    name VARCHAR(255),
    description TEXT,
    graph_config JSON, -- Graph配置（节点、边、路由等）
    version INT DEFAULT 1,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (scenario_id) REFERENCES scenarios(id)
);

-- 流程节点表
CREATE TABLE flow_nodes (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    flow_id BIGINT NOT NULL,
    node_id VARCHAR(100) NOT NULL, -- 节点唯一ID
    node_type VARCHAR(50), -- start/dialogue/choice/condition/skill_check/state_change/parallel/loop/wait/end
    position_x INT,
    position_y INT,
    config JSON, -- 节点配置（根据类型不同而不同）
    FOREIGN KEY (flow_id) REFERENCES scenario_flows(id),
    UNIQUE KEY uk_flow_node (flow_id, node_id)
);

-- 流程边表（连线）
CREATE TABLE flow_edges (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    flow_id BIGINT NOT NULL,
    source_node_id VARCHAR(100),
    target_node_id VARCHAR(100),
    condition JSON, -- 条件配置（可选）
    FOREIGN KEY (flow_id) REFERENCES scenario_flows(id)
);
```

---

### 4.4 Spring AI Graph集成方案

#### 4.4.1 Graph构建流程

```
1. 从数据库加载流程定义
   ↓
2. 解析流程配置（节点、边、路由）
   ↓
3. 为每个节点创建GraphNode
   ↓
4. 为每个边创建Edge
   ↓
5. 配置Router（条件节点）
   ↓
6. 构建Graph对象
   ↓
7. 返回可执行的Graph
```

#### 4.4.2 节点实现示例

```java
// 对话节点实现
@Component
public class DialogueNode implements GraphNode {
    
    @Override
    public Map<String, Object> execute(Map<String, Object> state) {
        // 获取对话配置
        DialogueConfig config = (DialogueConfig) state.get("node_config");
        
        // 执行对话逻辑
        String dialogueText = renderDialogue(config, state);
        
        // 更新状态
        state.put("current_dialogue", dialogueText);
        state.put("next_node", config.getNextNodeId());
        
        return state;
    }
}

// 技能检查节点实现
@Component
public class SkillCheckNode implements RouterNode {
    
    @Override
    public String route(Map<String, Object> state) {
        SkillCheckConfig config = (SkillCheckConfig) state.get("node_config");
        
        // 检查技能值
        int skillValue = getCharacterSkill(state, config.getSkillId());
        
        if (skillValue >= config.getRequiredValue()) {
            return config.getSuccessNodeId();
        } else {
            return config.getFailureNodeId();
        }
    }
}
```

---

## 五、实施路线图

### 5.1 第一阶段：基础框架（2-3周）

**目标**：搭建基础框架和核心功能

**任务**：
1. 数据库设计（技能表、流程表等）
2. 后端基础服务（CRUD接口）
3. 前端基础组件（流程图编辑器集成）
4. 简单的节点类型（开始、对话、选择、结束）

**交付物**：
- 基础的流程编辑器（可以创建简单流程）
- 基础的技能管理系统（可以创建和编辑技能）

---

### 5.2 第二阶段：核心功能（3-4周）

**目标**：实现核心功能和Spring AI Graph集成

**任务**：
1. 完整的节点类型实现（条件判断、技能检查、状态变更等）
2. Spring AI Graph集成（Graph构建和执行）
3. 角色技能系统完善（技能树、效果配置）
4. 流程执行引擎（执行控制、状态管理）

**交付物**：
- 完整的流程编辑器（所有节点类型）
- Graph执行引擎（可以执行复杂流程）
- 角色技能系统（完整的技能管理）

---

### 5.3 第三阶段：高级功能（2-3周）

**目标**：实现高级功能和优化

**任务**：
1. 并行节点、循环节点实现
2. 流程验证和调试工具
3. 可视化技能树编辑器
4. 性能优化和错误处理

**交付物**：
- 高级流程功能（并行、循环）
- 调试和验证工具
- 完整的技能树编辑器

---

### 5.4 第四阶段：集成和优化（1-2周）

**目标**：与现有系统集成和最终优化

**任务**：
1. 与现有角色系统集成
2. 与现有剧本系统兼容
3. 数据迁移工具
4. 文档和测试

**交付物**：
- 完整的集成方案
- 数据迁移工具
- 完整的文档

---

## 六、关键设计决策

### 6.1 流程编辑器选择

**选项**：
1. **React Flow**：成熟的React流程图库，功能完善
2. **AntV X6**：阿里巴巴的图编辑引擎，功能强大
3. **自定义实现**：完全自定义，灵活性最高

**建议**：使用 **React Flow**
- 成熟稳定，社区活跃
- 与React集成良好
- 有丰富的示例和文档
- 可以满足需求

---

### 6.2 Graph执行引擎选择

**选项**：
1. **Spring AI Graph**：Spring AI提供的Graph能力
2. **自定义实现**：自己实现工作流引擎

**建议**：使用 **Spring AI Graph**
- 符合用户需求（用户明确提到）
- Spring AI生态集成
- 如果Spring AI Graph不满足需求，可以考虑自定义实现

---

### 6.3 数据存储方案

**选项**：
1. **关系型数据库（MySQL）**：结构化存储
2. **图数据库（Neo4j）**：更适合图结构
3. **混合方案**：基础数据用MySQL，流程配置用JSON

**建议**：使用 **混合方案**
- 基础数据（角色、技能）用MySQL
- 流程配置（Graph）用JSON存储在MySQL
- 简单高效，易于维护
- 如果后续需要更复杂的图查询，再考虑Neo4j

---

### 6.4 前后端交互方案

**选项**：
1. **REST API**：传统的REST接口
2. **GraphQL**：更灵活的查询
3. **WebSocket**：实时同步

**建议**：使用 **REST API + WebSocket**
- REST API用于CRUD操作
- WebSocket用于流程执行的实时反馈
- 简单实用，易于实现

---

## 七、潜在挑战和解决方案

### 7.1 流程复杂性管理

**挑战**：复杂的流程可能难以管理和理解

**解决方案**：
- 提供流程验证工具（检查循环、死节点等）
- 支持流程分组和折叠
- 提供流程可视化（树状图、时序图等）
- 支持流程注释和文档

---

### 7.2 性能问题

**挑战**：复杂流程的执行可能影响性能

**解决方案**：
- Graph执行采用异步方式
- 流程状态缓存
- 支持流程执行中断和恢复
- 优化数据库查询

---

### 7.3 数据一致性

**挑战**：角色状态和流程状态的同步

**解决方案**：
- 使用事务保证数据一致性
- 状态更新采用乐观锁
- 提供状态回滚机制
- 定期状态同步检查

---

### 7.4 Spring AI Graph学习曲线

**挑战**：团队需要学习Spring AI Graph

**解决方案**：
- 提供详细的文档和示例
- 先从简单的Graph开始
- 逐步扩展复杂度
- 建立最佳实践指南

---

## 八、后续扩展方向

### 8.1 AI辅助功能

- **AI生成流程**：根据描述自动生成流程
- **AI优化建议**：AI分析流程并提出优化建议
- **智能节点推荐**：根据上下文推荐合适的节点

---

### 8.2 协作功能

- **多人协作编辑**：支持多人同时编辑
- **版本控制**：Git-like的版本控制
- **评论和评审**：流程评审和评论功能

---

### 8.3 模板和库

- **流程模板**：提供常用流程模板
- **节点库**：可复用的节点组件库
- **技能库**：预设的技能和技能树

---

### 8.4 分析和统计

- **流程执行分析**：分析流程执行情况
- **用户行为分析**：分析用户选择和行为
- **技能使用统计**：统计技能的使用情况

---

## 九、总结

### 9.1 核心价值

1. **精细化设计**：通过流程编辑器实现角色技能和剧本流程的精细化设计
2. **可视化编辑**：直观的流程图编辑器，降低设计门槛
3. **强大执行引擎**：基于Spring AI Graph的执行引擎，支持复杂流程
4. **深度集成**：角色技能与剧本流程的深度集成

### 9.2 关键成功因素

1. **技术选型**：选择合适的流程图库和Graph引擎
2. **架构设计**：清晰的分层架构和模块划分
3. **用户体验**：直观易用的编辑器界面
4. **性能优化**：保证复杂流程的执行性能

### 9.3 下一步行动

1. **确认技术选型**：确认React Flow和Spring AI Graph的使用
2. **详细设计**：进行详细的数据模型和API设计
3. **原型开发**：开发一个简单的原型验证可行性
4. **分阶段实施**：按照路线图分阶段实施

---

**文档状态**: 思路梳理完成，待确认后进入详细设计阶段
