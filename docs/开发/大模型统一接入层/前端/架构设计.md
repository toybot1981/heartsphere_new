# AI服务模块架构设计

**文档版本**: v1.0  
**创建日期**: 2025-01-22  
**模块路径**: `frontend/services/ai/`

---

## 一、整体架构

### 1.1 模块结构

```
frontend/services/ai/
├── index.ts                 # 统一导出入口
├── types.ts                 # TypeScript类型定义
├── config.ts                # 配置管理（localStorage）
├── AIService.ts             # 统一AI服务（主服务类）
├── AdapterManager.ts        # 适配器管理器
├── base/
│   └── BaseAdapter.ts       # 基础适配器抽象类
└── adapters/
    ├── index.ts             # 适配器统一导出
    ├── GeminiAdapter.ts     # Gemini模型适配器
    ├── OpenAIAdapter.ts     # OpenAI模型适配器
    ├── QwenAdapter.ts       # 通义千问模型适配器
    └── DoubaoAdapter.ts     # 豆包模型适配器
```

### 1.2 设计模式

- **适配器模式**：每个AI提供商都有独立的适配器实现
- **策略模式**：根据配置选择使用统一接入模式或本地配置模式
- **单例模式**：AIService和AdapterManager使用单例
- **工厂模式**：AdapterManager负责创建和管理适配器实例

---

## 二、核心组件

### 2.1 类型系统（types.ts）

**职责**：
- 定义所有接口和类型
- 定义异常类
- 提供类型安全

**关键类型**：
- `AIProvider`: 提供商类型（gemini | openai | qwen | doubao）
- `AIMode`: 模式类型（unified | local）
- `TextGenerationRequest/Response`: 文本生成请求/响应
- `ImageGenerationRequest/Response`: 图片生成请求/响应
- `UserAIConfig`: 用户配置
- `ModelAdapter`: 适配器接口

### 2.2 配置管理（config.ts）

**职责**：
- 管理用户配置（localStorage）
- 管理API Keys（本地配置模式）
- 提供默认配置

**关键方法**：
- `getUserConfig()`: 获取用户配置
- `saveUserConfig()`: 保存用户配置
- `getLocalApiKeys()`: 获取本地API Keys
- `setApiKey()`: 设置指定provider的API Key

### 2.3 基础适配器（BaseAdapter.ts）

**职责**：
- 提供适配器的通用实现
- 提供工具方法（HTTP请求、流式请求等）
- 定义抽象方法供子类实现

**关键方法**：
- `makeRequest()`: 通用HTTP请求
- `makeStreamRequest()`: 流式请求（SSE）
- `validateRequest()`: 请求参数验证
- `ensureConfigured()`: 检查API Key配置

### 2.4 适配器管理器（AdapterManager.ts）

**职责**：
- 管理所有适配器实例
- 根据配置创建适配器
- 提供适配器查找和更新

**关键方法**：
- `initializeLocalAdapters()`: 初始化本地适配器
- `getAdapter()`: 获取指定provider的适配器
- `updateAdapterApiKey()`: 更新适配器API Key
- `getAvailableProviders()`: 获取可用的provider列表

### 2.5 统一AI服务（AIService.ts）

**职责**：
- 提供统一的AI服务接口
- 实现双模式切换逻辑
- 实现降级机制
- 路由请求到正确的适配器或后端API

**关键方法**：
- `generateText()`: 生成文本
- `generateTextStream()`: 流式生成文本
- `generateImage()`: 生成图片
- `textToSpeech()`: 文本转语音
- `speechToText()`: 语音转文本
- `generateVideo()`: 生成视频
- `updateUserConfig()`: 更新用户配置

---

## 三、双模式实现

### 3.1 本地配置模式

**流程**：
```
用户请求
  ↓
AIService.generateText()
  ↓
检查配置 mode === 'local'
  ↓
AdapterManager.getAdapter(provider)
  ↓
Adapter.generateText()
  ↓
直接调用AI服务API
  ↓
返回结果
```

**特点**：
- API Key存储在客户端（localStorage）
- 直接调用AI服务，不经过后端
- 用户自己承担费用
- 更好的隐私保护

### 3.2 统一接入模式（待实现）

**流程**：
```
用户请求
  ↓
AIService.generateText()
  ↓
检查配置 mode === 'unified'
  ↓
调用后端API /api/ai/text/generate
  ↓
后端处理（认证、计费、限流等）
  ↓
后端调用AI服务
  ↓
返回结果
```

**特点**：
- API Key在后端，更安全
- 支持统一计费和配额管理
- 支持使用量统计
- 支持限流和监控

---

## 四、适配器实现

### 4.1 适配器接口

所有适配器必须实现`ModelAdapter`接口：

```typescript
interface ModelAdapter {
  getProviderType(): AIProvider;
  supportsTextGeneration(): boolean;
  supportsImageGeneration(): boolean;
  // ... 其他能力检查
  generateText(request: TextGenerationRequest): Promise<TextGenerationResponse>;
  generateTextStream(...): Promise<void>;
  // ... 其他方法
}
```

### 4.2 适配器实现要点

1. **参数转换**：不同provider的API参数格式不同，需要在适配器中转换
2. **响应解析**：统一响应格式，便于上层使用
3. **错误处理**：捕获并转换provider特定的错误
4. **流式处理**：实现SSE流式响应解析

---

## 五、降级机制

### 5.1 实现原理

当指定provider失败时，自动尝试其他可用的provider：

```typescript
try {
  return await adapter.generateText(request);
} catch (error) {
  if (config.enableFallback) {
    return this.tryFallback(request, provider, 'text', 'generateText');
  }
  throw error;
}
```

### 5.2 降级顺序

1. 获取所有可用的provider
2. 排除失败的provider
3. 按顺序尝试其他provider
4. 如果全部失败，抛出异常

### 5.3 限制

- 流式生成不支持降级（技术限制）
- 需要配置`enableFallback: true`

---

## 六、错误处理

### 6.1 异常类型

- `AIServiceException`: 通用AI服务异常
- `UnsupportedModelException`: 不支持的模型
- `APIKeyNotConfiguredException`: API Key未配置

### 6.2 错误处理流程

```
适配器调用
  ↓
捕获异常
  ↓
检查是否启用降级
  ↓
是 → 尝试其他provider
  ↓
否 → 抛出异常
```

---

## 七、配置持久化

### 7.1 存储位置

- **用户配置**: `localStorage['ai_service_config']`
- **API Keys**: `localStorage['ai_api_keys']`

### 7.2 配置结构

```typescript
interface UserAIConfig {
  mode: 'unified' | 'local';
  textProvider?: AIProvider;
  textModel?: string;
  imageProvider?: AIProvider;
  // ... 其他配置
  enableFallback?: boolean;
}
```

---

## 八、扩展性设计

### 8.1 添加新Provider

1. 创建新的适配器类，继承`BaseAdapter`
2. 实现`ModelAdapter`接口的所有方法
3. 在`AdapterManager`中注册
4. 更新类型定义

### 8.2 添加新功能

1. 在`types.ts`中定义新的请求/响应类型
2. 在`ModelAdapter`接口中添加新方法
3. 在各适配器中实现
4. 在`AIService`中添加统一接口

---

## 九、性能考虑

### 9.1 适配器实例管理

- 使用单例模式，避免重复创建
- 延迟初始化，只在需要时创建
- 支持动态更新API Key，无需重新创建

### 9.2 请求优化

- 使用流式生成减少等待时间
- 支持并发请求（由调用方控制）
- 错误快速失败，避免长时间等待

---

## 十、安全考虑

### 10.1 API Key安全

- **本地配置模式**：API Key存储在localStorage（建议加密）
- **统一接入模式**：API Key在后端，前端不接触

### 10.2 请求安全

- 统一接入模式：使用JWT认证
- 本地配置模式：直接调用，注意CORS

---

**文档维护**: 随系统开发持续更新


