# 日记重复保存问题修复

## 问题描述

在记忆中枢模块中，一篇日记产生了多份副本。经过分析，发现是由于同步机制和手动保存之间的竞态条件导致的。

## 问题根源

### 1. 保存流程

**`handleAddJournalEntry` 的流程**：
1. 创建临时ID `entry_${Date.now()}` 或 `e_${Date.now()}`
2. 立即添加到本地状态（`syncStatus=0`，待同步）
3. 异步调用 `journalApi.createJournalEntry` 保存到服务器
4. API成功后，更新本地状态，将临时ID替换为服务器ID

**`syncJournalEntries` 的流程**：
1. 获取服务器所有条目
2. 找出本地有但服务器没有的条目（`entriesToAdd`）
3. 对于这些条目，调用 `createJournalEntry` 保存

### 2. 竞态条件

如果 `syncJournalEntries` 在 `handleAddJournalEntry` 的API调用完成之前被触发：
- 临时ID的条目会被认为是新条目（因为服务器还没有这个ID）
- `syncJournalEntries` 会再次调用 `createJournalEntry`，导致重复保存

## 修复方案

### 1. 修复 `syncJournalEntries` 方法

**位置**：`frontend/services/syncService.ts`

**修复内容**：

1. **过滤已同步的条目**：
   - 只处理 `syncStatus === 0`（待同步）或 `syncStatus === -1`（同步失败）的条目
   - 跳过 `syncStatus === 1`（已同步）的条目，避免重复保存

2. **跳过正在处理的临时ID条目**：
   - 对于临时ID（`entry_` 或 `e_` 开头）且 `syncStatus === 0` 的条目
   - 说明正在被 `handleAddJournalEntry` 处理，应该跳过，让 `handleAddJournalEntry` 自己处理

3. **更新逻辑优化**：
   - 只更新已同步（`syncStatus === 1`）但内容有变化的条目
   - 跳过临时ID的条目（这些条目应该通过create处理，而不是update）

4. **添加日志和错误处理**：
   - 添加详细的日志，便于调试
   - 添加错误处理，确保单个条目失败不会中断整个同步过程

### 2. 修复后的代码逻辑

```typescript
// Entries to add to server
const entriesToAdd = localEntries.filter(entry => {
  // 如果条目已同步，不需要再次保存
  if (entry.syncStatus === 1) {
    return false;
  }
  // 如果条目不在服务器上，且是待同步或同步失败状态，需要添加
  if (!serverEntryMap.has(entry.id)) {
    // 对于临时ID（entry_或e_开头）且syncStatus=0的条目，说明正在被handleAddJournalEntry处理
    // 应该跳过，让handleAddJournalEntry自己处理，避免重复保存
    if ((entry.id.startsWith('entry_') || entry.id.startsWith('e_')) && entry.syncStatus === 0) {
      console.log('[syncJournalEntries] 跳过正在处理的临时条目:', entry.id);
      return false;
    }
    return true;
  }
  return false;
});

// Entries to update on server
const entriesToUpdate = localEntries.filter(entry => {
  // 跳过临时ID的条目（这些条目应该通过create处理，而不是update）
  if (entry.id.startsWith('entry_') || entry.id.startsWith('e_')) {
    return false;
  }
  const serverEntry = serverEntryMap.get(entry.id);
  if (!serverEntry) {
    return false;
  }
  // 只更新已同步但内容有变化的条目
  return entry.syncStatus === 1 && (
    entry.title !== serverEntry.title || 
    entry.content !== serverEntry.content || 
    entry.timestamp !== serverEntry.timestamp ||
    entry.tags !== (serverEntry.tags || null) ||
    entry.insight !== (serverEntry.insight || null)
  );
});
```

## 测试建议

1. **测试场景1：正常保存**
   - 创建一篇新日记
   - 验证：只保存一次，没有重复

2. **测试场景2：保存后立即同步**
   - 创建一篇新日记
   - 立即触发同步（手动或自动）
   - 验证：不会重复保存

3. **测试场景3：保存失败后同步**
   - 创建一篇新日记（网络断开）
   - 恢复网络后触发同步
   - 验证：只保存一次，没有重复

4. **测试场景4：多篇日记同时保存**
   - 快速创建多篇日记
   - 验证：每篇日记只保存一次

## 相关文件

- `frontend/services/syncService.ts` - 同步服务（已修复）
- `frontend/hooks/useJournalHandlers.ts` - 日记操作Hook
- `frontend/mobile/MobileApp.tsx` - 移动端应用（使用不同的临时ID格式）

## 注意事项

1. **临时ID格式**：
   - PC端使用：`entry_${Date.now()}`
   - 移动端使用：`e_${Date.now()}`
   - 修复代码已兼容两种格式

2. **同步状态**：
   - `syncStatus = 0`：待同步
   - `syncStatus = 1`：同步成功
   - `syncStatus = -1`：同步失败

3. **日志监控**：
   - 修复后添加了详细的日志，可以通过控制台查看同步过程
   - 如果发现重复保存，可以查看日志定位问题

## 修复日期

2025-12-29


