# 数据隔离机制设计

**文档版本**: V1.0  
**编写日期**: 2025-12-28  
**功能模块**: 体验模式数据隔离

---

## 一、设计目标

在访问他人心域时，确保：
1. **数据隔离**：访问者的体验数据不影响主人的心域
2. **完整体验**：访问者可以完整体验心域的核心功能
3. **数据安全**：访问者的数据不会泄露或误操作

---

## 二、数据隔离策略

### 2.1 会话隔离

**实现方式**：
- 使用 `sessionStorage` 存储体验模式状态
- 页面关闭后自动清除
- 不持久化到 `localStorage`

**代码示例**：
```typescript
// 进入体验模式时
sessionStorage.setItem('experience_mode', JSON.stringify({
  shareConfigId: shareConfig.id,
  visitorId: visitorId,
  startTime: Date.now(),
}));

// 离开体验模式时
sessionStorage.removeItem('experience_mode');
```

### 2.2 API请求隔离

**实现方式**：
- 在API请求头中添加体验模式标识
- 后端根据标识隔离数据操作

**代码示例**：
```typescript
// 在request.ts中添加体验模式标识
const experienceMode = sessionStorage.getItem('experience_mode');
if (experienceMode) {
  headers['X-Experience-Mode'] = 'true';
  headers['X-Share-Config-Id'] = JSON.parse(experienceMode).shareConfigId;
}
```

### 2.3 数据操作隔离

**后端实现**：
- 检查请求头中的体验模式标识
- 如果是体验模式，数据操作不保存到主人的心域
- 体验数据存储在临时表或session中

**示例**：
```java
@Aspect
public class ExperienceModeAspect {
    @Around("@annotation(RequiresExperienceMode)")
    public Object handleExperienceMode(ProceedingJoinPoint joinPoint) {
        HttpServletRequest request = getRequest();
        if (isExperienceMode(request)) {
            // 使用临时数据存储
            return proceedWithTemporaryStorage(joinPoint);
        }
        return proceedNormally(joinPoint);
    }
}
```

---

## 三、隔离范围

### 3.1 需要隔离的数据

- ✅ **对话记录**：访问者与E-SOUL的对话不保存到主人的对话历史
- ✅ **记忆数据**：访问者产生的记忆不保存到主人的记忆系统
- ✅ **情绪数据**：访问者的情绪记录不保存到主人的情绪系统
- ✅ **访问历史**：访问者的访问历史单独记录（体验摘要表）

### 3.2 不需要隔离的数据

- ✅ **角色信息**：可以查看角色的基本信息
- ✅ **场景信息**：可以查看场景的基本信息
- ✅ **世界信息**：可以查看世界的基本信息

---

## 四、实现方案

### 4.1 前端实现

**体验模式标识**：
- 使用 `ExperienceModeBanner` 组件显示标识
- 使用 `useExperienceMode` Hook 管理状态
- 使用 `ExperienceModeProvider` 提供全局状态

**数据操作拦截**：
- 在API请求中添加体验模式标识
- 在数据保存前检查体验模式状态

### 4.2 后端实现

**拦截器**：
```java
@Component
public class ExperienceModeInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        String experienceMode = request.getHeader("X-Experience-Mode");
        if ("true".equals(experienceMode)) {
            // 设置体验模式上下文
            ExperienceModeContext.setActive(true);
            ExperienceModeContext.setShareConfigId(request.getHeader("X-Share-Config-Id"));
        }
        return true;
    }
}
```

**数据服务层**：
```java
@Service
public class DialogueService {
    public void saveDialogue(Dialogue dialogue) {
        if (ExperienceModeContext.isActive()) {
            // 保存到临时表
            temporaryDialogueRepository.save(dialogue);
        } else {
            // 正常保存
            dialogueRepository.save(dialogue);
        }
    }
}
```

---

## 五、体验摘要

### 5.1 摘要内容

- 体验时长
- 访问的场景列表
- 交互的角色列表
- 对话轮数统计

### 5.2 摘要存储

- 存储在 `experience_summary` 表
- 主人可以查看访问者的体验摘要（可选）
- 访问者离开时自动生成摘要

---

## 六、注意事项

1. **性能考虑**：体验模式的数据操作不应影响正常用户的性能
2. **数据清理**：定期清理过期的体验数据
3. **安全考虑**：确保体验模式数据不会被恶意利用
4. **用户体验**：体验模式应该对用户透明，不影响使用体验

---

**文档维护**: 如有变更，请及时更新本文档

