# 数字生命体交互系统（心域）V1.0.0 源代码鉴别材料（后30页）

## 第 31 页

**文件路径：backend/src/main/java/com/heartsphere/entity/User.java**

```java

package com.heartsphere.entity;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;

@Data
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String username;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false)
    private String password;

    @Column(name = "wechat_openid", unique = true)
    private String wechatOpenid;

    @Column(name = "nickname")
    private String nickname;

    @Column(name = "avatar")
    private String avatar;

    @Column(name = "is_enabled", nullable = false)
    private Boolean isEnabled = true;

    @Column(name = "created_at")
    @CreationTimestamp
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    @UpdateTimestamp
    private LocalDateTime updatedAt;
}
```

## 第 32 页

**文件路径：backend/src/main/java/com/heartsphere/entity/World.java**

```java

package com.heartsphere.entity;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;

@Data
@Entity
@Table(name = "worlds")
public class World {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(columnDefinition = "TEXT")
    private String description;

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Column(name = "created_at")
    @CreationTimestamp
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    @UpdateTimestamp
    private LocalDateTime updatedAt;
    
    // 冗余字段，用于Spring Data JPA的findByUserId查询
    @Column(name = "user_id", insertable = false, updatable = false)
    private Long userId;

    @Column(name = "is_deleted", nullable = false)
    private Boolean isDeleted = false;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;
}
```

## 第 33 页

**文件路径：backend/src/main/java/com/heartsphere/entity/Character.java**

```java

package com.heartsphere.entity;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;
import org.springframework.data.annotation.Transient;

import java.time.LocalDateTime;

@Data
@Entity
@Table(name = "characters")
public class Character {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Column(name = "age")
    private Integer age;

    @Column(name = "gender")
    private String gender;

    @Column(name = "role")
    private String role;

    @Column(name = "bio", columnDefinition = "TEXT")
    private String bio;

    @Column(name = "avatar_url")
    private String avatarUrl;

    @Column(name = "background_url")
    private String backgroundUrl;

    @Column(name = "theme_color")
    private String themeColor;

    @Column(name = "color_accent")
    private String colorAccent;

    @Column(name = "first_message")
    private String firstMessage;

    @Column(name = "system_instruction", columnDefinition = "TEXT")
    private String systemInstruction;

    @Column(name = "voice_name")
    private String voiceName;

    @Column(name = "mbti")
    private String mbti;

    @Column(name = "tags")
    private String tags;

    @Column(name = "speech_style")
    private String speechStyle;

    @Column(name = "catchphrases")
    private String catchphrases;

    @Column(name = "secrets", columnDefinition = "TEXT")
    private String secrets;

    @Column(name = "motivations", columnDefinition = "TEXT")
    private String motivations;

    @Column(name = "relationships", columnDefinition = "TEXT")
    private String relationships;

    @ManyToOne
    @JoinColumn(name = "world_id", nullable = false)
    private World world;

    @ManyToOne
    @JoinColumn(name = "era_id")
    private Era era;

    // 为前端提供worldId字段
    @Transient
    public Long getWorldId() {
        return world != null ? world.getId() : null;
    }

    // 为前端提供eraId字段
    @Transient
    public Long getEraId() {
        return era != null ? era.getId() : null;
    }

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Column(name = "created_at")
    @CreationTimestamp
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    @UpdateTimestamp
    private LocalDateTime updatedAt;

    @Column(name = "is_deleted", nullable = false)
    private Boolean isDeleted = false;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;
}
```

## 第 34 页

**文件路径：backend/src/main/java/com/heartsphere/entity/Era.java**

```java

package com.heartsphere.entity;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;

@Data
@Entity
@Table(name = "eras")
public class Era {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Column(name = "start_year")
    private Integer startYear;

    @Column(name = "end_year")
    private Integer endYear;

    @Column(name = "image_url", columnDefinition = "TEXT")
    private String imageUrl;

    @ManyToOne
    @JoinColumn(name = "world_id", nullable = false)
    private World world;

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Column(name = "created_at")
    @CreationTimestamp
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    @UpdateTimestamp
    private LocalDateTime updatedAt;

    @Column(name = "is_deleted", nullable = false)
    private Boolean isDeleted = false;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;
}
```

## 第 35 页

**文件路径：backend/src/main/java/com/heartsphere/entity/JournalEntry.java**

```java

package com.heartsphere.entity;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;
import java.util.UUID;

import java.time.LocalDateTime;

@Data
@Entity
@Table(name = "journal_entries")
public class JournalEntry {
    @Id
    private String id;
    
    @PrePersist
    public void generateIdAndTimestamp() {
        if (this.id == null) {
            this.id = UUID.randomUUID().toString();
        }
        if (this.timestamp == null) {
            this.timestamp = System.currentTimeMillis();
        }
    }

    @Column(nullable = false)
    private String title;

    @Column(columnDefinition = "TEXT")
    private String content;

    @Column(length = 500)
    private String tags; // 标签（逗号分隔，如：#灵感,#梦境,#工作）

    @Column(name = "entry_date")
    private LocalDateTime entryDate;

    @Column(nullable = false)
    private Long timestamp;

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @ManyToOne
    @JoinColumn(name = "world_id")
    private World world;

    @ManyToOne
    @JoinColumn(name = "era_id")
    private Era era;

    @ManyToOne
    @JoinColumn(name = "character_id")
    private Character character;

    @Column(name = "created_at")
    @CreationTimestamp
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    @UpdateTimestamp
    private LocalDateTime updatedAt;
}
```

## 第 36 页

**文件路径：backend/src/main/java/com/heartsphere/entity/Membership.java**

```java

package com.heartsphere.entity;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;

/**
 * 用户会员实体
 */
@Data
@Entity
@Table(name = "memberships")
public class Membership {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "user_id", nullable = false)
    private Long userId;

    @Column(name = "plan_id", nullable = false)
    private Long planId;

    @Column(name = "plan_type", nullable = false, length = 50)
    private String planType; // free, basic, standard, premium

    @Column(name = "billing_cycle", nullable = false, length = 20)
    private String billingCycle; // monthly, yearly, continuous_monthly, continuous_yearly

    @Column(name = "status", nullable = false, length = 20)
    private String status = "active"; // active, expired, cancelled, suspended

    @Column(name = "start_date", nullable = false)
    private LocalDateTime startDate;

    @Column(name = "end_date")
    private LocalDateTime endDate;

    @Column(name = "auto_renew", nullable = false)
    private Boolean autoRenew = false;

    @Column(name = "next_renewal_date")
    private LocalDateTime nextRenewalDate;

    @Column(name = "renewal_price", precision = 10, scale = 2)
    private java.math.BigDecimal renewalPrice;

    @Column(name = "current_points", nullable = false)
    private Integer currentPoints = 0;

    @Column(name = "total_points_earned", nullable = false)
    private Integer totalPointsEarned = 0;

    @Column(name = "total_points_used", nullable = false)
    private Integer totalPointsUsed = 0;

    @Column(name = "created_at", nullable = false, updatable = false)
    @CreationTimestamp
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    @UpdateTimestamp
    private LocalDateTime updatedAt;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", insertable = false, updatable = false)
    private User user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "plan_id", insertable = false, updatable = false)
    private SubscriptionPlan plan;
}
```

## 第 37 页

**文件路径：backend/src/main/java/com/heartsphere/entity/PaymentOrder.java**

```java

package com.heartsphere.entity;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * 支付订单实体
 */
@Data
@Entity
@Table(name = "payment_orders")
public class PaymentOrder {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "order_no", nullable = false, unique = true, length = 64)
    private String orderNo;

    @Column(name = "user_id", nullable = false)
    private Long userId;

    @Column(name = "plan_id", nullable = false)
    private Long planId;

    @Column(name = "payment_type", nullable = false, length = 20)
    private String paymentType; // wechat, alipay

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal amount;

    @Column(nullable = false, length = 20)
    private String status = "pending"; // pending, paid, failed, cancelled, refunded

    @Column(name = "payment_provider", length = 50)
    private String paymentProvider;

    @Column(name = "transaction_id", length = 128)
    private String transactionId;

    @Column(name = "qr_code_url", columnDefinition = "TEXT")
    private String qrCodeUrl;

    @Column(name = "payment_url", columnDefinition = "TEXT")
    private String paymentUrl;

    @Column(name = "paid_at")
    private LocalDateTime paidAt;

    @Column(name = "expires_at")
    private LocalDateTime expiresAt;

    @Column(name = "notify_data", columnDefinition = "TEXT")
    private String notifyData; // JSON格式

    @Column(name = "created_at", nullable = false, updatable = false)
    @CreationTimestamp
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    @UpdateTimestamp
    private LocalDateTime updatedAt;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", insertable = false, updatable = false)
    private User user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "plan_id", insertable = false, updatable = false)
    private SubscriptionPlan plan;
}
```

## 第 38 页

**文件路径：backend/src/main/java/com/heartsphere/entity/Script.java**

```java

package com.heartsphere.entity;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;

@Data
@Entity
@Table(name = "scripts")
public class Script {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String title;

    @Column(columnDefinition = "TEXT")
    private String content;

    @Column(name = "scene_count")
    private Integer sceneCount;

    @ManyToOne
    @JoinColumn(name = "world_id", nullable = false)
    private World world;

    @ManyToOne
    @JoinColumn(name = "era_id")
    private Era era;

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Column(name = "created_at")
    @CreationTimestamp
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    @UpdateTimestamp
    private LocalDateTime updatedAt;

    @Column(name = "is_deleted", nullable = false)
    private Boolean isDeleted = false;

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;
}
```

## 第 39 页

**文件路径：backend/src/main/java/com/heartsphere/entity/SubscriptionPlan.java**

```java

package com.heartsphere.entity;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * 订阅计划实体
 */
@Data
@Entity
@Table(name = "subscription_plans")
public class SubscriptionPlan {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false, length = 50)
    private String type; // free, basic, standard, premium

    @Column(name = "billing_cycle", nullable = false, length = 20)
    private String billingCycle; // monthly, yearly, continuous_monthly, continuous_yearly

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal price;

    @Column(name = "original_price", precision = 10, scale = 2)
    private BigDecimal originalPrice;

    @Column(name = "discount_percent")
    private Integer discountPercent;

    @Column(name = "points_per_month", nullable = false)
    private Integer pointsPerMonth = 0;

    @Column(name = "max_images_per_month")
    private Integer maxImagesPerMonth;

    @Column(name = "max_videos_per_month")
    private Integer maxVideosPerMonth;

    @Column(name = "max_text_generations_per_month")
    private Integer maxTextGenerationsPerMonth; // NULL表示无限制

    @Column(name = "max_audio_generations_per_month")
    private Integer maxAudioGenerationsPerMonth; // NULL表示无限制

    @Column(name = "allowed_ai_models", columnDefinition = "TEXT")
    private String allowedAiModels; // JSON格式，如：["qwen3-max", "gpt-4", "gemini-pro"]

    @Column(name = "max_image_resolution", length = 20)
    private String maxImageResolution; // 如：2k, 4k, 8k

    @Column(name = "max_video_duration")
    private Integer maxVideoDuration; // 秒，NULL表示无限制

    @Column(name = "allow_priority_queue", nullable = false)
    private Boolean allowPriorityQueue = false; // 是否允许优先队列（加速处理）

    @Column(name = "allow_watermark_removal", nullable = false)
    private Boolean allowWatermarkRemoval = false; // 是否允许去除水印

    @Column(name = "allow_batch_processing", nullable = false)
    private Boolean allowBatchProcessing = false; // 是否允许批量处理

    @Column(name = "allow_api_access", nullable = false)
    private Boolean allowApiAccess = false; // 是否允许API访问

    @Column(name = "max_api_calls_per_day")
    private Integer maxApiCallsPerDay; // NULL表示无限制

    @Column(name = "ai_benefits", columnDefinition = "TEXT")
    private String aiBenefits; // JSON格式，包含详细权限配置

    @Column(columnDefinition = "TEXT")
    private String features; // JSON格式

    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;

    @Column(name = "sort_order", nullable = false)
    private Integer sortOrder = 0;

    @Column(name = "created_at", nullable = false, updatable = false)
    @CreationTimestamp
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    @UpdateTimestamp
    private LocalDateTime updatedAt;
}
```

## 第 40 页

**文件路径：backend/src/main/java/com/heartsphere/entity/PointTransaction.java**

```java

package com.heartsphere.entity;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;

import java.time.LocalDateTime;

/**
 * 积分记录实体
 */
@Data
@Entity
@Table(name = "point_transactions")
public class PointTransaction {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "user_id", nullable = false)
    private Long userId;

    @Column(name = "membership_id")
    private Long membershipId;

    @Column(nullable = false, length = 20)
    private String type; // earn, use, expire, refund

    @Column(nullable = false)
    private Integer amount; // 正数为获得，负数为使用

    @Column(name = "balance_after", nullable = false)
    private Integer balanceAfter;

    @Column(length = 500)
    private String description;

    @Column(name = "related_order_id")
    private Long relatedOrderId;

    @Column(name = "expires_at")
    private LocalDateTime expiresAt;

    @Column(name = "created_at", nullable = false, updatable = false)
    @CreationTimestamp
    private LocalDateTime createdAt;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", insertable = false, updatable = false)
    private User user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "membership_id", insertable = false, updatable = false)
    private Membership membership;
}
```

## 第 41 页

**文件路径：backend/src/main/java/com/heartsphere/repository/UserRepository.java**

```java

package com.heartsphere.repository;

import com.heartsphere.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
    Optional<User> findByEmail(String email);
    Optional<User> findByWechatOpenid(String wechatOpenid);
    Boolean existsByUsername(String username);
    Boolean existsByEmail(String email);
    Boolean existsByWechatOpenid(String wechatOpenid);
}
```

## 第 42 页

**文件路径：backend/src/main/java/com/heartsphere/repository/WorldRepository.java**

```java

package com.heartsphere.repository;

import com.heartsphere.entity.World;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface WorldRepository extends JpaRepository<World, Long> {
    // 按照其他Repository的模式，添加根据用户ID查询世界的方法
    @Query("SELECT w FROM World w WHERE w.userId = :userId AND w.isDeleted = false")
    List<World> findByUserId(@Param("userId") Long userId);
    
    // 回收站：获取已删除的世界
    @Query("SELECT w FROM World w WHERE w.userId = :userId AND w.isDeleted = true")
    List<World> findDeletedByUserId(@Param("userId") Long userId);
}
```

## 第 43 页

**文件路径：backend/src/main/java/com/heartsphere/repository/CharacterRepository.java**

```java

package com.heartsphere.repository;

import com.heartsphere.entity.Character;
import org.springframework.data.jpa.repository.EntityGraph;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface CharacterRepository extends JpaRepository<Character, Long> {
    @EntityGraph(attributePaths = {"world", "era", "user"})
    @Query("SELECT c FROM Character c WHERE c.user.id = :userId AND c.isDeleted = false")
    List<Character> findByUser_Id(@Param("userId") Long userId);
    
    @EntityGraph(attributePaths = {"world", "era", "user"})
    @Query("SELECT c FROM Character c WHERE c.world.id = :worldId AND c.isDeleted = false")
    List<Character> findByWorld_Id(@Param("worldId") Long worldId);
    
    @EntityGraph(attributePaths = {"world", "era", "user"})
    @Query("SELECT c FROM Character c WHERE c.era.id = :eraId AND c.isDeleted = false")
    List<Character> findByEra_Id(@Param("eraId") Long eraId);
    
    // 回收站：获取已删除的角色
    @EntityGraph(attributePaths = {"world", "era", "user"})
    @Query("SELECT c FROM Character c WHERE c.user.id = :userId AND c.isDeleted = true")
    List<Character> findDeletedByUser_Id(@Param("userId") Long userId);
}
```

## 第 44 页

**文件路径：backend/src/main/java/com/heartsphere/repository/EraRepository.java**

```java

package com.heartsphere.repository;

import com.heartsphere.entity.Era;
import org.springframework.data.jpa.repository.EntityGraph;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface EraRepository extends JpaRepository<Era, Long> {
    @EntityGraph(attributePaths = {"world", "user"})
    @Query("SELECT e FROM Era e WHERE e.user.id = :userId AND e.isDeleted = false")
    List<Era> findByUser_Id(@Param("userId") Long userId);
    
    @EntityGraph(attributePaths = {"world", "user"})
    @Query("SELECT e FROM Era e WHERE e.world.id = :worldId AND e.isDeleted = false")
    List<Era> findByWorld_Id(@Param("worldId") Long worldId);
    
    @EntityGraph(attributePaths = {"world", "user"})
    @Query("SELECT e FROM Era e WHERE e.world.id = :worldId AND e.user.id = :userId AND e.isDeleted = false")
    List<Era> findByWorld_IdAndUser_Id(@Param("worldId") Long worldId, @Param("userId") Long userId);
    
    // 回收站：获取已删除的时代
    @EntityGraph(attributePaths = {"world", "user"})
    @Query("SELECT e FROM Era e WHERE e.user.id = :userId AND e.isDeleted = true")
    List<Era> findDeletedByUser_Id(@Param("userId") Long userId);
}
```

## 第 45 页

**文件路径：backend/src/main/java/com/heartsphere/dto/UserDTO.java**

```java

package com.heartsphere.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserDTO {
    private Long id;
    private String username;
    private String email;
    private String nickname;
    private String avatar;
    private String wechatOpenid;
    private Boolean isEnabled;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```

## 第 46 页

**文件路径：backend/src/main/java/com/heartsphere/dto/WorldDTO.java**

```java

package com.heartsphere.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class WorldDTO {
    private Long id;
    private String name;
    private String description;
    private Long userId;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```

## 第 47 页

**文件路径：backend/src/main/java/com/heartsphere/dto/CharacterDTO.java**

```java

package com.heartsphere.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CharacterDTO {
    private Long id;
    private String name;
    private String description;
    private Integer age;
    private String gender;
    private String role;
    private String bio;
    private String avatarUrl;
    private String backgroundUrl;
    private String themeColor;
    private String colorAccent;
    private String firstMessage;
    private String systemInstruction;
    private String voiceName;
    private String mbti;
    private String tags;
    private String speechStyle;
    private String catchphrases;
    private String secrets;
    private String motivations;
    private String relationships;
    private Long worldId;
    private Long eraId;
    private Long userId;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```

## 第 48 页

**文件路径：backend/src/main/java/com/heartsphere/dto/EraDTO.java**

```java

package com.heartsphere.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class EraDTO {
    private Long id;
    private String name;
    private String description;
    private Integer startYear;
    private Integer endYear;
    private String imageUrl;
    private Long worldId;
    private Long userId;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```

## 第 49 页

**文件路径：backend/src/main/java/com/heartsphere/dto/JournalEntryDTO.java**

```java

package com.heartsphere.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class JournalEntryDTO {
    private String id;
    private String title;
    private String content;
    private String tags;
    private LocalDateTime entryDate;
    private Long timestamp;
    private Long worldId;
    private Long eraId;
    private Long characterId;
    private Long userId;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```

## 第 50 页

**文件路径：backend/src/main/java/com/heartsphere/dto/ScriptDTO.java**

```java

package com.heartsphere.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ScriptDTO {
    private Long id;
    private String title;
    private String content;
    private Integer sceneCount;
    private Long worldId;
    private Long eraId;
    private Long userId;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```

## 第 51 页

**文件路径：backend/src/main/java/com/heartsphere/config/WebSecurityConfig.java**

```java

package com.heartsphere.config;

import com.heartsphere.security.JwtAuthenticationFilter;
import com.heartsphere.security.UserDetailsServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class WebSecurityConfig {

    @Autowired
    UserDetailsServiceImpl userDetailsService;

    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();

        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());

        return authProvider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public JwtAuthenticationFilter jwtAuthenticationFilter() {
        return new JwtAuthenticationFilter();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
                // 启用默认的CORS配置，使用application.yml中的配置
                .cors(cors -> cors.configurationSource(request -> {
                    // 创建默认的CORS配置
                    CorsConfiguration config = new CorsConfiguration();
                    // 允许所有来源
                    config.addAllowedOriginPattern("*");
                    // 允许所有HTTP方法
                    config.addAllowedMethod("*");
                    // 允许所有请求头
                    config.addAllowedHeader("*");
                    // 允许携带凭证
                    config.setAllowCredentials(true);
                    // 预检请求的缓存时间
                    config.setMaxAge(3600L);
                    return config;
                }))
                // 禁用CSRF
                .csrf(csrf -> csrf.disable())
                // 设置会话管理为无状态
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                // 配置授权规则
                .authorizeHttpRequests(auth -> auth
                        // 允许公开访问的端点
                        .requestMatchers("/api/auth/**", "/api/admin/auth/**", "/api/wechat/**", "/swagger-ui/**", "/v3/api-docs/**").permitAll()
                        // 允许所有OPTIONS请求
                        .requestMatchers(request -> "OPTIONS".equals(request.getMethod())).permitAll()
                        // 允许所有请求，方便开发测试
                        .anyRequest().permitAll());

        // 配置认证提供者
        http.authenticationProvider(authenticationProvider());

        // 添加JWT过滤器
        http.addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}
```

## 第 52 页

**文件路径：backend/src/main/java/com/heartsphere/security/JwtAuthenticationFilter.java**

```java

package com.heartsphere.security;

import com.heartsphere.utils.JwtUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;

public class JwtAuthenticationFilter extends OncePerRequestFilter {

    @Autowired
    private JwtUtils jwtUtils;

    @Autowired
    private UserDetailsServiceImpl userDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        try {
            // 1. 从请求头中提取JWT令牌
            String jwt = parseJwt(request);
            
            // 2. 验证令牌
            if (jwt != null && jwtUtils.validateJwtToken(jwt)) {
                // 3. 从令牌中获取用户名
                String username = jwtUtils.getUserNameFromJwtToken(jwt);
                
                // 4. 加载用户信息
                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                
                // 5. 创建认证对象
                UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                
                // 6. 将认证对象设置到SecurityContextHolder中
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception e) {
            logger.error("Cannot set user authentication: " + e.getMessage(), e);
        }
        
        // 继续处理请求
        filterChain.doFilter(request, response);
    }
    
    // 从请求头中提取JWT令牌
    private String parseJwt(HttpServletRequest request) {
        String headerAuth = request.getHeader("Authorization");
        
        if (StringUtils.hasText(headerAuth) && headerAuth.startsWith("Bearer ")) {
            return headerAuth.substring(7);
        }
        
        return null;
    }
}
```

## 第 53 页

**文件路径：backend/src/main/java/com/heartsphere/controller/AuthController.java（部分）**

```java

package com.heartsphere.controller;

import com.heartsphere.dto.AuthResponse;
import com.heartsphere.dto.LoginRequest;
import com.heartsphere.dto.RegisterRequest;
import com.heartsphere.dto.WorldDTO;
import com.heartsphere.entity.User;
import com.heartsphere.repository.UserRepository;
import com.heartsphere.entity.World;
import com.heartsphere.repository.WorldRepository;
import java.util.List;
import java.util.stream.Collectors;
import com.heartsphere.security.UserDetailsImpl;
import com.heartsphere.service.InitializationService;
import com.heartsphere.utils.JwtUtils;
import com.heartsphere.utils.DTOMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.*;

import java.util.Map;
import java.util.HashMap;

@CrossOrigin(origins = "*")
@RestController
@RequestMapping("/api/auth")
public class AuthController {

    @Autowired
    AuthenticationManager authenticationManager;

    @Autowired
    UserRepository userRepository;

    @Autowired
    PasswordEncoder encoder;

    @Autowired
    JwtUtils jwtUtils;

    @Autowired
    InitializationService initializationService;

    @Autowired
    WorldRepository worldRepository;

    @Autowired
    com.heartsphere.admin.service.InviteCodeService inviteCodeService;

    @Autowired
    com.heartsphere.admin.service.SystemConfigService systemConfigService;

    @PostMapping("/login")
    public ResponseEntity<?> authenticateUser(@RequestBody LoginRequest loginRequest) {
        try {
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(loginRequest.getUsername(), loginRequest.getPassword()));

            SecurityContextHolder.getContext().setAuthentication(authentication);
            String jwt = jwtUtils.generateJwtToken(authentication);

            UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
            User user = userRepository.findByUsername(userDetails.getUsername()).orElseThrow();

            // 查询用户的世界，若为空则初始化，再次查询以返回最新数据
            List<World> userWorlds = worldRepository.findByUserId(user.getId());
            boolean isFirstLogin = userWorlds.isEmpty();
            if (isFirstLogin) {
                try {
                    initializationService.initializeUserData(user);
                    userWorlds = worldRepository.findByUserId(user.getId());
                } catch (Exception e) {
                    // 初始化失败不影响登录，记录日志即可
                    java.util.logging.Logger.getLogger(AuthController.class.getName())
                        .warning("用户数据初始化失败: " + e.getMessage());
                    e.printStackTrace();
                }
            }

            // 返回登录响应，包含首次登录标识
            Map<String, Object> resp = new HashMap<>();
            resp.put("token", jwt);
            resp.put("id", user.getId());
            resp.put("username", user.getUsername());
            resp.put("email", user.getEmail());
            resp.put("nickname", user.getNickname());
            resp.put("avatar", user.getAvatar()); // 允许为 null
            resp.put("isFirstLogin", isFirstLogin);
            
            // 转换为DTO列表，确保没有循环引用
            // 手动构建简单的DTO，将 LocalDateTime 转换为字符串
            List<Map<String, Object>> worldDTOs = new java.util.ArrayList<>();
            for (World world : userWorlds) {
                try {
                    Map<String, Object> worldMap = new HashMap<>();
                    worldMap.put("id", world.getId());
                    worldMap.put("name", world.getName());
                    worldMap.put("description", world.getDescription());
                    worldMap.put("userId", world.getUserId());
                    // 将 LocalDateTime 转换为字符串
                    worldMap.put("createdAt", world.getCreatedAt() != null ? world.getCreatedAt().toString() : null);
                    worldMap.put("updatedAt", world.getUpdatedAt() != null ? world.getUpdatedAt().toString() : null);
                    worldDTOs.add(worldMap);
                } catch (Exception e) {
                    // 跳过有问题的世界
                    java.util.logging.Logger.getLogger(AuthController.class.getName())
                        .warning("世界序列化失败: " + e.getMessage());
                }
            }
            resp.put("worlds", worldDTOs);
            
            return ResponseEntity.ok(resp);
        } catch (org.springframework.security.core.AuthenticationException e) {
            // 认证异常（用户名或密码错误）
            return ResponseEntity
                    .status(401)
                    .body(Map.of("message", "用户名或密码错误"));
        } catch (Exception e) {
            // 其他异常，记录日志并返回错误信息
            java.util.logging.Logger.getLogger(AuthController.class.getName())
                .severe("登录异常: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity
                    .status(500)
                    .body(Map.of("message", "登录失败: " + e.getMessage()));
        }
    }
```

## 第 54 页

**文件路径：backend/src/main/java/com/heartsphere/controller/AuthController.java（续）**

```java

    @PostMapping("/register")
    public ResponseEntity<?> registerUser(@RequestBody RegisterRequest registerRequest) {
        // 检查是否需要邀请码
        boolean inviteCodeRequired = systemConfigService.isInviteCodeRequired();
        if (inviteCodeRequired) {
            if (registerRequest.getInviteCode() == null || registerRequest.getInviteCode().trim().isEmpty()) {
                return ResponseEntity
                        .badRequest()
                        .body(Map.of("message", "邀请码是必需的"));
            }
            // 验证邀请码（但不核销，等用户创建成功后再核销）
            try {
                inviteCodeService.validateInviteCode(registerRequest.getInviteCode().trim());
            } catch (RuntimeException e) {
                return ResponseEntity
                        .badRequest()
                        .body(Map.of("message", e.getMessage()));
            }
        }

        if (userRepository.existsByUsername(registerRequest.getUsername())) {
            return ResponseEntity
                    .badRequest()
                    .body(Map.of("message", "Username is already taken!"));
        }

        if (userRepository.existsByEmail(registerRequest.getEmail())) {
            return ResponseEntity
                    .badRequest()
                    .body(Map.of("message", "Email is already in use!"));
        }

        User user = new User();
        user.setUsername(registerRequest.getUsername());
        user.setEmail(registerRequest.getEmail());
        user.setPassword(encoder.encode(registerRequest.getPassword()));
        // 如果提供了nickname则使用，否则使用username作为默认值
        user.setNickname(registerRequest.getNickname() != null && !registerRequest.getNickname().trim().isEmpty() 
            ? registerRequest.getNickname().trim() 
            : registerRequest.getUsername());
        user.setIsEnabled(true); // 确保用户是启用状态

        userRepository.save(user);

        // 如果使用了邀请码，核销它
        if (inviteCodeRequired && registerRequest.getInviteCode() != null) {
            try {
                inviteCodeService.useInviteCode(registerRequest.getInviteCode().trim(), user.getId());
            } catch (RuntimeException e) {
                // 如果核销失败，记录日志但不影响注册流程（因为已经验证过了）
                java.util.logging.Logger.getLogger(AuthController.class.getName())
                    .warning("邀请码核销失败: " + e.getMessage());
            }
        }
        
        // 初始化用户数据（世界、时代、角色）
        initializationService.initializeUserData(user);

        Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(registerRequest.getUsername(), registerRequest.getPassword()));

        SecurityContextHolder.getContext().setAuthentication(authentication);
        String jwt = jwtUtils.generateJwtToken(authentication);

        // 新注册用户一定是首次登录
        boolean isFirstLogin = true;

        // 注册完成后查询初始化生成的世界列表，便于前端首屏使用
        List<World> userWorlds = worldRepository.findByUserId(user.getId());
        List<WorldDTO> worldDTOs = userWorlds.stream()
            .map(DTOMapper::toWorldDTO)
            .collect(Collectors.toList());

        Map<String, Object> resp = new HashMap<>();
        resp.put("token", jwt);
        resp.put("id", user.getId());
        resp.put("username", user.getUsername());
        resp.put("email", user.getEmail());
        resp.put("nickname", user.getNickname());
        resp.put("avatar", user.getAvatar()); // 允许为 null
        resp.put("isFirstLogin", isFirstLogin);
        resp.put("worlds", worldDTOs);

        return ResponseEntity.ok(resp);
    }

    @GetMapping("/invite-code-required")
    public ResponseEntity<Map<String, Object>> isInviteCodeRequired() {
        boolean required = systemConfigService.isInviteCodeRequired();
        return ResponseEntity.ok(Map.of("inviteCodeRequired", required));
    }

    @GetMapping("/me")
    public ResponseEntity<?> getCurrentUser(Authentication authentication) {
        try {
            UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
            User user = userRepository.findByUsername(userDetails.getUsername())
                    .orElseThrow(() -> new RuntimeException("User not found"));

            return ResponseEntity.ok(DTOMapper.toUserDTO(user));
        } catch (Exception e) {
            // 捕获所有异常，返回具体的错误信息
            return ResponseEntity
                    .status(401)
                    .body(Map.of("message", "Invalid authentication token"));
        }
    }
}
```

## 第 55 页

**文件路径：frontend/services/api.ts（部分）**

```typescript

// API服务，用于处理与后端的通信

const API_BASE_URL = 'http://localhost:8081/api';

// 管理后台API
export const adminApi = {
  // 管理员登录
  login: (username: string, password: string) => {
    return request<{
      token: string;
      username: string;
      email: string;
      adminId: number;
    }>('/admin/auth/login', {
      method: 'POST',
      body: JSON.stringify({ username, password }),
      headers: {
        'Content-Type': 'application/json',
      },
    });
  },

  // 系统世界管理
  worlds: {
    getAll: (token: string) => {
      return request<Array<{
        id: number;
        name: string;
        description: string;
        isActive: boolean;
        sortOrder: number;
        createdAt: string;
        updatedAt: string;
      }>>('/admin/system/worlds', {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      });
    },
    getById: (id: number, token: string) => {
      return request<{
        id: number;
        name: string;
        description: string;
        isActive: boolean;
        sortOrder: number;
        createdAt: string;
        updatedAt: string;
      }>(`/admin/system/worlds/${id}`, {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      });
    },
    create: (data: any, token: string) => {
      return request<{
        id: number;
        name: string;
        description: string;
        isActive: boolean;
        sortOrder: number;
        createdAt: string;
        updatedAt: string;
      }>('/admin/system/worlds', {
        method: 'POST',
        body: JSON.stringify(data),
        headers: {
          Authorization: `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
      });
    },
    update: (id: number, data: any, token: string) => {
      return request<{
        id: number;
        name: string;
        description: string;
        isActive: boolean;
        sortOrder: number;
        createdAt: string;
        updatedAt: string;
      }>(`/admin/system/worlds/${id}`, {
        method: 'PUT',
        body: JSON.stringify(data),
        headers: {
          Authorization: `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
      });
    },
    delete: (id: number, token: string) => {
      return request<void>(`/admin/system/worlds/${id}`, {
        method: 'DELETE',
        headers: {
          Authorization: `Bearer ${token}`,
        },
      });
    },
  },
```

## 第 56 页

**文件路径：frontend/services/api.ts（续）**

```typescript

// 认证相关API
export const authApi = {
  // 用户登录
  login: (username: string, password: string) => {
    return request<{
      token: string;
      type: string;
      id: number;
      username: string;
      email: string;
      nickname: string;
      avatar: string;
      isFirstLogin?: boolean;
      worlds?: Array<{
        id: number;
        name: string;
        description: string;
        userId: number;
        createdAt: string;
        updatedAt: string;
      }>;
    }>('/auth/login', {
      method: 'POST',
      body: JSON.stringify({ username, password }),
    });
  },

  // 用户注册
  register: (username: string, email: string, password: string, nickname?: string, inviteCode?: string) => {
    return request<{
      token: string;
      type: string;
      id: number;
      username: string;
      email: string;
      nickname: string;
      avatar: string;
      isFirstLogin?: boolean;
      worlds?: Array<{
        id: number;
        name: string;
        description: string;
        userId: number;
        createdAt: string;
        updatedAt: string;
      }>;
    }>('/auth/register', {
      method: 'POST',
      body: JSON.stringify({ username, email, password, nickname: nickname || username, inviteCode }),
      headers: {
        'Content-Type': 'application/json',
      },
    });
  },

  // 检查是否需要邀请码
  isInviteCodeRequired: () => {
    return request<{ inviteCodeRequired: boolean }>('/auth/invite-code-required');
  },

  // 获取当前用户信息
  getCurrentUser: (token: string) => {
    return request<{
      id: number;
      username: string;
      email: string;
      nickname: string;
      avatar: string;
    }>('/auth/me', {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });
  },
};
```

## 第 57 页

**文件路径：frontend/services/gemini.ts（部分）**

```typescript

import { GoogleGenAI, Chat, GenerateContentResponse, Modality, Type } from "@google/genai";
import { Message, Character, StoryNode, CustomScenario, UserProfile, WorldScene, JournalEcho, JournalEntry, AppSettings, AIProvider, DebugLog } from "../types";
import { createScenarioContext } from "../constants";

// Helper to sanitize history for the API
const formatHistory = (history: Message[]) => {
  return history.map(msg => ({
    role: msg.role,
    parts: [{ text: msg.text }],
  }));
};

// Helper to format history for OpenAI Compatible APIs
const formatOpenAIHistory = (history: Message[], systemInstruction: string) => {
  const msgs = history.map(msg => ({
    role: msg.role === 'model' ? 'assistant' : 'user',
    content: msg.text
  }));
  // Prepend system instruction
  return [
    { role: 'system', content: systemInstruction },
    ...msgs
  ];
};

export class GeminiService {
  private ai?: GoogleGenAI;
  private chatSessions: Map<string, Chat> = new Map();
  
  // Configuration State
  private settings: AppSettings | null = null;
  
  // Debug Logging
  private logCallback: ((log: DebugLog) => void) | null = null;

  constructor() {
    // Default initialization with environment key if available
    // Prevent crash if API_KEY is missing during startup
    if (process.env.API_KEY) {
      try {
        this.ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
      } catch (e) {
        console.warn("Failed to initialize GoogleGenAI with process.env.API_KEY", e);
      }
    }
  }

  // Hook for App.tsx to receive logs
  setLogCallback(callback: (log: DebugLog) => void) {
      this.logCallback = callback;
  }

  private log(method: string, type: string, data: any, specificModel?: string, provider?: string) {
      if (this.settings?.debugMode && this.logCallback) {
          let safeData = data;
          try { safeData = JSON.parse(JSON.stringify(data)); } catch(e) { /* ignore circular */ }

          this.logCallback({
              id: `log_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
              timestamp: Date.now(),
              provider: provider || 'unknown',
              model: specificModel || 'unknown',
              method,
              type,
              data: safeData
          });
      }
      // Also log to console for immediate visibility during dev
      if (type === 'error' || type === 'fallback_error') {
          console.error(`[${provider}] ${method} Error:`, data);
      }
  }

  // Update internal configuration based on AppSettings
  updateConfig(settings: AppSettings) {
    this.settings = settings;

    // Re-initialize Gemini client if key changed in geminiConfig and is not empty
    // If empty, we keep the default constructor instance (which might have process.env.API_KEY)
    if (settings.geminiConfig.apiKey) {
        this.ai = new GoogleGenAI({ apiKey: settings.geminiConfig.apiKey });
    } else if (process.env.API_KEY) {
        // Fallback to env key if settings key is cleared/empty
        this.ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    } else {
        // No key available
        this.ai = undefined;
    }
    // Clear sessions on config change to avoid stale state
    this.chatSessions.clear();
  }
```

## 第 58 页

**文件路径：frontend/types.ts（部分）**

```typescript

// This file includes legacy types like 'Persona' to prevent errors in unused components,
// but the main application logic relies on the 'WorldScene' architecture.
export interface Persona {
  id: string;
  name: string;
  description: string;
  avatarUrl: string;
  eras: Character[];
}

export interface Character {
  id: string;
  name: string;
  age: number;
  era?: string; // Legacy support
  role: string;
  bio: string;
  avatarUrl: string;
  backgroundUrl: string;
  systemInstruction: string;
  themeColor: string;
  colorAccent: string;
  firstMessage: string;
  voiceName: string;

  // --- New Deep Personality Fields ---
  mbti?: string;             // e.g., "INFJ"
  tags?: string[];           // e.g., "Tsundere", "Hacker", "Cat Lover"
  speechStyle?: string;      // e.g., "Short, coded, uses slang"
  catchphrases?: string[];   // e.g., "Interesting.", "Baka!"
  secrets?: string;          // Hidden depth not known to user initially
  motivations?: string;      // Current goal driving the character
  relationships?: string;    // Text description of connections with others
}

export interface Message {
  id:string;
  role: 'user' | 'model';
  text: string;
  image?: string;
  timestamp: number;
}

export interface StoryOption {
  id: string;
  text: string;
  nextNodeId: string;
}

export interface StoryNode {
  id: string;
  title: string;
  prompt: string;
  backgroundHint?: string;
  options: StoryOption[];
}

export interface CustomScenario {
  id: string;
  sceneId: string; // Belongs to a specific scene
  title: string;
  description: string;
  nodes: Record<string, StoryNode>;
  startNodeId: string;
  author: string;
}

export interface EraMemory {
  id: string;
  content: string; // Text memory
  imageUrl?: string; // Optional photo
  timestamp: number;
}

export interface WorldScene {
  id: string;
  name: string;
  description: string;
  imageUrl: string;
  characters: Character[];
  mainStory?: Character;
  memories?: EraMemory[]; // Personal memories specific to this era
  scenes?: any[]; // Scenes for this era
  worldId?: number; // Associated world ID
}
```

## 第 59 页

**文件路径：frontend/components/ChatWindow.tsx（部分）**

```typescript

import React, { useState, useEffect, useRef } from 'react';
import { Character, Message, CustomScenario, AppSettings, StoryNode, UserProfile, JournalEcho } from '../types';
import { geminiService } from '../services/gemini';
import { GenerateContentResponse } from '@google/genai';
import { Button } from './Button';

// --- Audio Decoding Helpers (Raw PCM) ---
function decode(base64: string) {
  const binaryString = atob(base64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}

async function decodeAudioData(
  data: Uint8Array,
  ctx: AudioContext,
  sampleRate: number,
  numChannels: number,
): Promise<AudioBuffer> {
  const dataInt16 = new Int16Array(data.buffer);
  const frameCount = dataInt16.length / numChannels;
  const buffer = ctx.createBuffer(numChannels, frameCount, sampleRate);

  for (let channel = 0; channel < numChannels; channel++) {
    const channelData = buffer.getChannelData(channel);
    for (let i = 0; i < frameCount; i++) {
      channelData[i] = dataInt16[i * numChannels + channel] / 32768.0;
    }
  }
  return buffer;
}

// --- Rich Text Parser ---
// Parses *actions* and (thoughts) for styled rendering
const RichTextRenderer: React.FC<{ text: string, colorAccent: string }> = ({ text, colorAccent }) => {
    const parts = text.split(/(\*[^*]+\*|\([^)]+\))/g);

    return (
        <span className="whitespace-pre-wrap">
            {parts.map((part, index) => {
                if (part.startsWith('*') && part.endsWith('*')) {
                    // Action: Italic, slightly faded
                    return (
                        <span key={index} className="italic opacity-70 text-sm mx-1 block my-1" style={{ color: '#e5e7eb' }}>
                            {part.slice(1, -1)}
                        </span>
                    );
                } else if (part.startsWith('(') && part.endsWith(')')) {
                    // Thought/Inner Monologue: Smaller, distinct color
                    return (
                        <span key={index} className="block text-xs my-1 font-serif opacity-80 tracking-wide" style={{ color: `${colorAccent}cc` }}>
                            {part}
                        </span>
                    );
                } else if (part.trim() === '') {
                    return null;
                } else {
                    // Standard dialogue
                    return <span key={index}>{part}</span>;
                }
            })}
        </span>
    );
};

interface ChatWindowProps {
  character: Character;
  customScenario?: CustomScenario;
  history: Message[];
  scenarioState?: { currentNodeId: string };
  settings: AppSettings;
  userProfile: UserProfile;
  activeJournalEntryId: string | null; 
  onUpdateHistory: (msgs: Message[]) => void;
  onUpdateScenarioState?: (nodeId: string) => void;
  onBack: (echo?: JournalEcho) => void; 
}
```

## 第 60 页

**文件路径：frontend/components/CharacterCard.tsx（部分）**

```typescript

import React from 'react';
import { Character } from '../types';

interface CharacterCardProps {
  character: Character;
  customAvatarUrl?: string;
  isGenerating: boolean;
  onSelect: (char: Character) => void;
  onGenerate: (char: Character) => void;
  onEdit?: (char: Character) => void;
  onDelete?: (char: Character) => void;
  isUserCreated?: boolean; // 是否是用户创建的角色
}

export const CharacterCard: React.FC<CharacterCardProps> = ({ 
  character, 
  customAvatarUrl,
  isGenerating,
  onSelect,
  onGenerate,
  onEdit,
  onDelete,
  isUserCreated = false
}) => {
  const displayImage = customAvatarUrl || character.avatarUrl;

  const handleGenerateClick = (e: React.MouseEvent) => {
    e.stopPropagation(); // Prevent card selection
    onGenerate(character);
  };

  const handleEditClick = (e: React.MouseEvent) => {
    e.stopPropagation(); // Prevent card selection
    if (onEdit) {
      onEdit(character);
    }
  };

  const handleDeleteClick = (e: React.MouseEvent) => {
    e.stopPropagation(); // Prevent card selection
    if (onDelete) {
      onDelete(character);
    }
  };

  return (
    <div 
      onClick={() => onSelect(character)}
      className="group relative h-96 w-full cursor-pointer overflow-hidden rounded-3xl border border-white/10 shadow-2xl transition-all duration-500 hover:scale-[1.02]"
      style={{
        '--card-accent': character.colorAccent
      } as React.CSSProperties}
    >
      {/* Background Image with Gradient Overlay */}
      <div className="absolute inset-0 bg-gray-900">
        <img 
          src={displayImage} 
          alt={character.name}
          className={`h-full w-full object-cover transition-transform duration-700 group-hover:scale-110 ${isGenerating ? 'opacity-50 blur-sm scale-105' : ''}`}
        />
        {isGenerating && (
          <div className="absolute inset-0 flex items-center justify-center">
             <div 
               className="w-12 h-12 border-4 border-t-transparent rounded-full animate-spin"
               style={{ borderColor: `${character.colorAccent} transparent transparent transparent` }}
             />
          </div>
        )}
        <div className="absolute inset-0 bg-gradient-to-t from-black/90 via-black/40 to-transparent opacity-80 transition-opacity group-hover:opacity-70" />
      </div>

      {/* Action Buttons (Top Right) */}
      <div className="absolute top-4 right-4 z-20 opacity-0 group-hover:opacity-100 transition-opacity duration-300 transform translate-y-2 group-hover:translate-y-0 flex flex-col gap-2">
        <button
          onClick={handleGenerateClick}
          disabled={isGenerating}
          className="bg-black/50 backdrop-blur-md text-white p-3 rounded-full border border-white/20 transition-all duration-300 shadow-lg hover:rotate-180 hover:bg-white/20"
          style={{ borderColor: character.colorAccent }}
          title="生成新形象"
        >
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
             <path strokeLinecap="round" strokeLinejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99" />
          </svg>
        </button>
        {isUserCreated && onEdit && (
          <button
            onClick={handleEditClick}
            className="bg-black/50 backdrop-blur-md text-white p-3 rounded-full border border-white/20 transition-all duration-300 shadow-lg hover:bg-blue-500/50"
            title="编辑角色"
          >
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
              <path strokeLinecap="round" strokeLinejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L6.832 19.82a4.5 4.5 0 0 1-1.897 1.13l-2.685.8.8-2.685a4.5 4.5 0 0 1 1.13-1.897L16.863 4.487Zm0 0L19.5 7.125" />
            </svg>
          </button>
        )}
        {isUserCreated && onDelete && (
          <button
            onClick={handleDeleteClick}
            className="bg-black/50 backdrop-blur-md text-white p-3 rounded-full border border-white/20 transition-all duration-300 shadow-lg hover:bg-red-500/50"
            title="删除角色"
          >
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
              <path strokeLinecap="round" strokeLinejoin="round" d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0" />
            </svg>
          </button>
        )}
      </div>

      {/* Content */}
      <div className="absolute bottom-0 left-0 w-full p-6 translate-y-2 transition-transform duration-300 group-hover:translate-y-0">
        <div 
          className="mb-2 inline-block rounded-full px-3 py-1 text-xs font-bold backdrop-blur-md border"
          style={{ 
            backgroundColor: `${character.colorAccent}33`, // 20% opacity
            color: character.colorAccent,
            borderColor: `${character.colorAccent}4D` // 30% opacity
          }}
        >
          {character.role}
        </div>
        <h3 className="mb-1 text-2xl font-bold text-white transition-colors"
            style={{ textShadow: `0 0 20px ${character.colorAccent}40` }}>
          {character.name}
        </h3>
        <p className="text-sm text-white/70 line-clamp-2 mb-4 group-hover:text-white/90">
          {character.bio}
        </p>
      </div>
      
      {/* Selection Ring effect */}
      <div 
        className="absolute inset-0 rounded-3xl border-2 opacity-0 transition-opacity duration-300 group-hover:opacity-100 pointer-events-none" 
        style={{ borderColor: character.colorAccent }}
      />
    </div>
  );
};

## 第 61 页

**文件路径：backend/src/main/java/com/heartsphere/controller/ResourceController.java**

```java

package com.heartsphere.controller;

import com.heartsphere.admin.dto.SystemResourceDTO;
import com.heartsphere.admin.service.SystemResourceService;
import com.heartsphere.security.UserDetailsImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * 资源控制器 - 供普通用户使用
 * 提供资源的只读访问，不需要管理员权限
 */
@CrossOrigin(origins = "*")
@RestController
@RequestMapping("/api/resources")
public class ResourceController {

    @Autowired
    private SystemResourceService systemResourceService;

    /**
     * 获取所有资源（按分类筛选）
     * 需要用户登录，但不需要管理员权限
     */
    @GetMapping
    public ResponseEntity<List<SystemResourceDTO>> getAllResources(
            @RequestParam(required = false) String category) {
        // 验证用户是否已登录
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null || authentication.getPrincipal() == null) {
            return ResponseEntity.status(401).build();
        }
        
        // 检查 principal 是否是 UserDetailsImpl 类型（普通用户）
        if (!(authentication.getPrincipal() instanceof UserDetailsImpl)) {
            return ResponseEntity.status(401).build();
        }
        
        // 根据分类获取资源
        if (category != null && !category.isEmpty()) {
            return ResponseEntity.ok(systemResourceService.getResourcesByCategory(category));
        }
        return ResponseEntity.ok(systemResourceService.getAllResources());
    }

    /**
     * 根据ID获取资源详情
     * 需要用户登录，但不需要管理员权限
     */
    @GetMapping("/{id}")
    public ResponseEntity<SystemResourceDTO> getResourceById(@PathVariable Long id) {
        // 验证用户是否已登录
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null || authentication.getPrincipal() == null) {
            return ResponseEntity.status(401).build();
        }
        
        // 检查 principal 是否是 UserDetailsImpl 类型（普通用户）
        if (!(authentication.getPrincipal() instanceof UserDetailsImpl)) {
            return ResponseEntity.status(401).build();
        }
        
        return ResponseEntity.ok(systemResourceService.getResourceById(id));
    }
}
```

## 第 62 页

**文件路径：backend/src/main/java/com/heartsphere/controller/WeChatController.java**

```java

package com.heartsphere.controller;

import com.heartsphere.service.WeChatAuthService;
import com.heartsphere.repository.WorldRepository;
import com.heartsphere.entity.World;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import com.heartsphere.utils.DTOMapper;

@CrossOrigin(origins = "*")
@RestController
@RequestMapping("/api/wechat")
public class WeChatController {

    @Autowired
    private WeChatAuthService weChatAuthService;

    @Autowired
    private WorldRepository worldRepository;

    /**
     * 生成微信登录二维码URL
     */
    @GetMapping("/qr-code")
    public ResponseEntity<?> getQrCodeUrl() {
        try {
            Map<String, String> result = weChatAuthService.generateQrCodeUrl();
            Map<String, Object> response = new HashMap<>();
            response.put("qrCodeUrl", result.get("qrCodeUrl"));
            response.put("state", result.get("state"));
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            return ResponseEntity.status(500).body(Map.of("error", "生成二维码失败: " + e.getMessage()));
        }
    }

    /**
     * 检查登录状态（前端轮询）
     */
    @GetMapping("/status/{state}")
    public ResponseEntity<?> checkStatus(@PathVariable String state) {
        try {
            Map<String, Object> status = weChatAuthService.checkLoginStatus(state);
            
            // 如果登录成功，添加世界列表
            if ("confirmed".equals(status.get("status"))) {
                Long userId = (Long) status.get("userId");
                List<World> userWorlds = worldRepository.findByUserId(userId);
                boolean isFirstLogin = userWorlds.isEmpty();
                status.put("isFirstLogin", isFirstLogin);
                status.put("worlds", userWorlds.stream()
                    .map(DTOMapper::toWorldDTO)
                    .collect(Collectors.toList()));
            }
            
            return ResponseEntity.ok(status);
        } catch (Exception e) {
            return ResponseEntity.status(500).body(Map.of("error", "检查状态失败: " + e.getMessage()));
        }
    }

    /**
     * 微信OAuth回调接口
     */
    @GetMapping("/callback")
    public ResponseEntity<?> callback(
            @RequestParam(required = false) String code,
            @RequestParam(required = false) String state) {
        try {
            if (code == null || state == null) {
                return ResponseEntity.badRequest().body("<html><body><h1>登录失败：缺少必要参数</h1></body></html>");
            }

            Map<String, Object> result = weChatAuthService.handleCallback(code, state);
            
            if ("confirmed".equals(result.get("status"))) {
                // 登录成功，返回成功页面（前端会通过轮询获取状态）
                return ResponseEntity.ok()
                    .header("Content-Type", "text/html;charset=UTF-8")
                    .body("<html><body><h1>登录成功！</h1><p>请关闭此页面，返回应用查看登录结果。</p><script>setTimeout(function(){window.close();}, 2000);</script></body></html>");
            } else {
                return ResponseEntity.badRequest()
                    .header("Content-Type", "text/html;charset=UTF-8")
                    .body("<html><body><h1>登录失败</h1><p>" + result.get("error") + "</p></body></html>");
            }
        } catch (Exception e) {
            return ResponseEntity.status(500)
                .header("Content-Type", "text/html;charset=UTF-8")
                .body("<html><body><h1>登录异常</h1><p>" + e.getMessage() + "</p></body></html>");
        }
    }

    /**
     * 获取微信AppID（兼容旧接口）
     */
    @GetMapping("/appid")
    public ResponseEntity<?> getWechatAppId() {
        Map<String, String> response = new HashMap<>();
        response.put("appid", weChatAuthService.getAppId());
        return ResponseEntity.ok(response);
    }
}
```

## 第 63 页

**文件路径：backend/src/main/java/com/heartsphere/service/WeChatAuthService.java（部分）**

```java

package com.heartsphere.service;

import com.heartsphere.entity.User;
import com.heartsphere.repository.UserRepository;
import com.heartsphere.utils.JwtUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Logger;

/**
 * 微信OAuth2.0扫码登录服务
 */
@Service
public class WeChatAuthService {

    private static final Logger logger = Logger.getLogger(WeChatAuthService.class.getName());

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private JwtUtils jwtUtils;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired
    private com.heartsphere.service.InitializationService initializationService;

    @Autowired
    private com.heartsphere.admin.service.SystemConfigService systemConfigService;

    // 从配置文件读取默认值（如果数据库中没有配置）
    @Value("${wechat.app-id:}")
    private String defaultAppId;

    @Value("${wechat.app-secret:}")
    private String defaultAppSecret;

    @Value("${wechat.redirect-uri:http://localhost:8081/api/wechat/callback}")
    private String defaultRedirectUri;

    private final RestTemplate restTemplate = new RestTemplate();

    /**
     * 获取微信AppID（优先从数据库读取，如果数据库没有则使用配置文件默认值）
     */
    public String getAppId() {
        String dbAppId = systemConfigService.getWechatAppId();
        return (dbAppId != null && !dbAppId.trim().isEmpty()) ? dbAppId : defaultAppId;
    }

    /**
     * 获取微信AppSecret（优先从数据库读取，如果数据库没有则使用配置文件默认值）
     */
    private String getAppSecret() {
        String dbAppSecret = systemConfigService.getWechatAppSecret();
        return (dbAppSecret != null && !dbAppSecret.trim().isEmpty()) ? dbAppSecret : defaultAppSecret;
    }

    /**
     * 获取微信回调地址（优先从数据库读取，如果数据库没有则使用配置文件默认值）
     */
    private String getRedirectUri() {
        String dbRedirectUri = systemConfigService.getWechatRedirectUri();
        return (dbRedirectUri != null && !dbRedirectUri.trim().isEmpty()) ? dbRedirectUri : defaultRedirectUri;
    }

    // 存储登录状态：state -> {status: 'waiting'|'scanned'|'confirmed'|'expired', openid: '', token: ''}
    private final Map<String, Map<String, Object>> loginStates = new ConcurrentHashMap<>();

    /**
     * 生成登录二维码URL和state
     */
    public Map<String, String> generateQrCodeUrl() {
        String appId = getAppId();
        String redirectUri = getRedirectUri();
        
        if (appId == null || appId.trim().isEmpty()) {
            throw new RuntimeException("微信AppID未配置，请在管理后台配置");
        }
        
        String state = UUID.randomUUID().toString().replace("-", "");
        String scope = "snsapi_login"; // 网站应用使用snsapi_login
        
        // 微信开放平台扫码登录URL
        String qrCodeUrl = String.format(
            "https://open.weixin.qq.com/connect/qrconnect?appid=%s&redirect_uri=%s&response_type=code&scope=%s&state=%s#wechat_redirect",
            appId,
            java.net.URLEncoder.encode(redirectUri, java.nio.charset.StandardCharsets.UTF_8),
            scope,
            state
        );

        // 初始化登录状态
        Map<String, Object> stateInfo = new HashMap<>();
        stateInfo.put("status", "waiting");
        stateInfo.put("createdAt", System.currentTimeMillis());
        loginStates.put(state, stateInfo);

        // 清理过期状态（30分钟）
        cleanupExpiredStates();

        logger.info("生成微信登录二维码，state: " + state);
        
        Map<String, String> result = new HashMap<>();
        result.put("qrCodeUrl", qrCodeUrl);
        result.put("state", state);
        return result;
    }
```

## 第 64 页

**文件路径：backend/src/main/java/com/heartsphere/service/WeChatAuthService.java（续）**

```java

    /**
     * 处理微信回调
     */
    public Map<String, Object> handleCallback(String code, String state) {
        logger.info("收到微信回调，code: " + code + ", state: " + state);

        if (code == null || state == null) {
            throw new RuntimeException("微信回调参数错误");
        }

        Map<String, Object> stateInfo = loginStates.get(state);
        if (stateInfo == null) {
            throw new RuntimeException("无效的state参数");
        }

        try {
            String appId = getAppId();
            String appSecret = getAppSecret();
            
            if (appId == null || appId.trim().isEmpty() || appSecret == null || appSecret.trim().isEmpty()) {
                throw new RuntimeException("微信配置未完成，请在管理后台配置AppID和AppSecret");
            }
            
            // 1. 通过code获取access_token
            String tokenUrl = String.format(
                "https://api.weixin.qq.com/sns/oauth2/access_token?appid=%s&secret=%s&code=%s&grant_type=authorization_code",
                appId, appSecret, code
            );

            Map<String, Object> tokenResponse = restTemplate.getForObject(tokenUrl, Map.class);
            if (tokenResponse == null || tokenResponse.containsKey("errcode")) {
                logger.severe("获取access_token失败: " + tokenResponse);
                stateInfo.put("status", "error");
                stateInfo.put("error", "获取access_token失败");
                return stateInfo;
            }

            String accessToken = (String) tokenResponse.get("access_token");
            String openid = (String) tokenResponse.get("openid");

            // 2. 通过access_token获取用户信息
            String userInfoUrl = String.format(
                "https://api.weixin.qq.com/sns/userinfo?access_token=%s&openid=%s",
                accessToken, openid
            );

            Map<String, Object> userInfoResponse = restTemplate.getForObject(userInfoUrl, Map.class);
            if (userInfoResponse == null || userInfoResponse.containsKey("errcode")) {
                logger.severe("获取用户信息失败: " + userInfoResponse);
                stateInfo.put("status", "error");
                stateInfo.put("error", "获取用户信息失败");
                return stateInfo;
            }

            String nickname = (String) userInfoResponse.get("nickname");
            String avatar = (String) userInfoResponse.get("headimgurl");
            // unionid可能为空，不需要使用

            // 3. 查找或创建用户
            User user = userRepository.findByWechatOpenid(openid)
                    .orElseGet(() -> {
                        User newUser = new User();
                        newUser.setWechatOpenid(openid);
                        newUser.setUsername("wx_" + openid.substring(0, Math.min(10, openid.length())));
                        newUser.setEmail(openid + "@wechat.com");
                        newUser.setPassword(passwordEncoder.encode(UUID.randomUUID().toString()));
                        newUser.setNickname(nickname != null ? nickname : "微信用户");
                        newUser.setAvatar(avatar);
                        newUser.setIsEnabled(true);
                        User saved = userRepository.save(newUser);
                        // 初始化用户数据
                        initializationService.initializeUserData(saved);
                        return saved;
                    });

            // 更新用户信息（如果微信信息有更新）
            boolean needUpdate = false;
            if (nickname != null && (user.getNickname() == null || !nickname.equals(user.getNickname()))) {
                user.setNickname(nickname);
                needUpdate = true;
            }
            if (avatar != null && (user.getAvatar() == null || !avatar.equals(user.getAvatar()))) {
                user.setAvatar(avatar);
                needUpdate = true;
            }
            if (needUpdate) {
                userRepository.save(user);
            }

            // 4. 生成JWT token
            String jwt = jwtUtils.generateJwtTokenFromUsername(user.getUsername());

            // 5. 更新状态
            stateInfo.put("status", "confirmed");
            stateInfo.put("openid", openid);
            stateInfo.put("token", jwt);
            stateInfo.put("userId", user.getId());
            stateInfo.put("username", user.getUsername());
            stateInfo.put("nickname", user.getNickname());
            stateInfo.put("avatar", user.getAvatar());

            logger.info("微信登录成功，用户ID: " + user.getId() + ", openid: " + openid);
            return stateInfo;

        } catch (Exception e) {
            logger.severe("处理微信回调异常: " + e.getMessage());
            stateInfo.put("status", "error");
            stateInfo.put("error", e.getMessage());
            return stateInfo;
        }
    }

    /**
     * 检查登录状态
     */
    public Map<String, Object> checkLoginStatus(String state) {
        Map<String, Object> stateInfo = loginStates.get(state);
        if (stateInfo == null) {
            Map<String, Object> result = new HashMap<>();
            result.put("status", "expired");
            return result;
        }

        // 检查是否过期（30分钟）
        long createdAt = (Long) stateInfo.get("createdAt");
        if (System.currentTimeMillis() - createdAt > 30 * 60 * 1000) {
            loginStates.remove(state);
            Map<String, Object> result = new HashMap<>();
            result.put("status", "expired");
            return result;
        }

        return stateInfo;
    }

    /**
     * 清理过期的登录状态
     */
    private void cleanupExpiredStates() {
        long expireTime = System.currentTimeMillis() - 30 * 60 * 1000; // 30分钟
        loginStates.entrySet().removeIf(entry -> {
            Map<String, Object> info = entry.getValue();
            long createdAt = (Long) info.get("createdAt");
            return createdAt < expireTime;
        });
    }
}
```

## 第 65 页

**文件路径：backend/src/main/java/com/heartsphere/service/InitializationService.java（部分）**

```java

package com.heartsphere.service;

import com.heartsphere.entity.User;
import com.heartsphere.entity.*;
import com.heartsphere.repository.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class InitializationService {

    @Autowired
    private WorldRepository worldRepository;

    @Autowired
    private EraRepository eraRepository;

    @Autowired
    private CharacterRepository characterRepository;

    @Autowired
    private ScriptRepository scriptRepository;

    @Transactional
    public void initializeUserData(User user) {
        // 1. 创建主世界
        World mainWorld = new World();
        mainWorld.setName("心域");
        mainWorld.setDescription("一个平行于现实的记忆与情感世界");
        mainWorld.setUser(user);
        mainWorld = worldRepository.save(mainWorld);

        // 2. 创建大学时代
        Era universityEra = new Era();
        universityEra.setName("大学时代");
        universityEra.setDescription("重返青涩的校园，在樱花飞舞的季节里，体验一段纯粹的青春恋曲。");
        universityEra.setImageUrl("https://picsum.photos/seed/university_era/1920/1080");
        universityEra.setWorld(mainWorld);
        universityEra.setUser(user);
        universityEra = eraRepository.save(universityEra);

        // 3. 创建赛博都市时代
        Era cyberpunkEra = new Era();
        cyberpunkEra.setName("赛博都市");
        cyberpunkEra.setDescription("在2077年的霓虹都市，数据与欲望交织。是成为传奇黑客，还是街头武士？");
        cyberpunkEra.setImageUrl("https://picsum.photos/seed/cyberpunk_era/1920/1080");
        cyberpunkEra.setWorld(mainWorld);
        cyberpunkEra.setUser(user);
        cyberpunkEra = eraRepository.save(cyberpunkEra);

        // 4. 创建心域诊所时代
        Era clinicEra = new Era();
        clinicEra.setName("心域诊所");
        clinicEra.setDescription("一个安全、温暖的港湾。在这里，你可以放下所有防备，与专业疗愈师倾诉心事。");
        clinicEra.setImageUrl("https://picsum.photos/seed/clinic_era/1920/1080");
        clinicEra.setWorld(mainWorld);
        clinicEra.setUser(user);
        clinicEra = eraRepository.save(clinicEra);

        // 5. 创建大学时代角色
        createUniversityEraCharacters(mainWorld, universityEra, user);

        // 6. 创建赛博都市时代角色
        createCyberpunkEraCharacters(mainWorld, cyberpunkEra, user);

        // 7. 创建心域诊所角色
        createClinicEraCharacters(mainWorld, clinicEra, user);
    }

    private void createUniversityEraCharacters(World world, Era era, User user) {
        // 林樱 - 文学社社长
        com.heartsphere.entity.Character sakura = new com.heartsphere.entity.Character();
        sakura.setName("林樱");
        sakura.setDescription("大学文学社社长，性格温柔内向，喜欢在图书馆看书，擅长写现代诗。");
        sakura.setAge(21);
        sakura.setGender("女");
        sakura.setRole("主角");
        sakura.setBio("大学文学社社长，喜欢在图书馆的角落安静地阅读和写诗。内心细腻敏感，对文学有着执着的追求，经常在校园的樱花树下寻找灵感。虽然表面温柔内向，但面对自己热爱的事物时会展现出坚定的一面。");
        sakura.setAvatarUrl("https://picsum.photos/seed/sakura/400/600");
        sakura.setBackgroundUrl("https://picsum.photos/seed/sakura_bg/1080/1920");
        sakura.setThemeColor("pink-500");
        sakura.setColorAccent("#ec4899");
        sakura.setFirstMessage("你好，我是林樱。很高兴能在这个充满书香的校园里认识你...");
        sakura.setSystemInstruction("你是大学文学社社长林樱，性格温柔内向，喜欢文学和诗歌。与用户交流时要保持优雅、细腻的语气，适当引用文学作品，展现出对文字的热爱。");
        sakura.setVoiceName("Aoede");
        sakura.setMbti("INFJ");
        sakura.setTags("文学社,诗歌,温柔,内向");
        sakura.setSpeechStyle("优雅、细腻，偶尔会引用诗歌或文学作品");
        sakura.setCatchphrases("文字是心灵的窗户,樱花飘落的瞬间，时间仿佛静止了,每一首诗都是一段未完成的故事");
        sakura.setSecrets("其实我偷偷写了一本关于校园生活的小说，但从未告诉过任何人");
        sakura.setMotivations("用文字记录生活的美好瞬间，希望能通过自己的作品触动他人的心灵");
        sakura.setRelationships("与夏然是室友和好朋友，对沈凯的技术能力有些好奇但又不敢主动接近");
        sakura.setWorld(world);
        sakura.setEra(era);
        sakura.setUser(user);
        characterRepository.save(sakura);
```

## 第 66 页

**文件路径：backend/src/main/java/com/heartsphere/utils/DTOMapper.java**

```java

package com.heartsphere.utils;

import com.heartsphere.dto.*;
import com.heartsphere.entity.Character;
import com.heartsphere.entity.Era;
import com.heartsphere.entity.JournalEntry;
import com.heartsphere.entity.Script;
import com.heartsphere.entity.User;
import com.heartsphere.entity.World;

public class DTOMapper {
    
    public static WorldDTO toWorldDTO(World world) {
        if (world == null) return null;
        return new WorldDTO(
            world.getId(),
            world.getName(),
            world.getDescription(),
            world.getUser() != null ? world.getUser().getId() : null,
            world.getCreatedAt(),
            world.getUpdatedAt()
        );
    }
    
    public static EraDTO toEraDTO(Era era) {
        if (era == null) return null;
        return new EraDTO(
            era.getId(),
            era.getName(),
            era.getDescription(),
            era.getStartYear(),
            era.getEndYear(),
            era.getImageUrl(),
            era.getWorld() != null ? era.getWorld().getId() : null,
            era.getUser() != null ? era.getUser().getId() : null,
            era.getCreatedAt(),
            era.getUpdatedAt()
        );
    }
    
    public static CharacterDTO toCharacterDTO(Character character) {
        if (character == null) return null;
        return new CharacterDTO(
            character.getId(),
            character.getName(),
            character.getDescription(),
            character.getAge(),
            character.getGender(),
            character.getRole(),
            character.getBio(),
            character.getAvatarUrl(),
            character.getBackgroundUrl(),
            character.getThemeColor(),
            character.getColorAccent(),
            character.getFirstMessage(),
            character.getSystemInstruction(),
            character.getVoiceName(),
            character.getMbti(),
            character.getTags(),
            character.getSpeechStyle(),
            character.getCatchphrases(),
            character.getSecrets(),
            character.getMotivations(),
            character.getRelationships(),
            character.getWorld() != null ? character.getWorld().getId() : null,
            character.getEra() != null ? character.getEra().getId() : null,
            character.getUser() != null ? character.getUser().getId() : null,
            character.getCreatedAt(),
            character.getUpdatedAt()
        );
    }
    
    public static UserDTO toUserDTO(User user) {
        if (user == null) return null;
        return new UserDTO(
            user.getId(),
            user.getUsername(),
            user.getEmail(),
            user.getNickname(),
            user.getAvatar(),
            user.getWechatOpenid(),
            user.getIsEnabled(),
            user.getCreatedAt(),
            user.getUpdatedAt()
        );
    }
    
    public static JournalEntryDTO toJournalEntryDTO(JournalEntry entry) {
        if (entry == null) return null;
        JournalEntryDTO dto = new JournalEntryDTO();
        dto.setId(entry.getId());
        dto.setTitle(entry.getTitle());
        dto.setContent(entry.getContent());
        dto.setTags(entry.getTags());
        dto.setEntryDate(entry.getEntryDate());
        dto.setTimestamp(entry.getTimestamp());
        dto.setWorldId(entry.getWorld() != null ? entry.getWorld().getId() : null);
        dto.setEraId(entry.getEra() != null ? entry.getEra().getId() : null);
        dto.setCharacterId(entry.getCharacter() != null ? entry.getCharacter().getId() : null);
        dto.setUserId(entry.getUser() != null ? entry.getUser().getId() : null);
        dto.setCreatedAt(entry.getCreatedAt());
        dto.setUpdatedAt(entry.getUpdatedAt());
        return dto;
    }
    
    public static ScriptDTO toScriptDTO(Script script) {
        if (script == null) return null;
        return new ScriptDTO(
            script.getId(),
            script.getTitle(),
            script.getContent(),
            script.getSceneCount(),
            script.getWorld() != null ? script.getWorld().getId() : null,
            script.getEra() != null ? script.getEra().getId() : null,
            script.getUser() != null ? script.getUser().getId() : null,
            script.getCreatedAt(),
            script.getUpdatedAt()
        );
    }
}
```

## 第 67 页

**文件路径：frontend/components/ScenarioBuilder.tsx（部分）**

```typescript

import React, { useState, useEffect } from 'react';
import { CustomScenario, StoryNode, StoryOption } from '../types';
import { Button } from './Button';
import { geminiService } from '../services/gemini';

interface ScenarioBuilderProps {
  initialScenario?: CustomScenario | null;
  onSave: (scenario: CustomScenario) => void;
  onCancel: () => void;
}

export const ScenarioBuilder: React.FC<ScenarioBuilderProps> = ({ initialScenario, onSave, onCancel }) => {
  const [title, setTitle] = useState('我的新剧本');
  const [description, setDescription] = useState('一段浪漫的冒险...');
  
  const [nodes, setNodes] = useState<Record<string, StoryNode>>({
    'start': { id: 'start', title: '开场场景', prompt: '描述一个阳光明媚的大学早晨。介绍樱向用户跑来的场景。', options: [] }
  });
  const [selectedNodeId, setSelectedNodeId] = useState<string>('start');
  
  const [showMagicModal, setShowMagicModal] = useState(false);
  const [magicPrompt, setMagicPrompt] = useState('');
  const [isMagicLoading, setIsMagicLoading] = useState(false);

  useEffect(() => {
    if (initialScenario) {
      setTitle(initialScenario.title);
      setDescription(initialScenario.description);
      setNodes(initialScenario.nodes || { 'start': { id: 'start', title: '开场场景', prompt: '描述一个阳光明媚的大学早晨。介绍樱向用户跑来的场景。', options: [] } });
      setSelectedNodeId(initialScenario.startNodeId || 'start');
    }
  }, [initialScenario]);

  const currentNode = nodes[selectedNodeId];

  const addNode = () => {
    const id = `node_${Date.now()}`;
    setNodes({ ...nodes, [id]: { id, title: '新场景', prompt: '描述接下来发生了什么...', options: [] } });
    setSelectedNodeId(id);
  };

  const updateNode = (field: keyof StoryNode, value: any) => {
    setNodes({ ...nodes, [selectedNodeId]: { ...nodes[selectedNodeId], [field]: value } });
  };

  const addOption = () => {
    const newOption: StoryOption = { id: `opt_${Date.now()}`, text: '新选项', nextNodeId: 'start' };
    updateNode('options', [...currentNode.options, newOption]);
  };

  const updateOption = (idx: number, field: keyof StoryOption, value: string) => {
    const newOpts = [...currentNode.options];
    newOpts[idx] = { ...newOpts[idx], [field]: value };
    updateNode('options', newOpts);
  };

  const deleteOption = (idx: number) => {
    const newOpts = [...currentNode.options];
    newOpts.splice(idx, 1);
    updateNode('options', newOpts);
  };

  const handleSave = () => {
    const scenario: CustomScenario = {
      id: initialScenario ? initialScenario.id : `scenario_${Date.now()}`,
      sceneId: initialScenario?.sceneId || '',
      title,
      description,
      nodes,
      startNodeId: Object.keys(nodes).includes(initialScenario?.startNodeId || 'start') ? (initialScenario?.startNodeId || 'start') : Object.keys(nodes)[0],
      author: initialScenario ? initialScenario.author : 'User',
    };
    onSave(scenario);
  };

  const handleMagicBuild = async () => {
    if (!magicPrompt.trim()) return;
    setIsMagicLoading(true);
    try {
      const scenario = await geminiService.generateScenarioFromPrompt(magicPrompt);
      if (scenario) {
        setTitle(scenario.title);
        setDescription(scenario.description);
        setNodes(scenario.nodes);
        setSelectedNodeId(scenario.startNodeId);
        setShowMagicModal(false);
      }
    } catch (e: any) {
      console.error(e);
      let errorMsg = "生成失败，请稍后重试。";
      if (e?.status === 429 || e?.message?.includes('429') || e?.message?.includes('quota') || e?.message?.includes('RESOURCE_EXHAUSTED')) {
          errorMsg = "API 配额已耗尽或请求过于频繁 (429)。请在设置中检查您的 API Key，或稍作休息后重试。";
      } else if (e?.message?.includes('API config missing')) {
          errorMsg = "未配置 API Key。请前往设置 > AI 模型，输入您选择的模型的 API Key。";
      }
      alert(errorMsg);
    } finally {
      setIsMagicLoading(false);
    }
  };
```

## 第 68 页

**文件路径：frontend/services/syncService.ts（部分）**

```typescript

import { GameState, JournalEntry, WorldScene, CustomScenario, Character } from '../types';
import { storageService } from './storage';
import { journalApi, worldApi, eraApi, characterApi, scriptApi } from './api';
import { WORLD_SCENES } from '../constants';

// Sync status types
export type SyncStatus = 'idle' | 'syncing' | 'synced' | 'error';

// Scene ID to World ID mapping
// This should be maintained to map frontend scene IDs to backend world IDs
// For built-in scenes, we'll use default mappings
// For custom scenes, we'll need to store mappings when they are created
export const SCENE_WORLD_MAPPING: { [sceneId: string]: number } = {
  'university_era': 1,  // 大学时代
  'cyberpunk_city': 2,  // 赛博都市
  'clinic': 3           // 心域诊所
};

// Custom scene mappings - this will be loaded from storage
export let customSceneMappings: { [sceneId: string]: number } = {};

export interface SyncLog {
  id: string;
  timestamp: number;
  type: 'sync_start' | 'sync_complete' | 'sync_error' | 'data_conflict';
  message: string;
  details?: any;
}

// Data types for server API (matching backend models)
export interface ServerJournalEntry {
  id: string;
  title: string;
  content: string;
  entryDate: string;
  worldId?: string;
  eraId?: string;
  characterId?: string;
  userId: string;
  createdAt: string;
  updatedAt: string;
}

export interface ServerWorld {
  id: string;
  name: string;
  description: string;
  userId: string;
  createdAt: string;
  updatedAt: string;
}

export interface ServerEra {
  id: string;
  name: string;
  description: string;
  startYear?: number;
  endYear?: number;
  worldId: string;
  userId: string;
  createdAt: string;
  updatedAt: string;
}

export interface ServerCharacter {
  id: string;
  name: string;
  description: string;
  age?: number;
  gender?: string;
  worldId: string;
  eraId?: string;
  userId: string;
  createdAt: string;
  updatedAt: string;
}

export const syncService = {
  // Current sync status
  syncStatus: 'idle' as SyncStatus,
  syncLogs: [] as SyncLog[],
  lastSyncTime: 0,
  syncInterval: 60000, // 1 minute
  syncIntervalId: null as NodeJS.Timeout | null,

  /**
   * Initialize the sync service and start periodic sync
   */
  init: async () => {
    console.log('Initializing sync service...');
    
    // Load custom scene mappings from storage service
    try {
      const storedMappings = await storageService.getCustomSceneMappings();
      customSceneMappings = storedMappings || {};
      console.log('Loaded custom scene mappings:', customSceneMappings);
    } catch (error) {
      console.error('Failed to load custom scene mappings:', error);
    }
    
    syncService.startPeriodicSync();
  },

  /**
   * Get world ID for a given scene ID
   */
  getWorldIdForSceneId: (sceneId: string): number => {
    // Check built-in scene mappings first
    if (SCENE_WORLD_MAPPING[sceneId]) {
      return SCENE_WORLD_MAPPING[sceneId];
    }
    
    // Then check custom scene mappings
    if (customSceneMappings[sceneId]) {
      return customSceneMappings[sceneId];
    }
    
    // Fallback to default world ID
    return 1;
  },

  /**
   * Save custom scene mapping
   */
  saveCustomSceneMapping: async (sceneId: string, worldId: number): Promise<void> => {
    customSceneMappings[sceneId] = worldId;
    await storageService.saveCustomSceneMappings(customSceneMappings);
    console.log('Saved custom scene mapping:', { sceneId, worldId });
  },
```

## 第 69 页

**文件路径：frontend/vite.config.ts**

```typescript

import path from 'path';
import { defineConfig, loadEnv } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig(({ mode }) => {
    const env = loadEnv(mode, '.', '');
    return {
      server: {
        port: 3000,
        host: '0.0.0.0',
      },
      plugins: [react()],
      define: {
        'process.env.API_KEY': JSON.stringify(env.GEMINI_API_KEY),
        'process.env.GEMINI_API_KEY': JSON.stringify(env.GEMINI_API_KEY)
      },
      resolve: {
        alias: {
          '@': path.resolve(__dirname, '.'),
        }
      },
      build: {
        rollupOptions: {
          input: {
            main: path.resolve(__dirname, 'index.html'),
            admin: path.resolve(__dirname, 'admin.html'),
          },
        },
      },
    };
});
```

## 第 70 页

**文件路径：backend/src/main/resources/application.yml**

```yaml

server:
  port: 8081

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/heartsphere?useUnicode=true&characterEncoding=utf8mb4&useSSL=false&serverTimezone=Asia/Shanghai
    username: root
    password: 123456
    driver-class-name: com.mysql.cj.jdbc.Driver
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQL8Dialect
        format_sql: true
        use_sql_comments: true
  mvc:
    pathmatch:
      matching-strategy: ANT_PATH_MATCHER
  http:
    encoding:
      charset: UTF-8
      enabled: true
      force: true
  jackson:
    default-property-inclusion: non_null
    serialization:
      write-dates-as-timestamps: false
      write-date-timestamps-as-nanoseconds: false
    mapper:
      accept-case-insensitive-enums: true
    time-zone: Asia/Shanghai
  servlet:
    multipart:
      max-file-size: 10MB
      max-request-size: 10MB
  # CORS 配置
  web:
    cors:
      allowed-origins: '*'
      allowed-methods: GET, POST, PUT, DELETE, OPTIONS
      allowed-headers: '*'
      allow-credentials: true
      exposed-headers: '*'

# JWT 配置
jwt:
  secret: ${JWT_SECRET:your-secret-key-change-in-production}
  expiration: 86400000 # 24小时
  refresh-expiration: 604800000 # 7天

# 微信登录配置（微信开放平台网站应用）
wechat:
  app-id: ${WECHAT_APP_ID:your-wechat-app-id}
  app-secret: ${WECHAT_APP_SECRET:your-wechat-app-secret}
  redirect-uri: ${WECHAT_REDIRECT_URI:http://localhost:8081/api/wechat/callback}

# 图片存储配置
app:
  image:
    storage:
      type: ${IMAGE_STORAGE_TYPE:local} # local, oss, s3
      local:
        path: ${IMAGE_STORAGE_PATH:./uploads/images}
      base-url: ${IMAGE_BASE_URL:http://localhost:8081/api/images}  # 注意：端口应与server.port一致，实际访问URL会自动添加 /files/ 前缀
      max-size: ${IMAGE_MAX_SIZE:10485760} # 10MB (单位：字节)

# 日志配置
logging:
  level:
    # 根日志级别
    root: INFO
    # 应用包日志级别
    com.heartsphere: DEBUG
    # Hibernate SQL日志
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
    org.hibernate.type: TRACE
    # Spring Data JPA日志
    org.springframework.data.jpa: DEBUG
    # 数据库连接池日志
    com.zaxxer.hikari: DEBUG
    # Spring Security日志
    org.springframework.security: DEBUG
    # HTTP请求日志
    org.springframework.web: DEBUG
    # SQL语句和参数日志
    org.hibernate.engine.internal: DEBUG
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
```

## 第 71 页

**文件路径：backend/src/main/java/com/heartsphere/HeartSphereApplication.java**

```java

package com.heartsphere;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class HeartSphereApplication {

    public static void main(String[] args) {
        SpringApplication.run(HeartSphereApplication.class, args);
    }

}
```

## 第 72 页

**文件路径：frontend/index.tsx**

```typescript

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

## 第 73 页

**文件路径：frontend/components/RealWorldScreen.tsx（部分）**

```typescript

import React, { useState, useRef, useEffect, MouseEvent, ChangeEvent, KeyboardEvent } from 'react';
import { JournalEntry } from '../types';
import { Button } from './Button';
import { geminiService } from '../services/gemini';
import { imageApi } from '../services/api';
import { getAllTemplates, JournalTemplate, getTemplateById } from '../utils/journalTemplates';

interface RealWorldScreenProps {
  entries: JournalEntry[];
  onAddEntry: (title: string, content: string, imageUrl?: string, insight?: string, tags?: string) => void;
  onUpdateEntry: (entry: JournalEntry) => void;
  onDeleteEntry: (id: string) => void;
  onExplore: (entry: JournalEntry) => void;
  onChatWithCharacter: (characterName: string) => void;
  onBack: () => void;
  onConsultMirror: (content: string, recentContext: string[]) => Promise<string | null>;
  autoGenerateImage: boolean;
  worldStyle?: string; // 当前世界风格
  userName?: string; // 用户名
}

export const RealWorldScreen: React.FC<RealWorldScreenProps> = ({ 
    entries, onAddEntry, onUpdateEntry, onDeleteEntry, onExplore, onChatWithCharacter, onBack, onConsultMirror, autoGenerateImage, worldStyle, userName 
}) => {
  // State for View Mode
  const [isCreating, setIsCreating] = useState(false);
  const [isEditing, setIsEditing] = useState(false);
  const [selectedEntry, setSelectedEntry] = useState<JournalEntry | null>(null);

  // Form State
  const [newTitle, setNewTitle] = useState('');
  const [newContent, setNewContent] = useState('');
  const [newTags, setNewTags] = useState<string[]>([]); // 标签数组
  const [tagInput, setTagInput] = useState(''); // 标签输入框
  const [uploadedImageUrl, setUploadedImageUrl] = useState<string | undefined>(undefined);
  const [mirrorInsight, setMirrorInsight] = useState<string | null>(null);
  const [isConsultingMirror, setIsConsultingMirror] = useState(false);
  const [isGeneratingImage, setIsGeneratingImage] = useState(false);
  const [isUploadingImage, setIsUploadingImage] = useState(false);
  const [uploadError, setUploadError] = useState('');
  
  // Daily Greeting State
  const [dailyGreeting, setDailyGreeting] = useState<{greeting: string, question?: string, prompt?: string} | null>(null);
  const [isLoadingGreeting, setIsLoadingGreeting] = useState(false);
  
  // Search & Filter State
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedTag, setSelectedTag] = useState<string | null>(null);
  
  const fileInputRef = useRef<HTMLInputElement>(null);
```

## 第 74 页

**文件路径：frontend/components/EntryPoint.tsx（部分）**

```typescript

import React, { useState } from 'react';
import { Button } from './Button';
import { WorldStyle, WORLD_STYLE_DESCRIPTIONS } from '../types';
import { LoginModal } from './LoginModal';

interface EntryPointProps {
  onNavigate: (screen: 'realWorld' | 'sceneSelection' | 'admin') => void;
  onOpenSettings: () => void;
  nickname: string;
  onSwitchToMobile: () => void;
  currentStyle: WorldStyle;
  onStyleChange: (style: WorldStyle) => void;
  onLoginSuccess?: (method: 'password' | 'wechat', identifier: string, isFirstLogin?: boolean, worlds?: any[]) => void;
  isGuest?: boolean;
  onGuestEnter?: (nickname: string) => void;
}

export const EntryPoint: React.FC<EntryPointProps> = ({ 
  onNavigate, 
  onOpenSettings, 
  nickname, 
  onSwitchToMobile,
  currentStyle,
  onStyleChange,
  onLoginSuccess,
  isGuest = false,
  onGuestEnter
}) => {
  const [showStyleSelector, setShowStyleSelector] = useState(false);
  const [showLoginModal, setShowLoginModal] = useState(false);
  const [showGuestInput, setShowGuestInput] = useState(false);
  const [guestNickname, setGuestNickname] = useState('');
  
  const styles: WorldStyle[] = ['anime', 'realistic', 'cyberpunk', 'fantasy', 'steampunk', 'minimalist', 'watercolor', 'oil-painting'];

  const handleGuestSubmit = () => {
    if (!guestNickname.trim()) return;
    if (onGuestEnter) {
      onGuestEnter(guestNickname.trim());
      setShowGuestInput(false);
      setGuestNickname('');
    }
  };
  
  return (
    <div className="relative h-full w-full flex flex-col items-center justify-center p-4 bg-slate-950 overflow-hidden">
      {/* Background Effect */}
      <div className="absolute inset-0 z-0">
        <div className="absolute inset-0 bg-gradient-to-t from-slate-950 via-slate-900/70 to-transparent" />
        <div className="absolute inset-0 bg-[radial-gradient(ellipse_at_center,_var(--tw-gradient-stops))] from-indigo-900/30 via-slate-900/50 to-slate-950" />
        <div className="absolute inset-0 bg-gradient-to-br from-indigo-500/5 via-transparent to-purple-500/5" />
      </div>

      {/* Admin Access (Top Left) */}
      <div className="absolute top-6 left-6 z-20">
        <button
          onClick={() => window.open('/admin.html', '_blank')}
          className="p-3 text-slate-400 hover:text-red-400 bg-slate-900/30 hover:bg-slate-800/50 rounded-full transition-all opacity-50 hover:opacity-100 group backdrop-blur-sm"
          title="系统管理 System Admin"
        >
           <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
             <path strokeLinecap="round" strokeLinejoin="round" d="M16.5 10.5V6.75a4.5 4.5 0 1 0-9 0v3.75m-.75 11.25h10.5a2.25 2.25 0 0 0 2.25-2.25v-6.75a2.25 2.25 0 0 0-2.25-2.25H6.75a2.25 2.25 0 0 0-2.25 2.25v6.75a2.25 2.25 0 0 0 2.25 2.25Z" />
           </svg>
        </button>
      </div>

      {/* Top Right Buttons Container */}
      <div className="absolute top-6 right-6 z-20 flex items-center gap-3">
        {/* Style Selector Button */}
        <div className="relative">
          <button
            onClick={() => setShowStyleSelector(!showStyleSelector)}
            className="p-3 text-slate-200 hover:text-white bg-slate-800/50 hover:bg-slate-700/60 backdrop-blur-md rounded-full transition-all border border-white/20 hover:border-white/40 shadow-lg hover:scale-105 flex items-center gap-2 px-4"
            title="世界风格 World Style"
          >
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
              <path strokeLinecap="round" strokeLinejoin="round" d="M9.53 16.122a3 3 0 0 0-5.78 1.128 2.25 2.25 0 0 1-2.4 2.245 4.5 4.5 0 0 0 8.4-2.245c0-.399-.078-.78-.22-1.128Zm0 0a15.998 15.998 0 0 0 3.388-1.62m-5.043-.025a15.994 15.994 0 0 1 1.622-3.395m3.42 3.42a15.995 15.995 0 0 0 4.764-4.648l3.876-5.814a1.151 1.151 0 0 0-1.597-1.597L14.146 6.32a15.996 15.996 0 0 0-4.649 4.763m3.42 3.42a6.776 6.776 0 0 0-3.42-3.42" />
            </svg>
            <span className="text-sm font-bold hidden sm:inline">{WORLD_STYLE_DESCRIPTIONS[currentStyle].name}</span>
          </button>
```

## 第 75 页

**文件路径：frontend/components/SettingsModal.tsx（部分）**

```typescript

import React, { useRef, useState } from 'react';
import { AppSettings, GameState, AIProvider, UserProfile } from '../types';
import { Button } from './Button';
import { storageService } from '../services/storage';
import { geminiService } from '../services/gemini';

interface SettingsModalProps {
  settings: AppSettings;
  gameState: GameState; // Pass full state for backup
  onSettingsChange: (newSettings: AppSettings) => void;
  onUpdateProfile?: (profile: UserProfile) => void; // New prop for profile updates
  onClose: () => void;
  onLogout: () => void;
  onBindAccount: () => void;
  onOpenRecycleBin?: () => void; // 打开回收站
  onOpenMembership?: () => void; // 打开会员管理
}

const Toggle: React.FC<{ label: string; description: string; enabled: boolean; onChange: (enabled: boolean) => void; }> = ({ label, description, enabled, onChange }) => (
  <div className="flex justify-between items-center p-4 rounded-lg bg-gray-800/50 border border-gray-700">
    <div>
      <h4 className="font-bold text-white">{label}</h4>
      <p className="text-xs text-gray-400">{description}</p>
    </div>
    <button onClick={() => onChange(!enabled)} className={`relative w-12 h-6 rounded-full transition-colors duration-300 focus:outline-none ${enabled ? 'bg-indigo-600' : 'bg-gray-600'}`}>
      <span className={`absolute left-1 top-1 w-4 h-4 bg-white rounded-full transition-transform duration-300 ${enabled ? 'transform translate-x-6' : ''}`} />
    </button>
  </div>
);

const ConfigInput: React.FC<{ label: string; value: string; onChange: (val: string) => void; placeholder: string; type?: string }> = ({ label, value, onChange, placeholder, type = 'text' }) => (
    <div className="flex flex-col gap-1">
        <label className="text-[10px] uppercase font-bold tracking-wider text-gray-500">{label}</label>
        <input 
            type={type}
            value={value}
            onChange={(e) => onChange(e.target.value)}
            placeholder={placeholder}
            className="w-full bg-gray-800 border border-gray-700 rounded px-3 py-2 text-xs text-white focus:border-pink-500 outline-none transition-colors"
        />
    </div>
);

const ConfigSection: React.FC<{ title: string; children: React.ReactNode }> = ({ title, children }) => (
    <div className="mb-4 last:mb-0">
        <h6 className="text-[10px] font-bold text-gray-400 border-b border-gray-700/50 pb-1 mb-2 uppercase tracking-widest">{title}</h6>
        <div className="space-y-3">
            {children}
        </div>
    </div>
);

export const SettingsModal: React.FC<SettingsModalProps> = ({ settings, gameState, onSettingsChange, onUpdateProfile, onClose, onLogout, onBindAccount, onOpenRecycleBin, onOpenMembership }) => {
  const fileInputRef = useRef<HTMLInputElement>(null);
  const avatarInputRef = useRef<HTMLInputElement>(null);
  const [backupMsg, setBackupMsg] = useState('');
  const [activeTab, setActiveTab] = useState<'general' | 'models' | 'backup'>('general');

  const handleExportBackup = () => {
    // We use the current in-memory state for export, which is the most up-to-date
    const data = storageService.exportBackup(gameState);
    if (!data) {
        alert("没有可备份的数据！");
        return;
    }
    
    // Create a Blob and trigger download
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    
    const date = new Date().toISOString().split('T')[0];
    link.download = `HeartSphere_Backup_${date}.json`;
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    
    setBackupMsg('备份已下载到您的设备。');
    setTimeout(() => setBackupMsg(''), 3000);
  };
```

## 第 76 页

**文件路径：frontend/components/EraConstructorModal.tsx（部分）**

```typescript

import React, { useState, useRef, useEffect } from 'react';
import { WorldScene } from '../types';
import { geminiService } from '../services/gemini';
import { imageApi, adminApi } from '../services/api';
import { Button } from './Button';
import { ResourcePicker } from './ResourcePicker';

interface EraConstructorModalProps {
  initialScene?: WorldScene | null; // Optional: If provided, we are editing
  onSave: (scene: WorldScene) => void;
  onDelete?: () => void;
  onClose: () => void;
  worldStyle?: string; // 当前世界风格
}

export const EraConstructorModal: React.FC<EraConstructorModalProps> = ({ initialScene, onSave, onDelete, onClose, worldStyle }) => {
  const [name, setName] = useState('');
  const [description, setDescription] = useState('');
  const [imageUrl, setImageUrl] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [isUploading, setIsUploading] = useState(false);
  const [error, setError] = useState('');
  const [showResourcePicker, setShowResourcePicker] = useState(false);
  
  // Image Source Mode: 'generate' | 'upload'
  const [imageMode, setImageMode] = useState<'generate' | 'upload'>('generate');
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [uploadedFile, setUploadedFile] = useState<File | null>(null);

  // Pre-fill data if editing
  useEffect(() => {
    if (initialScene) {
        setName(initialScene.name);
        setDescription(initialScene.description);
        setImageUrl(initialScene.imageUrl);
        // If it looks like a base64 upload (long string), default to upload mode, otherwise generate mode
        if (initialScene.imageUrl.startsWith('data:')) {
            setImageMode('upload');
        }
    }
  }, [initialScene]);

  const handleGetPrompt = async () => {
    if (!name || !description) {
        setError('请先填写时代名称和简介。');
        return;
    }
    const prompt = geminiService.constructEraCoverPrompt(name, description, worldStyle);
    try {
        await navigator.clipboard.writeText(prompt);
        alert('提示词已复制到剪贴板！请使用 Midjourney 或其他工具生成图片后上传。');
        setImageMode('upload');
    } catch (e) {
        alert('复制失败，请手动复制：\n' + prompt);
    }
  };

  const handleFileUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    // 先显示预览（base64）
    const reader = new FileReader();
    reader.onloadend = () => {
      const result = reader.result as string;
      setImageUrl(result); // 临时显示预览
    };
    reader.readAsDataURL(file);
    setUploadedFile(file);

    // 自动上传到服务器
    setIsUploading(true);
    setError('');
    
    try {
      const token = localStorage.getItem('auth_token');
      const result = await imageApi.uploadImage(file, 'era', token || undefined);
      
      if (result.success && result.url) {
        // 使用服务器返回的URL替换base64预览
        setImageUrl(result.url);
        console.log('图片上传成功:', result.url);
      } else {
        throw new Error(result.error || '上传失败');
      }
    } catch (err: any) {
      console.error('图片上传失败:', err);
      setError('图片上传失败: ' + (err.message || '未知错误') + '。将使用本地预览，保存时可能无法正常显示。');
      // 保持base64预览，但提示用户
    } finally {
      setIsUploading(false);
    }
  };
```

## 第 77 页

**文件路径：frontend/components/CharacterConstructorModal.tsx（部分）**

```typescript

import React, { useState, useEffect, useRef } from 'react';
import { Character, WorldScene } from '../types';
import { geminiService } from '../services/gemini';
import { imageApi, adminApi } from '../services/api';
import { Button } from './Button';
import { ResourcePicker } from './ResourcePicker';

interface CharacterConstructorModalProps {
  scene: WorldScene;
  initialCharacter?: Character | null; // Support editing
  onSave: (character: Character) => void;
  onClose: () => void;
  worldStyle?: string; // 当前世界风格
}

export const CharacterConstructorModal: React.FC<CharacterConstructorModalProps> = ({ scene, initialCharacter, onSave, onClose, worldStyle }) => {
  const [prompt, setPrompt] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');
  const [generatedCharacter, setGeneratedCharacter] = useState<Character | null>(null);
  
  // Edit Mode State
  const [activeTab, setActiveTab] = useState<'basic' | 'personality' | 'depth' | 'visuals'>('basic');
  
  // Upload states
  const [isUploadingAvatar, setIsUploadingAvatar] = useState(false);
  const [isUploadingBackground, setIsUploadingBackground] = useState(false);
  const [uploadError, setUploadError] = useState('');
  const [showAvatarResourcePicker, setShowAvatarResourcePicker] = useState(false);
  const [showBackgroundResourcePicker, setShowBackgroundResourcePicker] = useState(false);
  
  // Refs for uploads
  const avatarInputRef = useRef<HTMLInputElement>(null);
  const bgInputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    if (initialCharacter) {
      setGeneratedCharacter(initialCharacter);
    }
  }, [initialCharacter]);

  const handleGenerate = async () => {
    if (!prompt.trim()) {
        setError('请输入一个关于角色的想法。');
        return;
    }
    setError('');
    setIsLoading(true);
    setGeneratedCharacter(null);
    try {
        const newCharacter = await geminiService.generateCharacterFromPrompt(prompt, scene.name);
        if (newCharacter) {
            setGeneratedCharacter(newCharacter);
            setActiveTab('visuals'); // Focus on visuals after generation
        } else {
            setError('角色生成失败，请调整你的想法或稍后重试。');
        }
    } catch (e) {
        console.error(e);
        setError('角色生成时发生网络错误，请稍后重试。');
    } finally {
        setIsLoading(false);
    }
  };

  const updateCharacter = (field: keyof Character, value: any) => {
      if (!generatedCharacter) return;
      setGeneratedCharacter({ ...generatedCharacter, [field]: value });
  };
  
  const updateArrayField = (field: 'tags' | 'catchphrases', value: string) => {
      if (!generatedCharacter) return;
      // Split comma-separated string back to array
      const arr = value.split(/,|，/).map(s => s.trim()).filter(s => s);
      setGeneratedCharacter({ ...generatedCharacter, [field]: arr });
  };

  const handleSave = () => {
    if (generatedCharacter) {
        onSave(generatedCharacter);
    }
  };

  const handleFileUpload = async (type: 'avatar' | 'background', e: React.ChangeEvent<HTMLInputElement>) => {
      const file = e.target.files?.[0];
      if (!file || !generatedCharacter) return;

      // 先显示预览（base64）
      const reader = new FileReader();
      reader.onloadend = () => {
          if (type === 'avatar') {
              updateCharacter('avatarUrl', reader.result as string);
          } else {
              updateCharacter('backgroundUrl', reader.result as string);
          }
      };
      reader.readAsDataURL(file);

      // 自动上传到服务器
      if (type === 'avatar') {
          setIsUploadingAvatar(true);
      } else {
          setIsUploadingBackground(true);
      }
      setUploadError('');
      
      try {
          const token = localStorage.getItem('auth_token');
          const result = await imageApi.uploadImage(file, 'character', token || undefined);
          
          if (result.success && result.url) {
              // 使用服务器返回的URL替换base64预览
              if (type === 'avatar') {
                  updateCharacter('avatarUrl', result.url);
              } else {
                  updateCharacter('backgroundUrl', result.url);
              }
              console.log('图片上传成功:', result.url);
          } else {
              throw new Error(result.error || '上传失败');
          }
      } catch (err: any) {
          console.error('图片上传失败:', err);
          setUploadError('图片上传失败: ' + (err.message || '未知错误') + '。将使用本地预览。');
          // 保持base64预览
      } finally {
          if (type === 'avatar') {
              setIsUploadingAvatar(false);
          } else {
              setIsUploadingBackground(false);
          }
      }
  };
```

## 第 78 页

**文件路径：frontend/services/syncService.ts（续）**

```typescript

  /**
   * Sync all data between local storage and server
   */
  syncData: async (): Promise<void> => {
    if (syncService.syncStatus === 'syncing') {
      console.log('Sync already in progress');
      return;
    }

    const token = localStorage.getItem('auth_token');
    if (!token) {
      console.log('No authentication token found, skipping sync');
      return;
    }

    syncService.syncStatus = 'syncing';
    syncService.log('sync_start', 'Starting data sync...');

    try {
      // Load local state
      const localState = await storageService.loadState();
      if (!localState) {
        throw new Error('No local state found');
      }

      // Sync journal entries
      await syncService.syncJournalEntries(localState.journalEntries || [], token);

      // Sync worlds (custom scenes)
      await syncService.syncWorlds(localState.customScenes || [], token);

      // TODO: Sync other data types (eras, characters, etc.) as needed

      syncService.syncStatus = 'synced';
      syncService.lastSyncTime = Date.now();
      syncService.log('sync_complete', 'Data sync completed successfully');
    } catch (error) {
      syncService.syncStatus = 'error';
      syncService.log('sync_error', 'Data sync failed', error);
      console.error('Sync error:', error);
    }
  },

  /**
   * Sync journal entries between local and server
   */
  syncJournalEntries: async (localEntries: JournalEntry[], token: string): Promise<void> => {
    try {
      // Get server entries
      const serverEntries = await journalApi.getAllJournalEntries(token);
      
      // Convert server entries to local format
      const formattedServerEntries: JournalEntry[] = serverEntries.map((entry: any) => ({
        id: entry.id,
        title: entry.title,
        content: entry.content,
        timestamp: new Date(entry.entryDate).getTime(),
        imageUrl: entry.imageUrl
      }));

      // Create a map of server entries by ID
      const serverEntryMap = new Map(formattedServerEntries.map(entry => [entry.id, entry]));
      const localEntryMap = new Map(localEntries.map(entry => [entry.id, entry]));

      // Entries to add to server (local entries not on server)
      const entriesToAdd = localEntries.filter(entry => !serverEntryMap.has(entry.id));
      
      // Entries to update on server (local entries that have changed)
      const entriesToUpdate = localEntries.filter(entry => {
        const serverEntry = serverEntryMap.get(entry.id);
        return serverEntry && 
               (entry.title !== serverEntry.title || 
                entry.content !== serverEntry.content || 
                entry.timestamp !== serverEntry.timestamp);
      });

      // Entries to add to local (server entries not local)
      const entriesToLocalAdd = formattedServerEntries.filter(entry => !localEntryMap.has(entry.id));

      // Process additions to server
      for (const entry of entriesToAdd) {
        await journalApi.createJournalEntry(
          {
            title: entry.title,
            content: entry.content,
            entryDate: new Date(entry.timestamp).toISOString(),
            worldId: undefined, // TODO: Map local scene ID to server world ID
            eraId: undefined,
            characterId: undefined
          },
          token
        );
        console.log('Added journal entry to server:', entry.id);
      }

      // Process updates to server
      for (const entry of entriesToUpdate) {
        await journalApi.updateJournalEntry(
          entry.id,
          {
            title: entry.title,
            content: entry.content,
            entryDate: new Date(entry.timestamp).toISOString(),
            worldId: undefined,
            eraId: undefined,
            characterId: undefined
          },
          token
        );
        console.log('Updated journal entry on server:', entry.id);
      }

      // If there are new entries from server, update local state
      if (entriesToLocalAdd.length > 0) {
        // Load full state to update
        const currentState = await storageService.loadState();
        if (currentState) {
          await storageService.saveState({
            ...currentState,
            journalEntries: [...(currentState.journalEntries || []), ...entriesToLocalAdd]
          } as any);
          console.log('Added', entriesToLocalAdd.length, 'journal entries from server');
        }
      }

    } catch (error) {
      console.error('Error syncing journal entries:', error);
      throw error;
    }
  },
```

## 第 79 页

**文件路径：frontend/services/syncService.ts（续）**

```typescript

  /**
   * Sync worlds (custom scenes) between local and server
   */
  syncWorlds: async (localScenes: WorldScene[], token: string): Promise<void> => {
    try {
      // Get server worlds
      const serverWorlds = await worldApi.getAllWorlds(token);
      
      // Create a map of server worlds by name (since local IDs are different)
      const serverWorldMap = new Map(serverWorlds.map((world: any) => [world.name, world]));

      // Process local scenes to sync with server
      for (const scene of localScenes) {
        // Skip built-in scenes since they are predefined on both ends
        if (WORLD_SCENES.some(builtIn => builtIn.id === scene.id)) {
          continue;
        }
        
        const serverWorld = serverWorldMap.get(scene.name);
        
        if (serverWorld) {
          // Update existing world
          await worldApi.updateWorld(
            serverWorld.id,
            scene.name,
            scene.description,
            token
          );
          console.log('Updated world on server:', scene.name);
        } else {
          // Create new world
          await worldApi.createWorld(
            scene.name,
            scene.description,
            token
          );
          console.log('Created world on server:', scene.name);
        }
      }

    } catch (error) {
      console.error('Error syncing worlds:', error);
      throw error;
    }
  },

  /**
   * Handle local data changes and sync to server immediately
   */
  handleLocalDataChange: async (dataType: 'journal' | 'scene' | 'character' | 'scenario', data: any): Promise<void> => {
    if (!navigator.onLine) {
      console.log('Offline, will sync when online');
      return;
    }

    const token = localStorage.getItem('auth_token');
    if (!token) {
      console.log('No authentication token, skipping sync');
      return;
    }

    try {
      switch (dataType) {
        case 'journal':
          if (data.id) {
            // Update existing entry
            await journalApi.updateJournalEntry(
              data.id,
              {
                title: data.title,
                content: data.content,
                entryDate: new Date(data.timestamp).toISOString(),
                worldId: undefined,
                eraId: undefined,
                characterId: undefined
              },
              token
            );
          } else {
            // Create new entry
            await journalApi.createJournalEntry(
              {
                title: data.title,
                content: data.content,
                entryDate: new Date(data.timestamp).toISOString(),
                worldId: undefined,
                eraId: undefined,
                characterId: undefined
              },
              token
            );
          }
          break;
        case 'character':
          // 检查角色ID是否是数字（数据库ID）
          const characterId = data.id ? (typeof data.id === 'string' ? parseInt(data.id) : data.id) : null;
          const isNumericId = characterId !== null && !isNaN(characterId) && characterId > 0;
          
          console.log(`[syncService] 角色同步 - ID解析:`, {
            originalId: data.id,
            originalIdType: typeof data.id,
            parsedId: characterId,
            isNumericId: isNumericId,
            characterName: data.name
          });
          
          // 准备角色数据
          const characterData = {
            name: data.name,
            description: data.description || data.bio || '',
            age: data.age,
            gender: data.gender || data.role || '',
            role: data.role,
            bio: data.bio || data.description || '',
            avatarUrl: data.avatarUrl,
            backgroundUrl: data.backgroundUrl,
            themeColor: data.themeColor,
            colorAccent: data.colorAccent,
            firstMessage: data.firstMessage,
            systemInstruction: data.systemInstruction,
            voiceName: data.voiceName,
            mbti: data.mbti,
            tags: data.tags ? (typeof data.tags === 'string' ? data.tags : (Array.isArray(data.tags) ? data.tags.join(',') : null)) : null,
            speechStyle: data.speechStyle,
            catchphrases: data.catchphrases ? (typeof data.catchphrases === 'string' ? data.catchphrases : (Array.isArray(data.catchphrases) ? data.catchphrases.join(',') : null)) : null,
            secrets: data.secrets,
            motivations: data.motivations,
            relationships: data.relationships,
            worldId: data.worldId || 1,
            eraId: data.eraId || null
          };
          
          if (isNumericId) {
            // 更新现有角色（只更新属于当前用户的角色）
            try {
              await characterApi.updateCharacter(characterId, characterData, token);
              console.log(`[syncService] 角色更新成功: ID=${characterId}`);
            } catch (error: any) {
              // 更新失败，给出明确的错误提示
              const errorMsg = error.message || '';
              let errorReason = '未知错误';
              
              if (errorMsg.includes('403') || errorMsg.includes('权限拒绝')) {
                errorReason = '该角色不属于当前用户，无法更新。请确保您正在编辑自己的角色。';
              } else if (errorMsg.includes('404') || errorMsg.includes('not found')) {
                errorReason = '角色不存在或已被删除。';
              } else {
                errorReason = errorMsg || '更新失败，请稍后重试。';
              }
              
              console.error(`[syncService] 角色更新失败: ID=${characterId}, 原因: ${errorReason}`);
              throw new Error(`角色更新失败: ${errorReason}`);
            }
          } else {
            // 创建新角色（非数字ID表示是新创建的角色）
            const createdCharacter = await characterApi.createCharacter(characterData, token);
            console.log(`[syncService] 新角色创建成功: ID=${createdCharacter.id}`);
          }
          break;
```

## 第 80 页

**文件路径：frontend/services/syncService.ts（续）**

```typescript

        case 'scenario':
          if (data.id) {
            // Update existing scenario/script
            await scriptApi.updateScript(
              parseInt(data.id),
              {
                title: data.title,
                content: JSON.stringify(data),
                sceneCount: Object.keys(data.nodes || {}).length,
                worldId: data.sceneId ? syncService.getWorldIdForSceneId(data.sceneId) : 1, // Use proper mapping
                eraId: 1 // Default era ID
              },
              token
            );
          } else {
            // Create new scenario/script
            await scriptApi.createScript(
              {
                title: data.title,
                content: JSON.stringify(data),
                sceneCount: Object.keys(data.nodes || {}).length,
                worldId: data.sceneId ? syncService.getWorldIdForSceneId(data.sceneId) : 1, // Use proper mapping
                eraId: 1 // Default era ID
              },
              token
            );
          }
          break;
        // TODO: Handle scene data type
      }
    } catch (error) {
      console.error('Error syncing data change:', error);
    }
  },

  /**
   * Manually trigger a sync
   */
  manualSync: async (): Promise<void> => {
    await syncService.syncData();
  }
};

// Listen for online/offline events
window.addEventListener('online', () => {
  console.log('Network online, starting sync');
  syncService.syncData();
});

window.addEventListener('offline', () => {
  console.log('Network offline, stopping sync');
});
```

## 第 81 页

**文件路径：frontend/components/LoginModal.tsx（部分）**

```typescript

import React, { useState, useEffect } from 'react';
import { Button } from './Button';
import { authApi, wechatApi } from '../services/api';
import QRCode from 'qrcode';

interface LoginModalProps {
  onLoginSuccess: (method: 'password' | 'wechat', identifier: string, isFirstLogin?: boolean, worlds?: any[]) => void;
  onCancel: () => void;
  initialNickname?: string; // 从访客状态传入的昵称
}

export const LoginModal: React.FC<LoginModalProps> = ({ onLoginSuccess, onCancel, initialNickname }) => {
  // 如果有初始昵称，默认显示注册标签
  const [activeTab, setActiveTab] = useState<'login' | 'register' | 'wechat'>(initialNickname ? 'register' : 'login');
  
  // Login State
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  // Register State
  const [registerUsername, setRegisterUsername] = useState('');
  const [registerNickname, setRegisterNickname] = useState(initialNickname || ''); // 昵称（在心域中的称呼）
  const [registerEmail, setRegisterEmail] = useState('');
  const [registerPassword, setRegisterPassword] = useState('');
  const [registerConfirmPassword, setRegisterConfirmPassword] = useState('');
  const [registerInviteCode, setRegisterInviteCode] = useState(''); // 邀请码
  const [registerError, setRegisterError] = useState('');
  const [isRegistering, setIsRegistering] = useState(false);
  const [inviteCodeRequired, setInviteCodeRequired] = useState(false); // 是否需要邀请码

  // 当initialNickname变化时，更新昵称字段，并自动切换到注册标签
  useEffect(() => {
    if (initialNickname) {
      setRegisterNickname(initialNickname);
      setActiveTab('register');
    }
  }, [initialNickname]);

  // WeChat State
  const [qrStatus, setQrStatus] = useState<'loading' | 'ready' | 'scanned' | 'confirmed' | 'expired'>('loading');
  const [qrCodeUrl, setQrCodeUrl] = useState('');
  const [qrCodeDataUrl, setQrCodeDataUrl] = useState(''); // 二维码图片数据URL
  const [qrState, setQrState] = useState('');
  const [pollingInterval, setPollingInterval] = useState<NodeJS.Timeout | null>(null);

  // 检查是否需要邀请码
  useEffect(() => {
    const checkInviteCodeRequired = async () => {
      try {
        const response = await authApi.isInviteCodeRequired();
        setInviteCodeRequired(response.inviteCodeRequired);
      } catch (err) {
        console.error('检查邀请码要求失败:', err);
        setInviteCodeRequired(false); // 默认不需要
      }
    };
    checkInviteCodeRequired();
  }, []);

  // 加载微信二维码
  useEffect(() => {
    if (activeTab === 'wechat') {
        setQrStatus('loading');
        // 生成二维码
        const loadQrCode = async () => {
            try {
                const response = await wechatApi.getQrCodeUrl();
                setQrCodeUrl(response.qrCodeUrl);
                setQrState(response.state);
                
                // 生成二维码图片
                try {
                    const dataUrl = await QRCode.toDataURL(response.qrCodeUrl, {
                        width: 256,
                        margin: 2,
                        color: {
                            dark: '#000000',
                            light: '#FFFFFF'
                        }
                    });
                    setQrCodeDataUrl(dataUrl);
                    setQrStatus('ready');
                } catch (qrErr) {
                    console.error('生成二维码图片失败:', qrErr);
                    setQrStatus('ready'); // 即使生成图片失败，也显示ready状态
                }
                
                // 开始轮询登录状态
                startPolling(response.state);
            } catch (err) {
                console.error('获取微信二维码失败:', err);
                setQrStatus('expired');
            }
        };
        loadQrCode();
        
        // 清理函数：切换标签页时停止轮询
        return () => {
            if (pollingInterval) {
                clearInterval(pollingInterval);
                setPollingInterval(null);
            }
        };
    } else {
        // 切换标签页时停止轮询
        if (pollingInterval) {
            clearInterval(pollingInterval);
            setPollingInterval(null);
        }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [activeTab]);

  // 轮询登录状态
  const startPolling = (state: string) => {
    if (pollingInterval) {
        clearInterval(pollingInterval);
    }
    
    const interval = setInterval(async () => {
        try {
            const status = await wechatApi.checkStatus(state);
            
            if (status.status === 'confirmed') {
                // 登录成功
                clearInterval(interval);
                setPollingInterval(null);
                setQrStatus('confirmed');
                
                // 保存token
                if (status.token) {
                    localStorage.setItem('auth_token', status.token);
                }
                
                // 调用登录成功回调
                onLoginSuccess('wechat', status.username || 'wechat_user', status.isFirstLogin, status.worlds);
            } else if (status.status === 'scanned') {
                setQrStatus('scanned');
            } else if (status.status === 'expired' || status.status === 'error') {
                clearInterval(interval);
                setPollingInterval(null);
                setQrStatus('expired');
            }
        } catch (err) {
            console.error('检查登录状态失败:', err);
        }
    }, 2000); // 每2秒轮询一次
    
    setPollingInterval(interval);
  };
```

## 第 82 页

**文件路径：frontend/components/MembershipModal.tsx（部分）**

```typescript

import React, { useState, useEffect } from 'react';
import { membershipApi, paymentApi } from '../services/api';
import { SubscriptionPlan, PaymentOrder } from '../types';
import './MembershipModal.css';

interface MembershipModalProps {
  isOpen: boolean;
  onClose: () => void;
  token: string;
  currentMembership?: {
    planType: string;
    billingCycle: string;
    status: string;
    endDate: string | null;
    autoRenew: boolean;
    nextRenewalDate: string | null;
    currentPoints: number;
  };
}

export const MembershipModal: React.FC<MembershipModalProps> = ({
  isOpen,
  onClose,
  token,
  currentMembership,
}) => {
  const [activeTab, setActiveTab] = useState<'continuous_yearly' | 'continuous_monthly' | 'monthly'>('continuous_yearly');
  const [plans, setPlans] = useState<SubscriptionPlan[]>([]);
  const [loading, setLoading] = useState(false);
  const [selectedPlan, setSelectedPlan] = useState<SubscriptionPlan | null>(null);
  const [showPaymentModal, setShowPaymentModal] = useState(false);
  const [paymentOrder, setPaymentOrder] = useState<PaymentOrder | null>(null);
  const [paymentType, setPaymentType] = useState<'wechat' | 'alipay'>('wechat');

  useEffect(() => {
    if (isOpen) {
      loadPlans();
    }
  }, [isOpen, activeTab]);

  const loadPlans = async () => {
    try {
      const data = await membershipApi.getPlans(activeTab, token);
      setPlans(data);
    } catch (error) {
      console.error('加载订阅计划失败:', error);
    }
  };

  const handlePurchase = async (plan: SubscriptionPlan) => {
    if (!token) {
      alert('请先登录');
      return;
    }
    
    setSelectedPlan(plan);
    setShowPaymentModal(true);
    setLoading(true);

    try {
      console.log('创建支付订单，planId:', plan.id, 'paymentType:', paymentType, 'token存在:', !!token);
      const order = await paymentApi.createOrder(plan.id, paymentType, token);
      setPaymentOrder(order);
    } catch (error) {
      console.error('创建支付订单失败:', error);
      alert('创建支付订单失败，请重试。如果问题持续，请检查是否已登录。');
    } finally {
      setLoading(false);
    }
  };

  const handlePaymentTypeChange = async (type: 'wechat' | 'alipay') => {
    if (!selectedPlan) return;
    
    setPaymentType(type);
    setLoading(true);

    try {
      const order = await paymentApi.createOrder(selectedPlan.id, type, token);
      setPaymentOrder(order);
    } catch (error) {
      console.error('创建支付订单失败:', error);
      alert('创建支付订单失败，请重试');
    } finally {
      setLoading(false);
    }
  };

  const checkOrderStatus = async () => {
    if (!paymentOrder) return;

    try {
      const order = await paymentApi.getOrder(paymentOrder.orderNo, token);
      if (order.status === 'paid') {
        alert('支付成功！会员已激活');
        setShowPaymentModal(false);
        onClose();
        window.location.reload();
      } else {
        setPaymentOrder(order);
      }
    } catch (error) {
      console.error('查询订单状态失败:', error);
    }
  };

  if (!isOpen) return null;

  const formatPrice = (price: number) => {
    return `¥${price.toFixed(2)}`;
  };

  const formatDate = (dateStr: string | null) => {
    if (!dateStr) return '';
    return new Date(dateStr).toLocaleString('zh-CN', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  const parseFeatures = (featuresStr: string): string[] => {
    try {
      return JSON.parse(featuresStr);
    } catch {
      return [];
    }
  };
```

## 第 83 页

**文件路径：frontend/components/RecycleBinModal.tsx（部分）**

```typescript

import React, { useState, useEffect } from 'react';
import { recycleBinApi } from '../services/api';
import { Button } from './Button';

interface RecycleBinModalProps {
  token: string;
  onClose: () => void;
  onRestore?: () => void; // 恢复后刷新数据
}

export const RecycleBinModal: React.FC<RecycleBinModalProps> = ({ token, onClose, onRestore }) => {
  const [recycleBin, setRecycleBin] = useState<{
    characters: any[];
    worlds: any[];
    eras: any[];
    scripts: any[];
  } | null>(null);
  const [loading, setLoading] = useState(true);
  const [activeTab, setActiveTab] = useState<'characters' | 'worlds' | 'eras' | 'scripts'>('characters');

  useEffect(() => {
    loadRecycleBin();
  }, []);

  const loadRecycleBin = async () => {
    try {
      setLoading(true);
      const data = await recycleBinApi.getRecycleBin(token);
      setRecycleBin(data);
    } catch (error) {
      console.error('加载回收站失败:', error);
      alert('加载回收站失败');
    } finally {
      setLoading(false);
    }
  };

  const handleRestore = async (type: 'characters' | 'worlds' | 'eras' | 'scripts', id: number) => {
    try {
      switch (type) {
        case 'characters':
          await recycleBinApi.restoreCharacter(id, token);
          break;
        case 'worlds':
          await recycleBinApi.restoreWorld(id, token);
          break;
        case 'eras':
          await recycleBinApi.restoreEra(id, token);
          break;
        case 'scripts':
          await recycleBinApi.restoreScript(id, token);
          break;
      }
      alert('恢复成功');
      await loadRecycleBin();
      if (onRestore) {
        onRestore();
      }
    } catch (error) {
      console.error('恢复失败:', error);
      alert('恢复失败');
    }
  };

  const handlePermanentlyDelete = async (type: 'characters' | 'worlds' | 'eras' | 'scripts', id: number, name: string) => {
    if (!confirm(`确定要永久删除 "${name}" 吗？此操作不可恢复！`)) {
      return;
    }

    try {
      switch (type) {
        case 'characters':
          await recycleBinApi.permanentlyDeleteCharacter(id, token);
          break;
        case 'worlds':
          await recycleBinApi.permanentlyDeleteWorld(id, token);
          break;
        case 'eras':
          await recycleBinApi.permanentlyDeleteEra(id, token);
          break;
        case 'scripts':
          await recycleBinApi.permanentlyDeleteScript(id, token);
          break;
      }
      alert('永久删除成功');
      await loadRecycleBin();
    } catch (error) {
      console.error('永久删除失败:', error);
      alert('永久删除失败');
    }
  };

  const getCurrentItems = () => {
    if (!recycleBin) return [];
    switch (activeTab) {
      case 'characters':
        return recycleBin.characters;
      case 'worlds':
        return recycleBin.worlds;
      case 'eras':
        return recycleBin.eras;
      case 'scripts':
        return recycleBin.scripts;
      default:
        return [];
    }
  };

  const getItemName = (item: any) => {
    return item.name || item.title || '未命名';
  };

  const getItemDescription = (item: any) => {
    return item.description || item.bio || '';
  };

  const totalCount = recycleBin
    ? recycleBin.characters.length + recycleBin.worlds.length + recycleBin.eras.length + recycleBin.scripts.length
    : 0;
```

## 第 84 页

**文件路径：frontend/components/ResourcePicker.tsx**

```typescript

import React, { useState, useEffect } from 'react';
import { resourceApi } from '../services/api';

interface ResourcePickerProps {
  category: 'avatar' | 'character' | 'era' | 'scenario' | 'journal' | 'general';
  onSelect: (url: string) => void;
  onClose: () => void;
  currentUrl?: string;
  token?: string;
}

export const ResourcePicker: React.FC<ResourcePickerProps> = ({ 
  category, 
  onSelect, 
  onClose, 
  currentUrl,
  token 
}) => {
  const [resources, setResources] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);
  const [selectedUrl, setSelectedUrl] = useState<string | null>(currentUrl || null);

  useEffect(() => {
    const loadResources = async () => {
      if (!token) {
        setLoading(false);
        return;
      }
      try {
        const data = await resourceApi.getAll(category, token);
        setResources(data);
      } catch (err) {
        console.error('加载资源失败:', err);
      } finally {
        setLoading(false);
      }
    };
    loadResources();
  }, [category, token]);

  const handleSelect = (url: string) => {
    setSelectedUrl(url);
    onSelect(url);
    onClose();
  };

  return (
    <div className="fixed inset-0 z-[200] flex items-center justify-center bg-black/80 backdrop-blur-md p-4">
      <div className="bg-slate-900 border border-indigo-500/30 rounded-2xl w-full max-w-4xl max-h-[80vh] flex flex-col shadow-2xl">
        {/* Header */}
        <div className="p-6 border-b border-slate-800 flex items-center justify-between">
          <h2 className="text-xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-pink-400 to-indigo-400">
            选择预置资源
          </h2>
          <button
            onClick={onClose}
            className="text-slate-500 hover:text-white transition-colors"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>

        {/* Content */}
        <div className="flex-1 overflow-y-auto p-6 custom-scrollbar">
          {loading ? (
            <div className="flex items-center justify-center py-12">
              <div className="w-8 h-8 border-4 border-slate-200 border-t-indigo-500 rounded-full animate-spin" />
            </div>
          ) : resources.length === 0 ? (
            <div className="text-center py-12 text-slate-500">
              <p>暂无预置资源</p>
              <p className="text-sm mt-2">请在管理后台上传资源</p>
            </div>
          ) : (
            <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
              {resources.map((resource) => (
                <div
                  key={resource.id}
                  onClick={() => handleSelect(resource.url)}
                  className={`relative group cursor-pointer rounded-lg overflow-hidden border-2 transition-all ${
                    selectedUrl === resource.url
                      ? 'border-indigo-500 ring-2 ring-indigo-500/50'
                      : 'border-slate-700 hover:border-indigo-400'
                  }`}
                >
                  <div className="aspect-square bg-slate-800 flex items-center justify-center">
                    <img
                      src={resource.url}
                      alt={resource.name}
                      className="w-full h-full object-cover"
                      onError={(e) => {
                        (e.target as HTMLImageElement).src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="100" height="100"%3E%3Crect fill="%23334155" width="100" height="100"/%3E%3Ctext fill="%2394a3b8" x="50" y="50" text-anchor="middle" dy=".3em" font-size="12"%3E图片加载失败%3C/text%3E%3C/svg%3E';
                      }}
                    />
                  </div>
                  {selectedUrl === resource.url && (
                    <div className="absolute inset-0 bg-indigo-500/20 flex items-center justify-center">
                      <div className="w-8 h-8 bg-indigo-500 rounded-full flex items-center justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={3} d="M5 13l4 4L19 7" />
                        </svg>
                      </div>
                    </div>
                  )}
                  <div className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/80 to-transparent p-2">
                    <p className="text-xs text-white font-medium truncate">{resource.name}</p>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>

        {/* Footer */}
        <div className="p-4 border-t border-slate-800 flex justify-end">
          <button
            onClick={onClose}
            className="px-4 py-2 bg-slate-700 hover:bg-slate-600 text-white rounded-lg transition-colors"
          >
            取消
          </button>
        </div>
      </div>
    </div>
  );
};
```

## 第 85 页

**文件路径：frontend/utils/journalTemplates.ts**

```typescript

/**
 * 思维模版库 - 类似于印象笔记的模版功能
 * 提供快捷模版，解决"不知写什么"的痛点
 */

export interface JournalTemplate {
  id: string;
  name: string;
  title: string;
  content: string;
  tags: string;
  description: string;
  icon: string;
}

export const JOURNAL_TEMPLATES: JournalTemplate[] = [
  {
    id: 'morning-intention',
    name: '晨间意图',
    title: '晨间意图',
    content: `今天,我想要专注于...

我期待...

让我感到兴奋的是...

今天最重要的三件事：
1. 
2. 
3. 

今天我想培养的心态是...`,
    tags: '#晨间,#意图,#计划',
    description: '设定一天的意图和重点',
    icon: '🌅'
  },
  {
    id: 'evening-review',
    name: '晚间回顾',
    title: '晚间回顾',
    content: `今天最让我感激的三件事：
1. 
2. 
3. 

今天学到的一课：

今天让我感到挑战的是...

明天我想改进的是...

今天最美好的瞬间：`,
    tags: '#晚间,#回顾,#感恩',
    description: '回顾一天的收获与成长',
    icon: '🌙'
  },
  {
    id: 'inspiration-flash',
    name: '灵感闪念',
    title: '灵感闪念',
    content: `突然想到...

这个想法让我感到...

可能的行动方向：

相关的资源或人：

下一步：`,
    tags: '#灵感,#闪念,#创意',
    description: '捕捉转瞬即逝的灵感',
    icon: '💡'
  },
  {
    id: 'dream-journal',
    name: '梦境记录',
    title: '梦境记录',
    content: `梦境主题：

主要场景：

出现的角色：

情感感受：

可能的象征意义：

醒来时的感觉：`,
    tags: '#梦境,#潜意识,#探索',
    description: '记录和探索梦境',
    icon: '🌙'
  },
  {
    id: 'gratitude',
    name: '感恩日记',
    title: '感恩日记',
    content: `今天我要感谢...

这个人/事让我感到...

这份感恩带给我...

我想如何表达这份感恩：

感恩让我意识到...`,
    tags: '#感恩,#正念,#积极',
    description: '培养感恩心态',
    icon: '🙏'
  },
  {
    id: 'reflection',
    name: '深度反思',
    title: '深度反思',
    content: `当前的状态：

让我感到困惑的是...

我真正想要的是...

阻碍我的是...

我可以做的是...

新的洞察：`,
    tags: '#反思,#深度,#成长',
    description: '深入思考与自我探索',
    icon: '🔍'
  },
  {
    id: 'emotion-tracking',
    name: '情绪追踪',
    title: '情绪追踪',
    content: `此刻的情绪：

情绪的强度（1-10）：

触发这个情绪的是...

这个情绪想告诉我什么：

我需要的是...

如何照顾自己的情绪：`,
    tags: '#情绪,#觉察,#自我关怀',
    description: '追踪和理解情绪',
    icon: '💭'
  },
  {
    id: 'goal-setting',
    name: '目标设定',
    title: '目标设定',
    content: `我的目标：

为什么这个目标重要：

实现这个目标需要：

可能的障碍：

克服障碍的策略：

第一步行动：`,
    tags: '#目标,#计划,#行动',
    description: '设定和规划目标',
    icon: '🎯'
  }
];

/**
 * 根据ID获取模版
 */
export function getTemplateById(id: string): JournalTemplate | undefined {
  return JOURNAL_TEMPLATES.find(t => t.id === id);
}

/**
 * 获取所有模版
 */
export function getAllTemplates(): JournalTemplate[] {
  return JOURNAL_TEMPLATES;
}
```

## 第 86 页

**文件路径：frontend/utils/promptTemplates.ts（部分）**

```typescript

/**
 * 预设提示词模板库
 * 涵盖常见的资源类型，用于AI生成图片
 */

export interface PromptTemplate {
  name: string;
  prompt: string;
  description?: string;
}

export const PROMPT_TEMPLATES: Record<string, PromptTemplate[]> = {
  // 头像类提示词
  avatar: [
    {
      name: '二次元头像',
      prompt: 'High-quality character portrait, anime style, detailed eyes, expressive emotions, vibrant colors, centered face, soft lighting, professional illustration, 4K quality',
      description: '现代二次元风格头像'
    },
    {
      name: '写实头像',
      prompt: 'Photorealistic portrait, professional photography, natural lighting, detailed facial features, high resolution, studio quality, 8K',
      description: '写实风格头像'
    },
    {
      name: '赛博朋克头像',
      prompt: 'Cyberpunk character portrait, neon lights, futuristic aesthetic, dark background, glowing effects, high-tech low-life atmosphere, cinematic lighting',
      description: '赛博朋克风格头像'
    },
    {
      name: '古风头像',
      prompt: 'Traditional Chinese style character portrait, ancient costume, elegant pose, ink painting aesthetic, classical beauty, refined details',
      description: '中国古风头像'
    },
    {
      name: '极简头像',
      prompt: 'Minimalist character avatar, clean lines, simple design, modern aesthetic, geometric shapes, elegant simplicity, flat design',
      description: '极简风格头像'
    }
  ],

  // 角色类提示词
  character: [
    {
      name: '二次元角色立绘',
      prompt: 'Full body character illustration, anime style, detailed design, dynamic pose, vibrant colors, expressive character, professional artwork, 4K quality, vertical composition',
      description: '二次元角色全身立绘'
    },
    {
      name: '写实角色',
      prompt: 'Photorealistic character design, full body, professional photography, natural lighting, detailed costume, high resolution, cinematic composition',
      description: '写实风格角色'
    },
    {
      name: '奇幻角色',
      prompt: 'Fantasy character illustration, magical elements, epic design, detailed armor or costume, mystical atmosphere, high fantasy aesthetic, professional artwork',
      description: '奇幻风格角色'
    },
    {
      name: '赛博朋克角色',
      prompt: 'Cyberpunk character design, futuristic outfit, neon accents, high-tech elements, dark aesthetic, Blade Runner inspired, cinematic lighting',
      description: '赛博朋克风格角色'
    },
    {
      name: '古风角色',
      prompt: 'Traditional Chinese character design, ancient costume, elegant pose, classical beauty, refined details, ink painting style, cultural heritage',
      description: '中国古风角色'
    },
    {
      name: '角色背景',
      prompt: 'Atmospheric background scene for character, matching personality and theme, detailed environment, cinematic lighting, immersive setting, professional illustration',
      description: '角色背景场景'
    }
  ],
```

## 第 87 页

**文件路径：backend/src/main/java/com/heartsphere/repository/JournalEntryRepository.java**

```java

package com.heartsphere.repository;

import com.heartsphere.entity.JournalEntry;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface JournalEntryRepository extends JpaRepository<JournalEntry, String> {
    List<JournalEntry> findByUser_Id(Long userId);
    List<JournalEntry> findByWorld_Id(Long worldId);
    List<JournalEntry> findByEra_Id(Long eraId);
    List<JournalEntry> findByCharacter_Id(Long characterId);
    
    // 搜索功能：按标题、内容、标签搜索
    @Query("SELECT j FROM JournalEntry j WHERE j.user.id = :userId AND " +
           "(LOWER(j.title) LIKE LOWER(CONCAT('%', :keyword, '%')) OR " +
           "LOWER(j.content) LIKE LOWER(CONCAT('%', :keyword, '%')) OR " +
           "LOWER(j.tags) LIKE LOWER(CONCAT('%', :keyword, '%')))")
    List<JournalEntry> searchByKeyword(@Param("userId") Long userId, @Param("keyword") String keyword);
    
    // 按标签筛选
    @Query("SELECT j FROM JournalEntry j WHERE j.user.id = :userId AND " +
           "LOWER(j.tags) LIKE LOWER(CONCAT('%', :tag, '%'))")
    List<JournalEntry> findByTag(@Param("userId") Long userId, @Param("tag") String tag);
}
```

## 第 88 页

**文件路径：backend/src/main/java/com/heartsphere/repository/ScriptRepository.java**

```java

package com.heartsphere.repository;

import com.heartsphere.entity.Script;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ScriptRepository extends JpaRepository<Script, Long> {
    @Query("SELECT s FROM Script s WHERE s.user.id = :userId AND s.isDeleted = false")
    List<Script> findByUser_Id(@Param("userId") Long userId);
    
    @Query("SELECT s FROM Script s WHERE s.world.id = :worldId AND s.isDeleted = false")
    List<Script> findByWorld_Id(@Param("worldId") Long worldId);
    
    @Query("SELECT s FROM Script s WHERE s.era.id = :eraId AND s.isDeleted = false")
    List<Script> findByEra_Id(@Param("eraId") Long eraId);
    
    // 回收站：获取已删除的剧本
    @Query("SELECT s FROM Script s WHERE s.user.id = :userId AND s.isDeleted = true")
    List<Script> findDeletedByUser_Id(@Param("userId") Long userId);
}
```

## 第 89 页

**文件路径：backend/src/main/java/com/heartsphere/repository/MembershipRepository.java**

```java

package com.heartsphere.repository;

import com.heartsphere.entity.Membership;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.List;

@Repository
public interface MembershipRepository extends JpaRepository<Membership, Long> {
    Optional<Membership> findByUserId(Long userId);
    List<Membership> findByStatus(String status);
    List<Membership> findByAutoRenewTrueAndNextRenewalDateLessThan(java.time.LocalDateTime date);
}
```

## 第 90 页

**文件路径：backend/src/main/java/com/heartsphere/repository/SubscriptionPlanRepository.java**

```java

package com.heartsphere.repository;

import com.heartsphere.entity.SubscriptionPlan;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface SubscriptionPlanRepository extends JpaRepository<SubscriptionPlan, Long> {
    List<SubscriptionPlan> findByIsActiveTrueOrderBySortOrderAsc();
    List<SubscriptionPlan> findByTypeAndIsActiveTrueOrderBySortOrderAsc(String type);
    List<SubscriptionPlan> findByBillingCycleAndIsActiveTrueOrderBySortOrderAsc(String billingCycle);
}
```

## 第 91 页

**文件路径：backend/src/main/java/com/heartsphere/repository/PaymentOrderRepository.java**

```java

package com.heartsphere.repository;

import com.heartsphere.entity.PaymentOrder;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface PaymentOrderRepository extends JpaRepository<PaymentOrder, Long> {
    Optional<PaymentOrder> findByOrderNo(String orderNo);
    Optional<PaymentOrder> findByTransactionId(String transactionId);
    List<PaymentOrder> findByUserIdOrderByCreatedAtDesc(Long userId);
    List<PaymentOrder> findByStatus(String status);
}
```

## 第 92 页

**文件路径：backend/src/main/java/com/heartsphere/repository/PointTransactionRepository.java**

```java

package com.heartsphere.repository;

import com.heartsphere.entity.PointTransaction;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface PointTransactionRepository extends JpaRepository<PointTransaction, Long> {
    List<PointTransaction> findByUserIdOrderByCreatedAtDesc(Long userId);
    List<PointTransaction> findByMembershipIdOrderByCreatedAtDesc(Long membershipId);
}
```

## 第 93 页

**文件路径：backend/src/main/java/com/heartsphere/dto/LoginRequest.java**

```java

package com.heartsphere.dto;

import lombok.Data;

@Data
public class LoginRequest {
    private String username;
    private String password;
}
```

## 第 94 页

**文件路径：backend/src/main/java/com/heartsphere/dto/RegisterRequest.java**

```java

package com.heartsphere.dto;

import lombok.Data;

@Data
public class RegisterRequest {
    private String username;
    private String email;
    private String password;
    private String nickname; // 昵称（在心域中的称呼）
    private String inviteCode; // 邀请码（可选）
}
```

## 第 95 页

**文件路径：backend/src/main/java/com/heartsphere/dto/AuthResponse.java**

```java

package com.heartsphere.dto;

import lombok.Data;

@Data
public class AuthResponse {
    private String token;
    private String type = "Bearer";
    private Long id;
    private String username;
    private String email;
    private String nickname;
    private String avatar;

    public AuthResponse(String token, Long id, String username, String email, String nickname, String avatar) {
        this.token = token;
        this.id = id;
        this.username = username;
        this.email = email;
        this.nickname = nickname;
        this.avatar = avatar;
    }
}
```

## 第 96 页

**文件路径：frontend/components/Button.tsx**

```typescript

import React from 'react';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'ghost';
  fullWidth?: boolean;
}

export const Button: React.FC<ButtonProps> = ({ 
  children, 
  variant = 'primary', 
  fullWidth = false, 
  className = '', 
  ...props 
}) => {
  const baseStyles = "px-6 py-3 rounded-xl font-bold transition-all duration-300 transform active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed";
  
  const variants = {
    primary: "bg-gradient-to-r from-pink-500 to-purple-600 text-white shadow-lg hover:shadow-pink-500/30 hover:-translate-y-0.5 border border-transparent",
    secondary: "bg-white/10 backdrop-blur-md border border-white/20 text-white hover:bg-white/20",
    ghost: "bg-transparent text-white/70 hover:text-white hover:bg-white/5"
  };

  return (
    <button 
      className={`${baseStyles} ${variants[variant]} ${fullWidth ? 'w-full' : ''} ${className}`}
      {...props}
    >
      {children}
    </button>
  );
};
```

## 第 97 页

**文件路径：frontend/components/ConnectionSpace.tsx（部分）**

```typescript

import React, { useEffect, useRef, useState } from 'react';
import { Character, UserProfile } from '../types';
import { Button } from './Button';

interface ConnectionSpaceProps {
  characters: Character[];
  userProfile: UserProfile;
  onConnect: (character: Character) => void;
  onBack: () => void;
}

interface Star {
  id: string;
  x: number;
  y: number;
  size: number;
  color: string;
  baseColor: string;
  speedX: number;
  speedY: number;
  characterId?: string; // If this star represents a character
  character?: Character;
  pulseSpeed: number;
  pulseOffset: number;
  glow: number;
}

interface ShootingStar {
  id: number;
  x: number;
  y: number;
  length: number;
  speed: number;
  angle: number;
  opacity: number;
  color: string;
}

export const ConnectionSpace: React.FC<ConnectionSpaceProps> = ({ characters, userProfile, onConnect, onBack }) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [selectedStar, setSelectedStar] = useState<Star | null>(null);
  const [connecting, setConnecting] = useState(false);
  const starsRef = useRef<Star[]>([]);
  const shootingStarsRef = useRef<ShootingStar[]>([]);
  const animationFrameRef = useRef<number>(0);
  const mouseRef = useRef<{x: number, y: number}>({ x: 0, y: 0 });

  // Initialize Stars
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    // Resize canvas
    const resize = () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    };
    window.addEventListener('resize', resize);
    resize();

    // Create Background Stars
    const bgStars: Star[] = Array.from({ length: 200 }).map((_, i) => {
      const isBlue = Math.random() > 0.8;
      const color = isBlue ? '#a5f3fc' : '#ffffff';
      return {
        id: `bg_${i}`,
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        size: Math.random() * 1.5,
        color: color,
        baseColor: color,
        speedX: (Math.random() - 0.5) * 0.05,
        speedY: (Math.random() - 0.5) * 0.05,
        pulseSpeed: Math.random() * 0.02,
        pulseOffset: Math.random() * Math.PI * 2,
        glow: 0
      };
    });

    // Create Soul Stars (Characters)
    const charStars: Star[] = characters.map(char => ({
      id: `soul_${char.id}`,
      x: Math.random() * (canvas.width - 100) + 50,
      y: Math.random() * (canvas.height - 100) + 50,
      size: 4 + Math.random() * 3, // Bigger
      color: char.colorAccent || '#ffffff',
      baseColor: char.colorAccent || '#ffffff',
      speedX: (Math.random() - 0.5) * 0.2,
      speedY: (Math.random() - 0.5) * 0.2,
      characterId: char.id,
      character: char,
      pulseSpeed: 0.05 + Math.random() * 0.05,
      pulseOffset: Math.random() * Math.PI * 2,
      glow: 15
    }));

    starsRef.current = [...bgStars, ...charStars];

    return () => window.removeEventListener('resize', resize);
  }, [characters]);
```

## 第 98 页

**文件路径：frontend/components/MailboxModal.tsx（部分）**

```typescript

import React, { useState } from 'react';
import { Mail } from '../types';
import { Button } from './Button';

interface MailboxModalProps {
  mails: Mail[];
  onClose: () => void;
  onMarkAsRead: (mailId: string) => void;
}

export const MailboxModal: React.FC<MailboxModalProps> = ({ mails, onClose, onMarkAsRead }) => {
  const [selectedMail, setSelectedMail] = useState<Mail | null>(null);

  const handleOpenMail = (mail: Mail) => {
    setSelectedMail(mail);
    if (!mail.isRead) {
        onMarkAsRead(mail.id);
    }
  };

  const handleBackToList = () => {
    setSelectedMail(null);
  };

  // Sort mails: Unread first, then by timestamp descending
  const sortedMails = [...mails].sort((a, b) => {
    if (a.isRead === b.isRead) {
        return b.timestamp - a.timestamp;
    }
    return a.isRead ? 1 : -1;
  });

  return (
    <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-md p-4 animate-fade-in">
      <div className="bg-slate-900 border border-slate-700 rounded-3xl w-full max-w-4xl h-[80vh] shadow-2xl overflow-hidden flex flex-col md:flex-row relative">
        <button onClick={onClose} className="absolute top-4 right-4 z-20 text-slate-500 hover:text-white bg-black/50 rounded-full p-2 backdrop-blur-sm transition-colors">
            <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>
        </button>

        {/* Sidebar / List View */}
        <div className={`w-full md:w-1/3 border-r border-slate-700 flex flex-col ${selectedMail ? 'hidden md:flex' : 'flex'}`}>
            <div className="p-6 bg-slate-950/50">
                <h3 className="text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-pink-400 to-purple-400 flex items-center gap-2">
                    <span>📬</span> 跨时空信箱
                </h3>
                <p className="text-xs text-slate-500 mt-1">来自各个时代切片的问候</p>
            </div>
            <div className="flex-1 overflow-y-auto p-4 space-y-3 scrollbar-hide">
                {sortedMails.length === 0 ? (
                    <div className="text-center text-slate-600 mt-10">
                        <p>信箱是空的。</p>
                        <p className="text-xs">去和大家聊聊天吧，也许下次会有惊喜。</p>
                    </div>
                ) : (
                    sortedMails.map(mail => (
                        <div 
                            key={mail.id}
                            onClick={() => handleOpenMail(mail)}
                            className={`p-4 rounded-xl cursor-pointer transition-all border relative overflow-hidden group ${
                                selectedMail?.id === mail.id 
                                ? 'bg-slate-800 border-pink-500/50' 
                                : mail.isRead 
                                    ? 'bg-slate-900/50 border-transparent hover:bg-slate-800' 
                                    : 'bg-gradient-to-r from-slate-800 to-indigo-900/30 border-indigo-500/30 hover:border-indigo-400'
                            }`}
                        >
                            {!mail.isRead && <div className="absolute top-2 right-2 w-2 h-2 bg-pink-500 rounded-full animate-pulse" />}
                            <div className="flex items-center gap-3">
                                <img src={mail.senderAvatarUrl} alt={mail.senderName} className="w-10 h-10 rounded-full object-cover border border-slate-600" />
                                <div className="flex-1 min-w-0">
                                    <h4 className={`font-bold truncate ${mail.isRead ? 'text-slate-400' : 'text-white'}`}>{mail.senderName}</h4>
                                    <p className="text-sm text-slate-500 truncate">{mail.subject}</p>
                                </div>
                            </div>
                            <p className="text-[10px] text-slate-600 mt-2 text-right">{new Date(mail.timestamp).toLocaleDateString()}</p>
                        </div>
                    ))
                )}
            </div>
        </div>
```

## 第 99 页

**文件路径：frontend/components/WelcomeOverlay.tsx**

```typescript

import React, { useEffect, useState } from 'react';

interface WelcomeOverlayProps {
  onClose: () => void;
}

export const WelcomeOverlay: React.FC<WelcomeOverlayProps> = ({ onClose }) => {
  const [showContent, setShowContent] = useState(false);
  const [showParticles, setShowParticles] = useState(false);

  useEffect(() => {
    // 粒子效果延迟出现
    const particleTimer = setTimeout(() => setShowParticles(true), 500);
    // 内容延迟出现
    const contentTimer = setTimeout(() => setShowContent(true), 1000);

    return () => {
      clearTimeout(particleTimer);
      clearTimeout(contentTimer);
    };
  }, []);

  // 生成随机粒子位置
  const particles = Array.from({ length: 100 }, (_, i) => ({
    id: i,
    x: Math.random() * 100,
    y: Math.random() * 100,
    size: Math.random() * 3 + 1,
    delay: Math.random() * 2,
  }));

  return (
    <div className="fixed inset-0 z-[9999] bg-gradient-to-b from-black/95 via-purple-900/80 to-black/95 flex items-center justify-center overflow-hidden">
      {/* 粒子背景 */}
      {showParticles && particles.map((particle) => (
        <div
          key={particle.id}
          className="absolute rounded-full bg-gradient-to-r from-cyan-500 to-purple-500 opacity-50 animate-pulse"
          style={{
            left: `${particle.x}%`,
            top: `${particle.y}%`,
            width: `${particle.size}px`,
            height: `${particle.size}px`,
            animationDelay: `${particle.delay}s`,
          }}
        />
      ))}

      {/* 网格背景 */}
      <div className="absolute inset-0 bg-[linear-gradient(rgba(0,255,255,0.15)_1px,transparent_1px),linear-gradient(90deg,rgba(0,255,255,0.15)_1px,transparent_1px)] bg-[size:50px_50px]"></div>

      {/* 中心内容 */}
      <div className="relative z-10 text-center max-w-2xl px-4">
        {/* 标题 */}
        <div className={`transform transition-all duration-1000 ${showContent ? 'scale-100 opacity-100' : 'scale-75 opacity-0'}`}>
          <h1 className="text-6xl md:text-8xl font-bold mb-6">
            <span className="bg-clip-text text-transparent bg-gradient-to-r from-cyan-400 via-purple-400 to-pink-400 animate-pulse">
              欢迎来到心域
            </span>
          </h1>
          <p className="text-xl md:text-2xl text-cyan-200 mb-8 opacity-90">
            一个探索心灵与创造的世界
          </p>
        </div>

        {/* 副标题 */}
        <div className={`transform transition-all duration-1000 delay-300 ${showContent ? 'translate-y-0 opacity-100' : 'translate-y-10 opacity-0'}`}>
          <p className="text-lg text-cyan-100 mb-12 max-w-xl mx-auto leading-relaxed">
            在这里，你可以记录内心的声音，探索不同的人生故事，
            与虚拟角色建立深厚的情感连接。
          </p>
        </div>

        {/* 按钮 */}
        <div className={`transform transition-all duration-1000 delay-500 ${showContent ? 'translate-y-0 opacity-100' : 'translate-y-10 opacity-0'}`}>
          <button
            onClick={onClose}
            className="bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 text-white font-bold py-4 px-10 rounded-full text-lg shadow-lg shadow-purple-500/50 transition-all duration-300 hover:scale-105 hover:shadow-xl hover:shadow-purple-500/70"
          >
            开始探索
          </button>
        </div>

        {/* 底部装饰 */}
        <div className={`mt-16 transform transition-all duration-1000 delay-700 ${showContent ? 'opacity-100' : 'opacity-0'}`}>
          <div className="w-32 h-1 bg-gradient-to-r from-transparent via-cyan-400 to-transparent mx-auto"></div>
          <p className="text-sm text-cyan-300 mt-4 opacity-70">
            HeartSphere © {new Date().getFullYear()}
          </p>
        </div>
      </div>

      {/* 动态光效 */}
      <div className="absolute top-0 left-1/2 transform -translate-x-1/2 w-96 h-96 bg-purple-500/20 rounded-full blur-3xl animate-pulse"></div>
      <div className="absolute bottom-0 right-1/2 transform translate-x-1/2 w-96 h-96 bg-cyan-500/20 rounded-full blur-3xl animate-pulse"></div>
    </div>
  );
};
```

## 第 100 页

**文件路径：backend/pom.xml**

```xml

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <groupId>com.heartsphere</groupId>
    <artifactId>heartsphere-service</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>heartsphere-service</name>
    <description>HeartSphere后端服务</description>

    <properties>
        <java.version>17</java.version>
        <springdoc.version>2.3.0</springdoc.version>
    </properties>

    <dependencies>
        <!-- Spring Boot Web -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <!-- Spring Data JPA -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>

        <!-- MySQL 驱动 -->
        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- Spring Security -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>

        <!-- JWT -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.12.3</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.12.3</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.12.3</version>
            <scope>runtime</scope>
        </dependency>

        <!-- Spring Boot Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- SpringDoc OpenAPI -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>${springdoc.version}</version>
        </dependency>

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- JSON 处理 -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>
```

## 第 101 页

**文件路径：frontend/package.json**

```json

{
  "name": "心域-heartsphere",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  },
  "dependencies": {
    "@google/genai": "^1.30.0",
    "@types/qrcode": "^1.5.6",
    "qrcode": "^1.5.4",
    "react": "^19.2.0",
    "react-dom": "^19.2.0"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.1.5",
    "@testing-library/react": "^14.1.2",
    "@testing-library/user-event": "^14.5.1",
    "@types/jest": "^29.5.11",
    "@types/node": "^22.14.0",
    "@types/react": "^19.2.7",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.0.0",
    "identity-obj-proxy": "^3.0.0",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "ts-jest": "^29.1.1",
    "typescript": "~5.8.2",
    "vite": "^5.0.0"
  }
}
```

## 第 102 页

**文件路径：frontend/index.html**

```html

<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>Neon Heartbeat - AI Dating Sim</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
      :root {
        --safe-top: env(safe-area-inset-top, 20px);
        --safe-bottom: env(safe-area-inset-bottom, 20px);
      }
      body {
        font-family: 'Noto Sans SC', sans-serif;
        overflow: hidden; /* Prevent body scroll, handle in app */
        overscroll-behavior-y: none; /* Prevent pull-to-refresh on mobile */
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        user-select: none;
        -webkit-user-select: none;
        background-color: black;
      }
      /* Allow text selection in inputs */
      input, textarea {
        user-select: text;
        -webkit-user-select: text;
      }

      /* Custom Scrollbar for chat */
      .scrollbar-hide::-webkit-scrollbar {
          display: none;
      }
      .scrollbar-hide {
          -ms-overflow-style: none;
          scrollbar-width: none;
      }
      
      /* --- Animations --- */
      
      /* Standard Fade */
      .animate-fade-in {
        animation: fadeIn 0.5s ease-out forwards;
      }
      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }

      /* Typing Dot Animation */
      .typing-dot {
        animation: typing 1.4s infinite ease-in-out both;
      }
      .typing-dot:nth-child(1) { animation-delay: -0.32s; }
      .typing-dot:nth-child(2) { animation-delay: -0.16s; }
      @keyframes typing {
        0%, 80%, 100% { transform: scale(0); }
        40% { transform: scale(1); }
      }
    </style>
  <script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.30.0"
  }
}
</script>
</head>
  <body>
    <div id="root"></div>
    <script type="module" src="/index.tsx"></script>
  </body>
</html>
```

## 第 103 页

**文件路径：backend/src/main/java/com/heartsphere/config/WebMvcConfig.java**

```java

package com.heartsphere.config;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.StringHttpMessageConverter;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.lang.NonNull;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import java.util.List;

/**
 * Web MVC配置
 * 配置静态资源访问，用于访问上传的图片
 */
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    @Value("${app.image.storage.local.path:./uploads/images}")
    private String localStoragePath;

    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        mapper.getFactory().configure(JsonGenerator.Feature.ESCAPE_NON_ASCII, false);
        // 注册 Java 8 时间模块
        mapper.registerModule(new com.fasterxml.jackson.datatype.jsr310.JavaTimeModule());
        // 禁用将日期写为时间戳，使用 ISO-8601 格式
        mapper.disable(com.fasterxml.jackson.databind.SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        mapper.disable(com.fasterxml.jackson.databind.SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS);
        return mapper;
    }

    @Override
    public void configureMessageConverters(@NonNull List<HttpMessageConverter<?>> converters) {
        // 确保字符串消息转换器使用UTF-8编码
        StringHttpMessageConverter stringConverter = new StringHttpMessageConverter(StandardCharsets.UTF_8);
        converters.add(0, stringConverter);
        
        // 配置 JSON 消息转换器，不转义非 ASCII 字符
        MappingJackson2HttpMessageConverter jsonConverter = new MappingJackson2HttpMessageConverter();
        jsonConverter.setObjectMapper(objectMapper());
        converters.add(0, jsonConverter);
    }

    @Override
    public void addResourceHandlers(@NonNull ResourceHandlerRegistry registry) {
        // 配置图片访问路径
        // 将 /api/images/files/** 映射到本地文件系统的 uploads/images/ 目录
        // 注意：使用 /files/** 后缀以避免与 ImageController 的 /api/images/upload 等端点冲突
        String uploadPath = Paths.get(localStoragePath).toAbsolutePath().normalize().toString();
        // 确保路径以 / 结尾
        if (!uploadPath.endsWith("/") && !uploadPath.endsWith("\\")) {
            uploadPath += "/";
        }
        registry.addResourceHandler("/api/images/files/**")
                .addResourceLocations("file:" + uploadPath);
    }
}
```

## 第 104 页

**文件路径：frontend/components/DebugConsole.tsx（部分）**

```typescript

import React, { useState, useEffect, useRef } from 'react';
import { DebugLog } from '../types';

interface DebugConsoleProps {
  logs: DebugLog[];
  onClear: () => void;
  onClose: () => void;
}

export const DebugConsole: React.FC<DebugConsoleProps> = ({ logs, onClear, onClose }) => {
  const scrollRef = useRef<HTMLDivElement>(null);
  const [autoScroll, setAutoScroll] = useState(true);
  const [isMinimized, setIsMinimized] = useState(false);

  useEffect(() => {
    if (autoScroll && !isMinimized && scrollRef.current) {
      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
    }
  }, [logs, autoScroll, isMinimized]);

  return (
    <div 
      className={`fixed bottom-0 left-0 w-full z-[100] flex flex-col font-mono text-xs shadow-[0_-5px_20px_rgba(0,0,0,0.8)] backdrop-blur-md transition-all duration-300 ease-in-out border-t border-green-500/30 ${
        isMinimized ? 'h-9 bg-black/80' : 'h-1/3 min-h-[300px] bg-black/90'
      }`}
    >
      {/* Header - Click to Toggle */}
      <div 
        className="flex justify-between items-center px-4 h-9 bg-gray-900/90 border-b border-gray-700 cursor-pointer hover:bg-gray-800 transition-colors select-none"
        onClick={() => setIsMinimized(!isMinimized)}
        title={isMinimized ? "点击展开日志" : "点击折叠日志"}
      >
        <div className="flex items-center gap-3">
          <button className="text-gray-400 hover:text-white focus:outline-none">
            {isMinimized ? '▲' : '▼'}
          </button>
          <div className="flex items-center gap-2">
            <span className={`font-bold animate-pulse ${logs.some(l => l.type === 'error') ? 'text-red-500' : 'text-green-500'}`}>
              ● MATRIX DEBUGGER
            </span>
            <span className="text-gray-600">|</span>
            <span className="text-gray-400">{logs.length} events</span>
          </div>
        </div>
        
        <div className="flex items-center gap-4" onClick={(e) => e.stopPropagation()}>
           {!isMinimized && (
              <label className="flex items-center gap-2 cursor-pointer text-gray-400 hover:text-white select-none hidden sm:flex">
                <input type="checkbox" checked={autoScroll} onChange={e => setAutoScroll(e.target.checked)} className="rounded bg-gray-700 border-gray-600 text-green-500 focus:ring-0" />
                Auto-scroll
              </label>
           )}
           <div className="flex items-center gap-2">
              <button onClick={onClear} className="text-yellow-500 hover:text-yellow-400 font-bold px-2 py-0.5 hover:bg-white/5 rounded text-[10px] border border-yellow-500/30">CLEAR</button>
              <button onClick={onClose} className="text-red-500 hover:text-red-400 font-bold ml-2 px-2 py-0.5 hover:bg-white/5 rounded text-[10px] border border-red-500/30">CLOSE</button>
           </div>
        </div>
      </div>

      {/* Logs Area */}
      {!isMinimized && (
        <div ref={scrollRef} className="flex-1 overflow-y-auto p-4 space-y-2 scrollbar-hide bg-black/50">
          {logs.length === 0 && (
            <div className="text-gray-600 text-center mt-10 italic flex flex-col items-center gap-2">
                <div className="w-2 h-2 bg-green-500 rounded-full animate-ping" />
                Waiting for neural signals...
            </div>
          )}
          {logs.map((log) => (
            <div key={log.id} className="border-l-2 pl-3 py-1 font-mono text-xs break-all hover:bg-white/5 transition-colors rounded-r group" 
                 style={{ 
                   borderColor: log.type === 'error' ? '#ef4444' : log.type === 'request' ? '#3b82f6' : '#22c55e' 
                 }}>
               <div className="flex gap-2 text-[10px] opacity-70 mb-0.5 items-center flex-wrap">
                  <span className="text-gray-500 font-light">[{new Date(log.timestamp).toLocaleTimeString([], {hour12: false, hour:'2-digit', minute:'2-digit', second:'2-digit', fractionalSecondDigits: 3} as any)}]</span>
                  <span className="font-bold uppercase tracking-wider" style={{ color: log.type === 'error' ? '#ef4444' : log.type === 'request' ? '#60a5fa' : '#4ade80' }}>
                    {log.type}
                  </span>
                  
                  {/* Provider & Model Badge */}
                  <span className="text-purple-400 bg-purple-900/20 px-1.5 py-0.5 rounded border border-purple-500/20 flex items-center gap-1">
                      <span>@{log.provider}</span>
                      {log.model && <span className="text-purple-300 opacity-70">/ {log.model}</span>}
                  </span>

                  <span className="text-yellow-200/80 font-semibold">::{log.method}</span>
               </div>
               
               <div className="text-gray-300 whitespace-pre-wrap pl-1 mt-1">
                  {typeof log.data === 'string' ? log.data : (
                      <details>
                          <summary className="cursor-pointer text-gray-500 hover:text-gray-300 select-none outline-none text-[10px] flex items-center gap-1 group-hover:text-gray-200 transition-colors">
                             <span className="opacity-50">▶</span> {log.type === 'request' ? 'View Payload' : 'View Response Data'}
                          </summary>
                          <pre className="mt-2 text-[10px] bg-gray-950 p-3 rounded-lg border border-gray-800 overflow-x-auto text-green-400/90 max-h-60 custom-scrollbar shadow-inner">
                              {JSON.stringify(log.data, null, 2)}
                          </pre>
                      </details>
                  )}
               </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};
```

## 第 105 页

**文件路径：backend/src/main/java/com/heartsphere/service/MembershipService.java**

```java

package com.heartsphere.service;

import com.heartsphere.entity.Membership;
import com.heartsphere.entity.SubscriptionPlan;
import com.heartsphere.entity.PointTransaction;
import com.heartsphere.repository.MembershipRepository;
import com.heartsphere.repository.SubscriptionPlanRepository;
import com.heartsphere.repository.PointTransactionRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

/**
 * 会员服务
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class MembershipService {

    private final MembershipRepository membershipRepository;
    private final SubscriptionPlanRepository planRepository;
    private final PointTransactionRepository pointTransactionRepository;

    /**
     * 获取用户的会员信息
     */
    public Optional<Membership> getUserMembership(Long userId) {
        return membershipRepository.findByUserId(userId);
    }

    /**
     * 获取或创建免费会员
     */
    @Transactional
    public Membership getOrCreateFreeMembership(Long userId) {
        Optional<Membership> existing = membershipRepository.findByUserId(userId);
        if (existing.isPresent()) {
            return existing.get();
        }

        // 获取免费计划
        SubscriptionPlan freePlan = planRepository.findByTypeAndIsActiveTrueOrderBySortOrderAsc("free")
                .stream()
                .findFirst()
                .orElseThrow(() -> new RuntimeException("免费计划不存在"));

        // 创建免费会员
        Membership membership = new Membership();
        membership.setUserId(userId);
        membership.setPlanId(freePlan.getId());
        membership.setPlanType("free");
        membership.setBillingCycle("monthly");
        membership.setStatus("active");
        membership.setStartDate(LocalDateTime.now());
        membership.setAutoRenew(false);
        membership.setCurrentPoints(0);
        membership.setTotalPointsEarned(0);
        membership.setTotalPointsUsed(0);

        return membershipRepository.save(membership);
    }

    /**
     * 激活会员（支付成功后调用）
     */
    @Transactional
    public Membership activateMembership(Long userId, Long planId, String billingCycle) {
        SubscriptionPlan plan = planRepository.findById(planId)
                .orElseThrow(() -> new RuntimeException("订阅计划不存在"));

        // 获取或创建会员记录
        Membership membership = membershipRepository.findByUserId(userId)
                .orElse(new Membership());

        // 计算结束时间
        LocalDateTime startDate = LocalDateTime.now();
        LocalDateTime endDate = null;
        LocalDateTime nextRenewalDate = null;

        if (billingCycle.equals("monthly")) {
            endDate = startDate.plusMonths(1);
        } else if (billingCycle.equals("yearly")) {
            endDate = startDate.plusYears(1);
        } else if (billingCycle.equals("continuous_monthly")) {
            nextRenewalDate = startDate.plusMonths(1);
            membership.setAutoRenew(true);
        } else if (billingCycle.equals("continuous_yearly")) {
            nextRenewalDate = startDate.plusYears(1);
            membership.setAutoRenew(true);
        }

        // 更新会员信息
        membership.setUserId(userId);
        membership.setPlanId(planId);
        membership.setPlanType(plan.getType());
        membership.setBillingCycle(billingCycle);
        membership.setStatus("active");
        membership.setStartDate(startDate);
        membership.setEndDate(endDate);
        membership.setNextRenewalDate(nextRenewalDate);
        membership.setRenewalPrice(plan.getPrice());

        // 如果是新会员，初始化积分
        if (membership.getId() == null) {
            membership.setCurrentPoints(0);
            membership.setTotalPointsEarned(0);
            membership.setTotalPointsUsed(0);
        }

        Membership saved = membershipRepository.save(membership);

        // 添加每月积分
        if (plan.getPointsPerMonth() > 0) {
            addPoints(userId, saved.getId(), plan.getPointsPerMonth(), "会员激活赠送", null);
        }

        log.info("会员激活成功: userId={}, planId={}, billingCycle={}", userId, planId, billingCycle);
        return saved;
    }

    /**
     * 添加积分
     */
    @Transactional
    public void addPoints(Long userId, Long membershipId, Integer points, String description, Long orderId) {
        Membership membership = membershipRepository.findByUserId(userId)
                .orElseThrow(() -> new RuntimeException("会员不存在"));

        Integer newBalance = membership.getCurrentPoints() + points;
        membership.setCurrentPoints(newBalance);
        membership.setTotalPointsEarned(membership.getTotalPointsEarned() + points);
        membershipRepository.save(membership);

        // 记录积分交易
        PointTransaction transaction = new PointTransaction();
        transaction.setUserId(userId);
        transaction.setMembershipId(membershipId);
        transaction.setType("earn");
        transaction.setAmount(points);
        transaction.setBalanceAfter(newBalance);
        transaction.setDescription(description);
        transaction.setRelatedOrderId(orderId);
        pointTransactionRepository.save(transaction);

        log.info("积分添加成功: userId={}, points={}, balance={}", userId, points, newBalance);
    }

    /**
     * 使用积分
     */
    @Transactional
    public boolean usePoints(Long userId, Integer points, String description) {
        Membership membership = membershipRepository.findByUserId(userId)
                .orElseThrow(() -> new RuntimeException("会员不存在"));

        if (membership.getCurrentPoints() < points) {
            return false;
        }

        Integer newBalance = membership.getCurrentPoints() - points;
        membership.setCurrentPoints(newBalance);
        membership.setTotalPointsUsed(membership.getTotalPointsUsed() + points);
        membershipRepository.save(membership);

        // 记录积分交易
        PointTransaction transaction = new PointTransaction();
        transaction.setUserId(userId);
        transaction.setMembershipId(membership.getId());
        transaction.setType("use");
        transaction.setAmount(-points);
        transaction.setBalanceAfter(newBalance);
        transaction.setDescription(description);
        pointTransactionRepository.save(transaction);

        log.info("积分使用成功: userId={}, points={}, balance={}", userId, points, newBalance);
        return true;
    }

    /**
     * 获取所有订阅计划
     */
    public List<SubscriptionPlan> getAllPlans() {
        return planRepository.findByIsActiveTrueOrderBySortOrderAsc();
    }

    /**
     * 根据计费周期获取计划
     */
    public List<SubscriptionPlan> getPlansByBillingCycle(String billingCycle) {
        return planRepository.findByBillingCycleAndIsActiveTrueOrderBySortOrderAsc(billingCycle);
    }
}
```

## 第 106 页

**文件路径：backend/src/main/java/com/heartsphere/service/PaymentService.java**

```java

package com.heartsphere.service;

import com.heartsphere.entity.PaymentOrder;
import com.heartsphere.entity.SubscriptionPlan;
import com.heartsphere.repository.PaymentOrderRepository;
import com.heartsphere.repository.SubscriptionPlanRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.UUID;

/**
 * 支付服务
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class PaymentService {

    private final PaymentOrderRepository orderRepository;
    private final SubscriptionPlanRepository planRepository;
    private final MembershipService membershipService;

    /**
     * 创建支付订单
     */
    @Transactional
    public PaymentOrder createOrder(Long userId, Long planId, String paymentType) {
        SubscriptionPlan plan = planRepository.findById(planId)
                .orElseThrow(() -> new RuntimeException("订阅计划不存在"));

        // 生成订单号
        String orderNo = generateOrderNo();

        // 创建订单
        PaymentOrder order = new PaymentOrder();
        order.setOrderNo(orderNo);
        order.setUserId(userId);
        order.setPlanId(planId);
        order.setPaymentType(paymentType);
        order.setAmount(plan.getPrice());
        order.setStatus("pending");
        order.setExpiresAt(LocalDateTime.now().plusMinutes(30)); // 30分钟过期

        PaymentOrder saved = orderRepository.save(order);

        // 调用支付接口获取支付二维码（暂时使用模拟数据，后续集成真实支付SDK）
        try {
            // TODO: 集成微信支付和支付宝SDK
            // 暂时返回模拟的二维码URL
            if ("wechat".equals(paymentType)) {
                saved.setQrCodeUrl("https://api.example.com/qrcode/wechat/" + orderNo);
                saved.setPaymentUrl("weixin://wxpay/bizpayurl?pr=" + orderNo);
            } else if ("alipay".equals(paymentType)) {
                saved.setQrCodeUrl("https://api.example.com/qrcode/alipay/" + orderNo);
                saved.setPaymentUrl("https://mapi.alipay.com/gateway.do?order=" + orderNo);
            }
            orderRepository.save(saved);
        } catch (Exception e) {
            log.error("创建支付订单失败", e);
            saved.setStatus("failed");
            orderRepository.save(saved);
            throw new RuntimeException("创建支付订单失败: " + e.getMessage());
        }

        return saved;
    }

    /**
     * 查询订单状态
     */
    public PaymentOrder getOrder(String orderNo) {
        return orderRepository.findByOrderNo(orderNo)
                .orElseThrow(() -> new RuntimeException("订单不存在"));
    }

    /**
     * 处理支付回调
     */
    @Transactional
    public void handlePaymentCallback(String orderNo, String transactionId, String paymentType) {
        PaymentOrder order = orderRepository.findByOrderNo(orderNo)
                .orElseThrow(() -> new RuntimeException("订单不存在"));

        if (!"pending".equals(order.getStatus())) {
            log.warn("订单状态不是pending，忽略回调: orderNo={}, status={}", orderNo, order.getStatus());
            return;
        }

        order.setStatus("paid");
        order.setTransactionId(transactionId);
        order.setPaymentProvider(paymentType);
        order.setPaidAt(LocalDateTime.now());
        orderRepository.save(order);

        // 激活会员
        membershipService.activateMembership(
                order.getUserId(),
                order.getPlanId(),
                planRepository.findById(order.getPlanId())
                        .map(SubscriptionPlan::getBillingCycle)
                        .orElse("monthly")
        );

        log.info("支付成功，会员已激活: orderNo={}, userId={}", orderNo, order.getUserId());
    }

    /**
     * 生成订单号
     */
    private String generateOrderNo() {
        return "HS" + System.currentTimeMillis() + UUID.randomUUID().toString().substring(0, 8).toUpperCase();
    }
}
```

## 第 107 页

**文件路径：backend/src/main/java/com/heartsphere/service/ImageStorageService.java（部分）**

```java

package com.heartsphere.service;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.UUID;
import java.util.logging.Logger;

/**
 * 图片存储服务
 * 支持本地文件存储，可扩展为云存储
 */
@Service
public class ImageStorageService {

    private static final Logger logger = Logger.getLogger(ImageStorageService.class.getName());

    @Value("${app.image.storage.type:local}")
    private String storageType; // local, oss, s3, etc.

    @Value("${app.image.storage.local.path:./uploads/images}")
    private String localStoragePath;

    @Value("${app.image.storage.base-url:http://localhost:8081/api/images}")
    private String baseUrl;

    @Value("${app.image.storage.max-size:10485760}")
    private long maxFileSize; // 10MB default

    @jakarta.annotation.PostConstruct
    public void init() {
        // 确保上传目录存在
        try {
            Path uploadPath = Paths.get(localStoragePath);
            if (!Files.exists(uploadPath)) {
                Files.createDirectories(uploadPath);
                System.out.println("图片上传目录已创建: " + uploadPath.toAbsolutePath());
            }
        } catch (IOException e) {
            System.err.println("创建图片上传目录失败: " + e.getMessage());
        }
    }

    /**
     * 保存图片文件
     * @param file 上传的文件
     * @param category 图片分类（如：era, character, journal等）
     * @return 图片访问URL
     */
    public String saveImage(MultipartFile file, String category) throws IOException {
        logger.info("[ImageStorageService] 开始保存图片，分类: " + category);
        
        if (file == null || file.isEmpty()) {
            throw new IllegalArgumentException("文件不能为空");
        }

        // 验证文件类型
        String contentType = file.getContentType();
        logger.info("[ImageStorageService] 文件类型: " + contentType);
        if (contentType == null || !contentType.startsWith("image/")) {
            throw new IllegalArgumentException("只支持图片文件");
        }

        // 验证文件大小
        long fileSize = file.getSize();
        logger.info("[ImageStorageService] 文件大小: " + fileSize + " bytes (限制: " + maxFileSize + " bytes)");
        if (fileSize > maxFileSize) {
            throw new IllegalArgumentException("文件大小不能超过 " + (maxFileSize / 1024 / 1024) + "MB");
        }

        // 根据存储类型选择存储方式
        logger.info("[ImageStorageService] 存储类型: " + storageType);
        switch (storageType.toLowerCase()) {
            case "local":
                return saveToLocal(file, category);
            case "oss":
                // TODO: 实现OSS存储
                throw new UnsupportedOperationException("OSS存储暂未实现");
            case "s3":
                // TODO: 实现S3存储
                throw new UnsupportedOperationException("S3存储暂未实现");
            default:
                return saveToLocal(file, category);
        }
    }

    /**
     * 保存到本地文件系统
     */
    private String saveToLocal(MultipartFile file, String category) throws IOException {
        logger.info("[ImageStorageService] 开始保存到本地文件系统");
        
        // 创建目录结构：uploads/images/{category}/{year}/{month}/
        String year = String.valueOf(java.time.Year.now().getValue());
        String month = String.format("%02d", java.time.MonthDay.now().getMonthValue());
        
        Path categoryPath = Paths.get(localStoragePath, category, year, month);
        logger.info("[ImageStorageService] 目标目录: " + categoryPath.toAbsolutePath());
        Files.createDirectories(categoryPath);
        logger.info("[ImageStorageService] 目录创建成功");

        // 生成唯一文件名：UUID + 原始扩展名
        String originalFilename = file.getOriginalFilename();
        String extension = "";
        if (originalFilename != null && originalFilename.contains(".")) {
            extension = originalFilename.substring(originalFilename.lastIndexOf("."));
        }
        String filename = UUID.randomUUID().toString() + extension;
        logger.info("[ImageStorageService] 生成文件名: " + filename);

        // 保存文件
        Path targetPath = categoryPath.resolve(filename);
        logger.info("[ImageStorageService] 保存文件到: " + targetPath.toAbsolutePath());
        Files.copy(file.getInputStream(), targetPath, StandardCopyOption.REPLACE_EXISTING);
        logger.info("[ImageStorageService] 文件保存成功");

        // 返回访问URL（使用 /files/ 前缀以匹配静态资源处理器）
        String relativePath = String.format("%s/%s/%s/%s", category, year, month, filename);
        String imageUrl = baseUrl + "/files/" + relativePath;
        logger.info("[ImageStorageService] 返回图片URL: " + imageUrl);
        return imageUrl;
    }
```

## 第 108 页

**文件路径：backend/src/main/java/com/heartsphere/service/ImageStorageService.java（续）**

```java

    /**
     * 删除图片
     */
    public boolean deleteImage(String imageUrl) {
        if (imageUrl == null || imageUrl.isEmpty()) {
            return false;
        }

        try {
            switch (storageType.toLowerCase()) {
                case "local":
                    return deleteFromLocal(imageUrl);
                default:
                    return deleteFromLocal(imageUrl);
            }
        } catch (Exception e) {
            System.err.println("删除图片失败: " + e.getMessage());
            return false;
        }
    }

    /**
     * 从本地删除图片
     */
    private boolean deleteFromLocal(String imageUrl) throws IOException {
        // 从URL中提取相对路径（支持 /files/ 前缀）
        String relativePath = imageUrl.replace(baseUrl + "/files/", "").replace(baseUrl + "/", "");
        Path filePath = Paths.get(localStoragePath, relativePath);
        
        if (Files.exists(filePath)) {
            Files.delete(filePath);
            return true;
        }
        return false;
    }

    /**
     * 保存Base64图片（用于前端直接上传base64数据）
     */
    public String saveBase64Image(String base64Data, String category) throws IOException {
        if (base64Data == null || base64Data.isEmpty()) {
            throw new IllegalArgumentException("Base64数据不能为空");
        }

        // 解析Base64数据
        String[] parts = base64Data.split(",");
        if (parts.length != 2) {
            throw new IllegalArgumentException("无效的Base64格式");
        }

        String header = parts[0];
        String data = parts[1];

        // 从header中提取MIME类型
        String mimeType = "image/png";
        if (header.contains("image/jpeg") || header.contains("image/jpg")) {
            mimeType = "image/jpeg";
        } else if (header.contains("image/png")) {
            mimeType = "image/png";
        } else if (header.contains("image/webp")) {
            mimeType = "image/webp";
        } else if (header.contains("image/gif")) {
            mimeType = "image/gif";
        }

        // 解码Base64
        byte[] imageBytes = java.util.Base64.getDecoder().decode(data);

        // 验证文件大小
        if (imageBytes.length > maxFileSize) {
            throw new IllegalArgumentException("文件大小不能超过 " + (maxFileSize / 1024 / 1024) + "MB");
        }

        // 创建目录
        String year = String.valueOf(java.time.Year.now().getValue());
        String month = String.format("%02d", java.time.MonthDay.now().getMonthValue());
        Path categoryPath = Paths.get(localStoragePath, category, year, month);
        Files.createDirectories(categoryPath);

        // 生成文件名
        String extension = getExtensionFromMimeType(mimeType);
        String filename = UUID.randomUUID().toString() + extension;

        // 保存文件
        Path targetPath = categoryPath.resolve(filename);
        Files.write(targetPath, imageBytes);

        // 返回访问URL（使用 /files/ 前缀以匹配静态资源处理器）
        String relativePath = String.format("%s/%s/%s/%s", category, year, month, filename);
        return baseUrl + "/files/" + relativePath;
    }

    /**
     * 根据MIME类型获取文件扩展名
     */
    private String getExtensionFromMimeType(String mimeType) {
        switch (mimeType) {
            case "image/jpeg":
            case "image/jpg":
                return ".jpg";
            case "image/png":
                return ".png";
            case "image/webp":
                return ".webp";
            case "image/gif":
                return ".gif";
            default:
                return ".png";
        }
    }
}
```

## 第 109 页

**文件路径：backend/src/main/java/com/heartsphere/security/UserDetailsServiceImpl.java**

```java

package com.heartsphere.security;

import com.heartsphere.entity.User;
import com.heartsphere.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User Not Found with username: " + username));

        return UserDetailsImpl.build(user);
    }
}
```

## 第 110 页

**文件路径：backend/src/main/java/com/heartsphere/security/UserDetailsImpl.java**

```java

package com.heartsphere.security;

import com.heartsphere.entity.User;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.Collections;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class UserDetailsImpl implements UserDetails {

    private static final long serialVersionUID = 1L;

    private Long id;
    private String username;
    private String email;
    private String password;
    private Boolean isEnabled;

    public static UserDetailsImpl build(User user) {
        return new UserDetailsImpl(
                user.getId(),
                user.getUsername(),
                user.getEmail(),
                user.getPassword(),
                user.getIsEnabled());
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return Collections.emptyList();
    }

    @Override
    public String getPassword() {
        return password;
    }

    @Override
    public String getUsername() {
        return username;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return isEnabled;
    }
}
```

## 第 111 页

**文件路径：backend/src/main/java/com/heartsphere/utils/JwtUtils.java**

```java

package com.heartsphere.utils;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.util.Date;

@Component
public class JwtUtils {

    @Value("${jwt.secret}")
    private String jwtSecret;

    @Value("${jwt.expiration}")
    private int jwtExpirationMs;

    private SecretKey key() {
        return Keys.hmacShaKeyFor(jwtSecret.getBytes());
    }

    public String generateJwtToken(Authentication authentication) {
        UserDetails userPrincipal = (UserDetails) authentication.getPrincipal();

        return Jwts.builder()
                .setSubject((userPrincipal.getUsername()))
                .setIssuedAt(new Date())
                .setExpiration(new Date((new Date()).getTime() + jwtExpirationMs))
                .signWith(key(), SignatureAlgorithm.HS256)
                .compact();
    }

    public String generateJwtTokenFromUsername(String username) {
        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(new Date())
                .setExpiration(new Date((new Date()).getTime() + jwtExpirationMs))
                .signWith(key(), SignatureAlgorithm.HS256)
                .compact();
    }

    public String getUserNameFromJwtToken(String token) {
        return Jwts.parser()
                .verifyWith(key())
                .build()
                .parseSignedClaims(token)
                .getPayload()
                .getSubject();
    }

    public boolean validateJwtToken(String authToken) {
        try {
            Jwts.parser()
                    .verifyWith(key())
                    .build()
                    .parseSignedClaims(authToken);
            return true;
        } catch (JwtException e) {
            System.err.println("Invalid JWT token: " + e.getMessage());
        }

        return false;
    }
}
```

## 第 112 页

**文件路径：frontend/services/storage.ts（部分）**

```typescript

import { GameState } from '../types';

const DB_NAME = 'HeartSphereDB';
const STORE_NAME = 'gameState';
const CUSTOM_SCENE_MAPPINGS_STORE = 'customSceneMappings';
const DB_VERSION = 2;
const LEGACY_STORAGE_KEY = 'HEARTSPHERE_MEMORY_CORE_V1';

// Definte a partial type for saving to avoid saving unnecessary UI state
type PersistedState = Omit<GameState, 'currentScreen' | 'currentScenarioState' | 'generatingAvatarId' | 'activeJournalEntryId' | 'tempStoryCharacter' | 'debugLogs'>;

export const storageService = {
  
  /**
   * Open the IndexedDB database
   */
  initDB: (): Promise<IDBDatabase> => {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_NAME, DB_VERSION);

      request.onerror = (event) => {
        console.error("IndexedDB error:", request.error);
        reject("Database error");
      };

      request.onsuccess = (event) => {
        resolve(request.result);
      };

      request.onupgradeneeded = (event) => {
        const db = request.result;
        if (!db.objectStoreNames.contains(STORE_NAME)) {
          db.createObjectStore(STORE_NAME);
        }
        if (!db.objectStoreNames.contains(CUSTOM_SCENE_MAPPINGS_STORE)) {
          db.createObjectStore(CUSTOM_SCENE_MAPPINGS_STORE);
        }
      };
    });
  },

  /**
   * Save the current game state to IndexedDB.
   */
  saveState: async (state: GameState): Promise<void> => {
    try {
      const stateToSave: PersistedState = {
        userProfile: state.userProfile,
        selectedSceneId: state.selectedSceneId, 
        selectedCharacterId: state.selectedCharacterId,
        selectedScenarioId: state.selectedScenarioId,
        editingScenarioId: null, 
        history: state.history,
        customAvatars: state.customAvatars,
        customScenarios: state.customScenarios,
        customScenes: state.customScenes,
        customCharacters: state.customCharacters, // Ensure user-created characters for default scenes are saved
        journalEntries: state.journalEntries,
        settings: state.settings,
        mailbox: state.mailbox,
        lastLoginTime: state.lastLoginTime,
        sceneMemories: state.sceneMemories || {},
        userWorldScenes: state.userWorldScenes || [], // Save remote world data for local-first loading
        showWelcomeOverlay: state.showWelcomeOverlay // Save welcome overlay state
      };

      const db = await storageService.initDB();
      const transaction = db.transaction(STORE_NAME, "readwrite");
      const store = transaction.objectStore(STORE_NAME);
      
      // We store the whole state under a single key 'latest'
      const request = store.put(stateToSave, 'latest');

      return new Promise((resolve, reject) => {
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });

    } catch (e) {
      console.error("Memory Core Write Error:", e);
    }
  },

  /**
   * Load the game state from IndexedDB.
   * Includes migration logic from LocalStorage.
   */
  loadState: async (): Promise<Partial<GameState> | null> => {
    try {
      const db = await storageService.initDB();
      const transaction = db.transaction(STORE_NAME, "readonly");
      const store = transaction.objectStore(STORE_NAME);
      const request = store.get('latest');

      const result = await new Promise<PersistedState | undefined>((resolve, reject) => {
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });

      if (result) {
        return result;
      }

      // Fallback / Migration: Check LocalStorage
      const legacyData = localStorage.getItem(LEGACY_STORAGE_KEY);
      if (legacyData) {
        console.log("Migrating data from LocalStorage to IndexedDB...");
        const parsedData = JSON.parse(legacyData);
        // Save to IDB
        await storageService.saveState(parsedData as GameState);
        // Clear Legacy
        localStorage.removeItem(LEGACY_STORAGE_KEY);
        return parsedData;
      }

      return null;
    } catch (e) {
      console.error("Memory Core Read Error:", e);
      return null;
    }
  },
```

## 第 113 页

**文件路径：frontend/services/storage.ts（续）**

```typescript

  /**
   * Clear all data (Factory Reset)
   */
  clearMemory: async () => {
    try {
      const db = await storageService.initDB();
      const transaction = db.transaction(STORE_NAME, "readwrite");
      const store = transaction.objectStore(STORE_NAME);
      store.clear();
      localStorage.removeItem(LEGACY_STORAGE_KEY);
      window.location.reload();
    } catch (e) {
      console.error("Failed to clear memory", e);
    }
  },

  /**
   * Generate backup string from current state (Synchronous helper for the UI)
   */
  exportBackup: (currentState: GameState): string => {
     const stateToSave: PersistedState = {
        userProfile: currentState.userProfile,
        selectedSceneId: currentState.selectedSceneId, 
        selectedCharacterId: currentState.selectedCharacterId,
        selectedScenarioId: currentState.selectedScenarioId,
        editingScenarioId: null, 
        history: currentState.history,
        customAvatars: currentState.customAvatars,
        customScenarios: currentState.customScenarios,
        customScenes: currentState.customScenes,
        customCharacters: currentState.customCharacters,
        journalEntries: currentState.journalEntries,
        settings: currentState.settings,
        mailbox: currentState.mailbox,
        lastLoginTime: currentState.lastLoginTime,
        sceneMemories: currentState.sceneMemories || {},
        userWorldScenes: currentState.userWorldScenes || [],
        showWelcomeOverlay: currentState.showWelcomeOverlay
      };
      return JSON.stringify(stateToSave);
  },

  /**
   * Validate and Restore data from a JSON string to IndexedDB
   */
  restoreBackup: async (jsonString: string): Promise<boolean> => {
    try {
      const data = JSON.parse(jsonString);
      // Basic validation: check if it looks like our state
      if (!data || typeof data !== 'object') {
        throw new Error("Invalid backup format");
      }
      // Check for a few key fields to ensure it's a HeartSphere backup
      if (!data.history && !data.userProfile && !data.settings) {
        throw new Error("Data does not contain HeartSphere memory structures");
      }

      // Save to IndexedDB
      await storageService.saveState(data as GameState);
      return true;
    } catch (e) {
      console.error("Restore failed:", e);
      return false;
    }
  },

  /**
   * Save custom scene mappings to IndexedDB
   */
  saveCustomSceneMappings: async (mappings: { [sceneId: string]: number }): Promise<void> => {
    try {
      const db = await storageService.initDB();
      const transaction = db.transaction(CUSTOM_SCENE_MAPPINGS_STORE, "readwrite");
      const store = transaction.objectStore(CUSTOM_SCENE_MAPPINGS_STORE);
      const request = store.put(mappings, 'customSceneMappings');

      return new Promise((resolve, reject) => {
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    } catch (e) {
      console.error("Failed to save custom scene mappings", e);
      throw e;
    }
  },

  /**
   * Get custom scene mappings from IndexedDB
   */
  getCustomSceneMappings: async (): Promise<{ [sceneId: string]: number } | null> => {
    try {
      const db = await storageService.initDB();
      const transaction = db.transaction(CUSTOM_SCENE_MAPPINGS_STORE, "readonly");
      const store = transaction.objectStore(CUSTOM_SCENE_MAPPINGS_STORE);
      const request = store.get('customSceneMappings');

      return new Promise((resolve, reject) => {
        request.onsuccess = () => resolve(request.result || null);
        request.onerror = () => reject(request.error);
      });
    } catch (e) {
      console.error("Failed to get custom scene mappings", e);
      return null;
    }
  }
};
```

## 第 114 页

**文件路径：frontend/components/EraMemoryModal.tsx**

```typescript

import React, { useState, useRef } from 'react';
import { WorldScene, EraMemory } from '../types';
import { imageApi } from '../services/api';
import { Button } from './Button';

interface EraMemoryModalProps {
  scene: WorldScene;
  memories: EraMemory[];
  onAddMemory: (content: string, imageUrl?: string) => void;
  onDeleteMemory: (memoryId: string) => void;
  onClose: () => void;
}

export const EraMemoryModal: React.FC<EraMemoryModalProps> = ({ scene, memories, onAddMemory, onDeleteMemory, onClose }) => {
  const [content, setContent] = useState('');
  const [imageUrl, setImageUrl] = useState<string | null>(null);
  const [isUploading, setIsUploading] = useState(false);
  const [uploadError, setUploadError] = useState('');
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    // 先显示预览（base64）
    const reader = new FileReader();
    reader.onloadend = () => {
      setImageUrl(reader.result as string);
    };
    reader.readAsDataURL(file);

    // 自动上传到服务器
    setIsUploading(true);
    setUploadError('');
    
    try {
      const token = localStorage.getItem('auth_token');
      const result = await imageApi.uploadImage(file, 'journal', token || undefined);
      
      if (result.success && result.url) {
        // 使用服务器返回的URL替换base64预览
        setImageUrl(result.url);
        console.log('图片上传成功:', result.url);
      } else {
        throw new Error(result.error || '上传失败');
      }
    } catch (err: any) {
      console.error('图片上传失败:', err);
      setUploadError('图片上传失败: ' + (err.message || '未知错误') + '。将使用本地预览。');
      // 保持base64预览
    } finally {
      setIsUploading(false);
    }
  };

  const handleSubmit = () => {
    if (!content.trim() && !imageUrl) return;
    onAddMemory(content, imageUrl || undefined);
    setContent('');
    setImageUrl(null);
  };

  return (
    <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-md p-4 animate-fade-in">
      <div className="bg-slate-900 border border-slate-700 rounded-2xl w-full max-w-4xl h-[85vh] flex flex-col md:flex-row overflow-hidden shadow-2xl">
        
        {/* Left Side: Memory Creator */}
        <div className="w-full md:w-1/3 bg-slate-950/50 p-6 flex flex-col border-r border-slate-800">
          <div className="mb-6">
            <h3 className="text-xl font-bold text-white mb-1">时代记忆</h3>
            <p className="text-sm text-slate-400">在 <span className="text-pink-400 font-bold">{scene.name}</span> 留下的印记</p>
          </div>

          <div className="flex-1 flex flex-col gap-4 overflow-y-auto">
            <textarea
              value={content}
              onChange={(e) => setContent(e.target.value)}
              placeholder="写下关于这个时代的回忆、故事，或者对它的印象..."
              className="w-full h-32 bg-slate-800/50 border border-slate-700 rounded-lg p-3 text-white placeholder-slate-500 focus:border-pink-500 outline-none resize-none text-sm"
            />
            
            <div 
              onClick={() => !isUploading && fileInputRef.current?.click()}
              className={`w-full h-32 border-2 border-dashed rounded-lg flex items-center justify-center transition-all overflow-hidden ${
                imageUrl ? 'border-pink-500' : isUploading ? 'border-blue-500 cursor-wait' : 'border-slate-700 hover:border-slate-500 hover:bg-slate-800 cursor-pointer'
              }`}
            >
              <input type="file" ref={fileInputRef} onChange={handleFileUpload} accept="image/*" className="hidden" disabled={isUploading} />
              {isUploading ? (
                <div className="flex flex-col items-center text-blue-400">
                  <div className="w-8 h-8 border-2 border-blue-400 border-t-transparent rounded-full animate-spin mb-2"></div>
                  <span className="text-xs">上传中...</span>
                </div>
              ) : imageUrl ? (
                <div className="relative w-full h-full">
                  <img src={imageUrl} alt="Preview" className="w-full h-full object-cover" />
                  <button 
                    onClick={(e) => {
                      e.stopPropagation();
                      setImageUrl(null);
                    }}
                    className="absolute top-2 right-2 bg-black/60 text-white rounded-full p-1 hover:bg-red-500 transition-colors"
                  >
                    ×
                  </button>
                </div>
              ) : (
                <div className="flex flex-col items-center text-slate-500">
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-8 h-8 mb-2">
                    <path strokeLinecap="round" strokeLinejoin="round" d="M2.25 15.75l5.159-5.159a2.25 2.25 0 013.182 0l5.159 5.159m-1.5-1.5l1.409-1.409a2.25 2.25 0 013.182 0l2.909 2.909m-18 3.75h16.5a2.25 2.25 0 002.25-2.25V6a2.25 2.25 0 00-2.25-2.25H3.75A2.25 2.25 0 001.5 6v12a2.25 2.25 0 002.25 2.25zm10.5-11.25h.008v.008h-.008V8.25zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0z" />
                  </svg>
                  <span className="text-xs">上传老照片 / 纪念物</span>
                </div>
              )}
            </div>
            {uploadError && <p className="text-xs text-red-400 mt-1">{uploadError}</p>}
            
            <Button onClick={handleSubmit} disabled={!content.trim() && !imageUrl} className="bg-pink-600 hover:bg-pink-500 mt-2">
              封存记忆
            </Button>
          </div>
          
          <button onClick={onClose} className="mt-6 text-slate-500 hover:text-white text-sm flex items-center gap-2">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-4 h-4">
              <path strokeLinecap="round" strokeLinejoin="round" d="M10.5 19.5L3 12m0 0l7.5-7.5M3 12h18" />
            </svg>
            返回时代
          </button>
        </div>

        {/* Right Side: Memory Gallery */}
        <div className="flex-1 bg-black/20 p-6 overflow-y-auto">
          {memories.length === 0 ? (
            <div className="h-full flex flex-col items-center justify-center text-slate-500 opacity-50">
              <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1} stroke="currentColor" className="w-24 h-24 mb-4">
                <path strokeLinecap="round" strokeLinejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
              <p>这里还没有回忆。</p>
            </div>
          ) : (
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              {[...memories].sort((a,b) => b.timestamp - a.timestamp).map(memory => (
                <div key={memory.id} className="bg-white/5 border border-white/10 rounded-xl overflow-hidden group hover:border-pink-500/30 transition-all">
                  {memory.imageUrl && (
                    <div className="h-48 w-full overflow-hidden relative">
                      <img src={memory.imageUrl} alt="Memory" className="w-full h-full object-cover transition-transform duration-700 group-hover:scale-105" />
                      <div className="absolute inset-0 bg-gradient-to-t from-black/80 to-transparent opacity-60" />
                    </div>
                  )}
                  <div className="p-4 relative">
                    <button 
                      onClick={() => onDeleteMemory(memory.id)}
                      className="absolute top-2 right-2 text-slate-600 hover:text-red-400 opacity-0 group-hover:opacity-100 transition-opacity"
                      title="删除"
                    >
                      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className="w-4 h-4">
                        <path fillRule="evenodd" d="M8.75 1A2.75 2.75 0 006 3.75v.443c-.795.077-1.584.176-2.365.298a.75.75 0 10.23 1.482l.149-.022.841 10.518A2.75 2.75 0 007.596 19h4.807a2.75 2.75 0 002.742-2.53l.841-10.52.149.023a.75.75 0 00.23-1.482A41.03 41.03 0 0014 4.193V3.75A2.75 2.75 0 0011.25 1h-2.5zM10 4c.84 0 1.673.025 2.5.075V3.75c0-.69-.56-1.25-1.25-1.25h-2.5c-.69 0-1.25.56-1.25 1.25v.325C8.327 4.025 9.16 4 10 4zM8.58 7.72a.75.75 0 00-1.5.06l.3 7.5a.75.75 0 101.5-.06l-.3-7.5zm4.34.06a.75.75 0 10-1.5-.06l-.3 7.5a.75.75 0 101.5.06l.3-7.5z" clipRule="evenodd" />
                      </svg>
                    </button>
                    <p className="text-slate-200 text-sm whitespace-pre-wrap font-serif leading-relaxed">
                      {memory.content}
                    </p>
                    <p className="text-xs text-slate-500 mt-3 border-t border-white/5 pt-2">
                      {new Date(memory.timestamp).toLocaleDateString()}
                    </p>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};
```

## 第 115 页

**文件路径：frontend/components/RealWorldJournal.tsx**

```typescript

import React, { useState } from 'react';
import { Button } from './Button';

interface RealWorldJournalProps {
  onQuestionSubmit: (question: string) => void;
}

export const RealWorldJournal: React.FC<RealWorldJournalProps> = ({ onQuestionSubmit }) => {
  const [text, setText] = useState('');

  const handleSubmit = () => {
    if (!text.trim()) return;
    onQuestionSubmit(text.trim());
    setText('');
  };

  return (
    <div className="bg-slate-800/50 border border-slate-700 rounded-2xl p-6 h-full flex flex-col">
      <div className="mb-4">
        <h3 className="text-2xl font-bold text-white/90">现实世界</h3>
        <p className="text-slate-400 text-sm">记录你的问题、经历或当下的心情。</p>
      </div>
      <textarea
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder="记下任何你想探索的事..."
        className="w-full flex-grow bg-slate-900/70 border-2 border-slate-700 rounded-lg py-3 px-4 text-white placeholder-slate-500 focus:border-pink-500 focus:ring-0 outline-none transition-colors resize-none text-base leading-relaxed scrollbar-hide"
      />
      <Button
        onClick={handleSubmit}
        disabled={!text.trim()}
        fullWidth
        className="mt-4 bg-gradient-to-r from-indigo-500 to-purple-600 !text-base"
      >
        带着这个问题进入心域
      </Button>
    </div>
  );
};
```

## 第 116 页

**文件路径：frontend/components/EraSelectionModal.tsx**

```typescript

import React from 'react';
import { Persona, Character } from '../types';

interface EraSelectionModalProps {
  persona: Persona;
  onSelect: (character: Character) => void;
  onClose: () => void;
}

export const EraSelectionModal: React.FC<EraSelectionModalProps> = ({ persona, onSelect, onClose }) => {
  return (
    <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4 animate-fade-in">
      <div className="bg-gray-800 border border-gray-700 rounded-2xl p-6 w-full max-w-2xl shadow-2xl">
        <div className="flex justify-between items-center mb-6">
          <div>
            <h3 className="text-2xl font-bold text-white">
              选择时代: <span className="text-purple-400">{persona.name}</span>
            </h3>
            <p className="text-sm text-gray-400">你想与哪个时期的TA相遇？</p>
          </div>
          <button onClick={onClose} className="text-gray-500 hover:text-white text-3xl">&times;</button>
        </div>
        
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          {persona.eras.map(character => (
            <div 
              key={character.id}
              onClick={() => onSelect(character)}
              className="group relative cursor-pointer overflow-hidden rounded-xl border border-gray-700 hover:border-purple-500/50 transition-all"
            >
              <img src={character.avatarUrl} alt={character.name} className="h-48 w-full object-cover" />
              <div className="absolute inset-0 bg-gradient-to-t from-black/80 to-transparent" />
              <div className="absolute bottom-0 left-0 p-3 text-white">
                <div 
                  className="px-2 py-0.5 text-xs font-bold rounded-full mb-1 inline-block"
                  style={{ backgroundColor: `${character.colorAccent}40`, color: character.colorAccent }}
                >
                  {character.era}
                </div>
                <h4 className="font-bold">{character.name}</h4>
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};
```

## 第 117 页

**文件路径：frontend/components/PersonaCard.tsx**

```typescript

import React from 'react';
import { Persona } from '../types';

interface PersonaCardProps {
  persona: Persona;
  onSelect: () => void;
}

export const PersonaCard: React.FC<PersonaCardProps> = ({ persona, onSelect }) => {
  return (
    <div 
      onClick={onSelect}
      className="group relative h-96 w-full cursor-pointer overflow-hidden rounded-3xl border border-white/10 shadow-2xl transition-all duration-500 hover:scale-[1.02] hover:border-purple-400/50"
    >
      <div className="absolute inset-0 bg-gray-900">
        <img 
          src={persona.avatarUrl} 
          alt={persona.name}
          className="h-full w-full object-cover transition-transform duration-700 group-hover:scale-110"
        />
        <div className="absolute inset-0 bg-gradient-to-t from-black/90 via-black/40 to-transparent opacity-80 transition-opacity group-hover:opacity-70" />
      </div>

      <div className="absolute bottom-0 left-0 w-full p-6">
        <div 
          className="mb-2 inline-block rounded-full px-3 py-1 text-xs font-bold backdrop-blur-md border bg-purple-500/20 text-purple-300 border-purple-400/30"
        >
          人格
        </div>
        <h3 className="mb-1 text-2xl font-bold text-white">
          {persona.name}
        </h3>
        <p className="text-sm text-white/70 line-clamp-2">
          {persona.description}
        </p>
      </div>
      
      <div className="absolute inset-0 rounded-3xl border-2 border-transparent opacity-0 transition-opacity duration-300 group-hover:opacity-100 group-hover:border-purple-400 pointer-events-none" />
    </div>
  );
};
```

## 第 118 页

**文件路径：frontend/utils/promptTemplates.ts（续）**

```typescript

  // 时代类提示词
  era: [
    {
      name: '二次元世界',
      prompt: 'Beautiful vertical world illustration, anime style, vibrant colors, detailed environment, epic feel, cinematic lighting, immersive atmosphere, 4K quality',
      description: '二次元风格世界场景'
    },
    {
      name: '写实世界',
      prompt: 'Photorealistic world scene, highly detailed, realistic lighting and textures, professional photography quality, immersive environment, 8K resolution',
      description: '写实风格世界场景'
    },
    {
      name: '奇幻世界',
      prompt: 'Fantasy world illustration, magical elements, epic scenes, mystical atmosphere, high fantasy aesthetic, detailed world-building, professional artwork',
      description: '奇幻风格世界场景'
    },
    {
      name: '赛博朋克世界',
      prompt: 'Cyberpunk cityscape, neon lights, futuristic technology, dark aesthetic, Blade Runner inspired, high-tech low-life atmosphere, cinematic composition',
      description: '赛博朋克风格世界'
    },
    {
      name: '古风世界',
      prompt: 'Traditional Chinese world scene, ancient architecture, classical beauty, ink painting aesthetic, cultural heritage, refined details, elegant atmosphere',
      description: '中国古风世界场景'
    },
    {
      name: '蒸汽朋克世界',
      prompt: 'Steampunk world illustration, Victorian era aesthetics, brass and copper machinery, gears and cogs, retro-futuristic technology, detailed design',
      description: '蒸汽朋克风格世界'
    },
    {
      name: '未来科幻世界',
      prompt: 'Futuristic sci-fi world, advanced technology, space elements, high-tech environment, epic scale, cinematic lighting, professional illustration',
      description: '未来科幻风格世界'
    },
    {
      name: '自然风景',
      prompt: 'Beautiful natural landscape, serene atmosphere, detailed environment, natural lighting, peaceful scene, high quality, professional photography',
      description: '自然风景场景'
    }
  ],

  // 剧本类提示词
  scenario: [
    {
      name: '剧情场景',
      prompt: 'Dramatic scene illustration, storytelling atmosphere, detailed composition, cinematic lighting, emotional depth, professional artwork, immersive setting',
      description: '剧情场景图'
    },
    {
      name: '对话场景',
      prompt: 'Conversation scene, character interaction, detailed environment, natural lighting, storytelling composition, professional illustration',
      description: '对话场景图'
    },
    {
      name: '战斗场景',
      prompt: 'Action scene, dynamic composition, intense atmosphere, dramatic lighting, detailed action, epic scale, professional artwork',
      description: '战斗场景图'
    },
    {
      name: '温馨场景',
      prompt: 'Warm and cozy scene, soft lighting, peaceful atmosphere, detailed environment, emotional warmth, professional illustration',
      description: '温馨场景图'
    }
  ],

  // 日记类提示词
  journal: [
    {
      name: '日常记录',
      prompt: 'Daily life scene, natural lighting, realistic atmosphere, detailed environment, personal moment, professional photography quality',
      description: '日常记录场景'
    },
    {
      name: '回忆场景',
      prompt: 'Nostalgic scene, soft lighting, emotional atmosphere, memory-like quality, detailed composition, artistic photography',
      description: '回忆场景图'
    },
    {
      name: '心情记录',
      prompt: 'Emotional scene, atmospheric lighting, expressive composition, detailed environment, mood-based design, professional artwork',
      description: '心情记录场景'
    }
  ],

  // 通用类提示词
  general: [
    {
      name: '抽象艺术',
      prompt: 'Abstract art, creative composition, artistic design, vibrant colors, unique style, professional artwork, high quality',
      description: '抽象艺术作品'
    },
    {
      name: '装饰图案',
      prompt: 'Decorative pattern, elegant design, detailed ornamentation, artistic style, refined aesthetics, professional illustration',
      description: '装饰图案'
    },
    {
      name: '图标设计',
      prompt: 'Icon design, clean lines, modern aesthetic, simple yet detailed, professional graphic design, high quality',
      description: '图标设计'
    }
  ]
};

/**
 * 根据分类获取提示词模板
 */
export function getPromptTemplates(category: string): string[] {
  const templates = PROMPT_TEMPLATES[category] || [];
  return templates.map(t => t.prompt);
}

/**
 * 获取所有模板（用于选择）
 */
export function getAllTemplatesForCategory(category: string): PromptTemplate[] {
  return PROMPT_TEMPLATES[category] || [];
}
```

## 第 119 页

**文件路径：backend/src/main/java/com/heartsphere/controller/ImageController.java**

```java

package com.heartsphere.controller;

import com.heartsphere.service.ImageStorageService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.HashMap;
import java.util.Map;
import java.util.logging.Logger;

@CrossOrigin(origins = "*")
@RestController
@RequestMapping("/api/images")
public class ImageController {

    private static final Logger logger = Logger.getLogger(ImageController.class.getName());

    @Autowired
    private ImageStorageService imageStorageService;

    /**
     * 上传图片文件
     * @param file 图片文件
     * @param category 图片分类（可选，默认为general）
     */
    @PostMapping("/upload")
    public ResponseEntity<Map<String, Object>> uploadImage(
            @RequestParam("file") MultipartFile file,
            @RequestParam(value = "category", defaultValue = "general") String category) {
        logger.info("========== 收到图片上传请求 ==========");
        logger.info("文件名: " + (file != null ? file.getOriginalFilename() : "null"));
        logger.info("文件大小: " + (file != null ? file.getSize() + " bytes" : "null"));
        logger.info("文件类型: " + (file != null ? file.getContentType() : "null"));
        logger.info("分类: " + category);
        
        try {
            String imageUrl = imageStorageService.saveImage(file, category);
            logger.info("图片上传成功，URL: " + imageUrl);
            Map<String, Object> response = new HashMap<>();
            response.put("success", true);
            response.put("url", imageUrl);
            response.put("message", "图片上传成功");
            logger.info("========== 图片上传请求处理完成 ==========");
            return ResponseEntity.ok(response);
        } catch (IllegalArgumentException e) {
            Map<String, Object> response = new HashMap<>();
            response.put("success", false);
            response.put("error", e.getMessage());
            return ResponseEntity.badRequest().body(response);
        } catch (Exception e) {
            Map<String, Object> response = new HashMap<>();
            response.put("success", false);
            response.put("error", "图片上传失败: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }

    /**
     * 上传Base64图片
     * @param request 包含base64数据和分类的请求体
     */
    @PostMapping("/upload-base64")
    public ResponseEntity<Map<String, Object>> uploadBase64Image(@RequestBody Map<String, String> request) {
        try {
            String base64Data = request.get("base64");
            String category = request.getOrDefault("category", "general");
            
            if (base64Data == null || base64Data.isEmpty()) {
                Map<String, Object> response = new HashMap<>();
                response.put("success", false);
                response.put("error", "Base64数据不能为空");
                return ResponseEntity.badRequest().body(response);
            }

            String imageUrl = imageStorageService.saveBase64Image(base64Data, category);
            Map<String, Object> response = new HashMap<>();
            response.put("success", true);
            response.put("url", imageUrl);
            response.put("message", "图片上传成功");
            return ResponseEntity.ok(response);
        } catch (IllegalArgumentException e) {
            Map<String, Object> response = new HashMap<>();
            response.put("success", false);
            response.put("error", e.getMessage());
            return ResponseEntity.badRequest().body(response);
        } catch (Exception e) {
            Map<String, Object> response = new HashMap<>();
            response.put("success", false);
            response.put("error", "图片上传失败: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }

    /**
     * 删除图片
     */
    @DeleteMapping("/delete")
    public ResponseEntity<Map<String, Object>> deleteImage(@RequestParam("url") String imageUrl) {
        try {
            boolean deleted = imageStorageService.deleteImage(imageUrl);
            Map<String, Object> response = new HashMap<>();
            if (deleted) {
                response.put("success", true);
                response.put("message", "图片删除成功");
            } else {
                response.put("success", false);
                response.put("message", "图片不存在或已删除");
            }
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            Map<String, Object> response = new HashMap<>();
            response.put("success", false);
            response.put("error", "删除失败: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
}
```

## 第 120 页

**文件路径：backend/src/main/java/com/heartsphere/controller/MembershipController.java**

```java

package com.heartsphere.controller;

import com.heartsphere.entity.Membership;
import com.heartsphere.entity.SubscriptionPlan;
import com.heartsphere.security.UserDetailsImpl;
import com.heartsphere.service.MembershipService;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

/**
 * 会员管理API
 */
@RestController
@RequestMapping("/api/membership")
@RequiredArgsConstructor
public class MembershipController {

    private final MembershipService membershipService;

    /**
     * 获取当前用户的会员信息
     */
    @GetMapping("/current")
    public ResponseEntity<MembershipResponse> getCurrentMembership(Authentication authentication) {
        if (authentication == null || authentication.getPrincipal() == null) {
            return ResponseEntity.status(401).build();
        }
        UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
        Long userId = userDetails.getId();
        Membership membership = membershipService.getUserMembership(userId)
                .orElseGet(() -> membershipService.getOrCreateFreeMembership(userId));

        MembershipResponse response = new MembershipResponse();
        response.setId(membership.getId());
        response.setPlanType(membership.getPlanType());
        response.setBillingCycle(membership.getBillingCycle());
        response.setStatus(membership.getStatus());
        response.setStartDate(membership.getStartDate());
        response.setEndDate(membership.getEndDate());
        response.setAutoRenew(membership.getAutoRenew());
        response.setNextRenewalDate(membership.getNextRenewalDate());
        response.setCurrentPoints(membership.getCurrentPoints());
        response.setTotalPointsEarned(membership.getTotalPointsEarned());
        response.setTotalPointsUsed(membership.getTotalPointsUsed());

        return ResponseEntity.ok(response);
    }

    /**
     * 获取所有订阅计划
     */
    @GetMapping(value = "/plans", produces = "application/json;charset=UTF-8")
    public ResponseEntity<List<SubscriptionPlanResponse>> getAllPlans(
            @RequestParam(required = false) String billingCycle) {
        List<SubscriptionPlan> plans;
        if (billingCycle != null && !billingCycle.isEmpty()) {
            plans = membershipService.getPlansByBillingCycle(billingCycle);
        } else {
            plans = membershipService.getAllPlans();
        }

        List<SubscriptionPlanResponse> responses = plans.stream()
                .map(plan -> {
                    SubscriptionPlanResponse resp = new SubscriptionPlanResponse();
                    resp.setId(plan.getId());
                    resp.setName(plan.getName());
                    resp.setType(plan.getType());
                    resp.setBillingCycle(plan.getBillingCycle());
                    resp.setPrice(plan.getPrice());
                    resp.setOriginalPrice(plan.getOriginalPrice());
                    resp.setDiscountPercent(plan.getDiscountPercent());
                    resp.setPointsPerMonth(plan.getPointsPerMonth());
                    resp.setMaxImagesPerMonth(plan.getMaxImagesPerMonth());
                    resp.setMaxVideosPerMonth(plan.getMaxVideosPerMonth());
                    resp.setFeatures(plan.getFeatures());
                    return resp;
                })
                .toList();

        return ResponseEntity.ok(responses);
    }

    @Data
    public static class MembershipResponse {
        private Long id;
        private String planType;
        private String billingCycle;
        private String status;
        private java.time.LocalDateTime startDate;
        private java.time.LocalDateTime endDate;
        private Boolean autoRenew;
        private java.time.LocalDateTime nextRenewalDate;
        private Integer currentPoints;
        private Integer totalPointsEarned;
        private Integer totalPointsUsed;
    }

    @Data
    public static class SubscriptionPlanResponse {
        private Long id;
        private String name;
        private String type;
        private String billingCycle;
        private java.math.BigDecimal price;
        private java.math.BigDecimal originalPrice;
        private Integer discountPercent;
        private Integer pointsPerMonth;
        private Integer maxImagesPerMonth;
        private Integer maxVideosPerMonth;
        private String features;
    }
}
```
```

## 第 119 页

**文件路径：frontend/services/gemini.ts（续）**

```typescript
  async sendMessageStream(
    character: Character, 
    history: Message[], 
    userMessage: string,
    userProfile: UserProfile | null
  ): Promise<AsyncIterable<GenerateContentResponse>> {
    
    const providers = this.getPrioritizedProviders('text');
    let lastError = null;

    for (const provider of providers) {
        try {
            const config = this.getConfigForProvider(provider);
            const effectiveKey = config?.apiKey || (provider === 'gemini' ? process.env.API_KEY : '');
            
            if (!config || !effectiveKey) {
                 if (providers.length === 1) throw new Error(`${provider} API Key missing.`);
                 continue;
            }
            
            this.log('sendMessageStream', 'attempt', { provider }, config.modelName);

            // 1. OpenAI / Qwen / Doubao
            if (provider === 'openai' || provider === 'qwen' || provider === 'doubao') {
                const scenarioContext = createScenarioContext(userProfile);
                
                // --- DEEP CHARACTER INJECTION (Duplicate logic for generic providers) ---
                let deepCharacterPrompt = `YOUR CHARACTER INSTRUCTION:\n${character.systemInstruction}`;
                if (character.mbti) deepCharacterPrompt += `\nMBTI: ${character.mbti}`;
                if (character.speechStyle) deepCharacterPrompt += `\nSpeaking Style: ${character.speechStyle}`;
                if (character.catchphrases) deepCharacterPrompt += `\nCommon Phrases: ${character.catchphrases.join(', ')}`;
                if (character.secrets) deepCharacterPrompt += `\nSecrets: ${character.secrets}`;
                // -----------------------------------------------------------------------

                const combinedInstruction = `${scenarioContext}\n\n${deepCharacterPrompt}`;
                
                const messages = formatOpenAIHistory(history, combinedInstruction);
                messages.push({ role: 'user', content: userMessage });
                
                const response = await this.initOpenAIStreamRequest({ ...config, apiKey: effectiveKey }, messages);
                return this.parseOpenAIStream(response);
            }
            // 2. Gemini
            else {
                 let historyForInit = history;
                 if (history.length > 0) {
                    const lastMsg = history[history.length - 1];
                    if (lastMsg.role === 'user' && lastMsg.text === userMessage) {
                        historyForInit = history.slice(0, -1);
                    }
                 }
                 const chat = this.getSession(character, historyForInit, userProfile);
                 return await chat.sendMessageStream({ message: userMessage });
            }

        } catch (e) {
             console.warn(`sendMessageStream failed on ${provider}`, e);
             this.log('sendMessageStream', 'error_fallback', { provider, error: e });
             lastError = e;
             if (provider === 'gemini') this.chatSessions.delete(character.id);
             continue; // Try next provider
        }
    }
    throw lastError || new Error("All text providers failed for streaming");
  }
```

## 第 120 页

**文件路径：frontend/services/gemini.ts（续）**

```typescript
  // --- Era & Character Constructor ---
  async generateCharacterFromPrompt(prompt: string, eraName: string): Promise<Character | null> {
    return this.retry(async () => {
       try {
        const systemPrompt = `You are a creative writer. Create a complete character profile for a world/era named "${eraName}".
            Output JSON only with these properties: 
            - name, age (number), role, bio
            - systemInstruction (detailed roleplay instructions)
            - firstMessage (greeting)
            - themeColor (hex), colorAccent (hex)
            - mbti (e.g. INFJ)
            - tags (array of strings, personality keywords)
            - speechStyle (description of how they talk)
            - catchphrases (array of strings, 2-3 common phrases)
            - secrets (hidden depth/secret)
            - motivations (current goal)
            
            The content MUST be in Chinese.`;
        const userPrompt = `Character concept: "${prompt}".`;

        const responseText = await this.generateText(userPrompt, systemPrompt, true);
        
        const jsonStr = responseText.replace(/```json/g, '').replace(/```/g, '').trim();
        const details = JSON.parse(jsonStr);

        // DO NOT Auto Generate Image to save cost. Use placeholder.
        let avatarUrl = 'https://picsum.photos/seed/default_avatar/400/600';
        let backgroundUrl = 'https://picsum.photos/seed/default_bg/1080/1920';

        const newCharacter: Character = {
            id: `custom_${Date.now()}`,
            voiceName: 'Kore', 
            ...details,
            avatarUrl,
            backgroundUrl
        };
        return newCharacter;
       } catch (e) {
         this.log('generateCharacterFromPrompt', 'error', e);
         throw e;
       }
    }, 2, 3000);
  }

  async generateScenarioFromPrompt(prompt: string): Promise<CustomScenario | null> {
      return this.retry(async () => {
        try {
            const systemPrompt = `You are a creative director for an interactive visual novel game.
            Based on the user's idea, generate a branching scenario structure in JSON format.
            JSON Structure: { "title": "...", "description": "...", "startNodeId": "node_1", "nodes": { "node_1": { "id": "node_1", "title": "...", "prompt": "...", "options": [...] } } }
            Create at least 3-4 nodes with choices. The content MUST be in Chinese.`;

            const responseText = await this.generateText(prompt, systemPrompt, true);
            const jsonStr = responseText.replace(/```json/g, '').replace(/```/g, '').trim();
            const scenarioData = JSON.parse(jsonStr);

            const scenario: CustomScenario = {
                id: `scenario_${Date.now()}`,
                sceneId: '', 
                author: 'AI Architect',
                ...scenarioData
            };
            return scenario;
        } catch (e) {
            this.log('generateScenarioFromPrompt', 'error', e);
            throw e;
        }
      }, 2, 3000); 
  }
```

## 第 121 页

**文件路径：frontend/services/gemini.ts（续）**

```typescript
  // --- Image Generation ---
  async generateImageFromPrompt(prompt: string, aspectRatio: '1:1' | '16:9' | '9:16' | '3:4' | '4:3' = '1:1'): Promise<string | null> {
    const providers = this.getPrioritizedProviders('image');
    for (const provider of providers) {
        try {
            const result = await this.executeImageGeneration(provider, prompt, aspectRatio);
            if (result) return result;
        } catch (e: any) {
            console.warn(`Image gen failed on ${provider}`, e);
            this.log('generateImage', 'fallback_error', { provider, error: e?.message || e });
            continue;
        }
    }
    return null;
  }

  // --- Video Generation ---
  async generateVideoFromPrompt(prompt: string): Promise<string | null> {
      const providers = this.getPrioritizedProviders('video');
      for (const provider of providers) {
          try {
              const result = await this.executeVideoGeneration(provider, prompt);
              if (result) return result;
          } catch(e) {
              console.warn(`Video gen failed on ${provider}`, e);
              continue;
          }
      }
      return null;
  }

  // --- Prompt Constructors (Cost Saving) ---
  constructEraCoverPrompt(name: string, description: string, worldStyle?: string): string {
      const styleSuffix = worldStyle ? this.getStylePromptSuffix(worldStyle) : 'Style: Modern Chinese Anime (Manhua), cinematic lighting, vibrant, epic feel.';
      return `A beautiful, high-quality vertical world illustration for a world named "${name}". The theme is: "${description}". ${styleSuffix}`;
  }

  constructCharacterAvatarPrompt(name: string, role: string, bio: string, themeColor: string, worldStyle?: string): string {
      const styleSuffix = worldStyle ? this.getStylePromptSuffix(worldStyle) : 'Style: Modern Chinese Anime (Manhua), vibrant colors, detailed eyes.';
      return `High-quality vertical character portrait of ${name}. Role: ${role}. Description: ${bio}. ${styleSuffix} Centered character, abstract background matching theme color ${themeColor}.`;
  }

  constructCharacterBackgroundPrompt(name: string, bio: string, eraName: string, worldStyle?: string): string {
      const styleSuffix = worldStyle ? this.getStylePromptSuffix(worldStyle) : 'Style: Modern Chinese Anime (Manhua), high quality, cinematic lighting.';
      return `Atmospheric background scene for the world of "${eraName}". It should match the personality of a character named ${name}, described as: "${bio}". ${styleSuffix}`;
  }
```

## 第 122 页

**文件路径：frontend/services/gemini.ts（续）**

```typescript
  constructUserAvatarPrompt(nickname: string, worldStyle?: string): string {
      const styleSuffix = worldStyle ? this.getStylePromptSuffix(worldStyle) : 'Style: Modern Anime, Cyberpunk, or Dreamy Digital Art.';
      return `Profile avatar for a user named "${nickname}". ${styleSuffix} High quality, centered face or symbol.`;
  }

  constructMoodPrompt(content: string, worldStyle?: string): string {
      const styleSuffix = worldStyle ? this.getStylePromptSuffix(worldStyle) : 'Style: Ethereal, Dreamlike, Digital Art, vibrant colors, expressive brushstrokes.';
      return `Abstract, artistic, high-quality illustration representing this emotion/thought: "${content.substring(0, 100)}...". ${styleSuffix}`;
  }

  // Helper method to get style prompt suffix
  private getStylePromptSuffix(worldStyle: string): string {
      // Import WORLD_STYLE_DESCRIPTIONS dynamically or use a switch
      const styleMap: Record<string, string> = {
          'anime': 'Style: Modern Chinese Anime (Manhua), vibrant colors, detailed eyes, expressive emotions, cinematic lighting.',
          'realistic': 'Style: Photorealistic, highly detailed, realistic lighting and textures, professional photography quality.',
          'cyberpunk': 'Style: Cyberpunk, neon lights, futuristic technology, dark aesthetic, Blade Runner inspired, high-tech low-life atmosphere.',
          'fantasy': 'Style: Fantasy art, magical elements, epic scenes, mystical atmosphere, high fantasy aesthetic, detailed world-building.',
          'steampunk': 'Style: Steampunk, Victorian era aesthetics, brass and copper machinery, gears and cogs, retro-futuristic technology.',
          'minimalist': 'Style: Minimalist, clean lines, elegant simplicity, modern design, ample white space, refined aesthetics.',
          'watercolor': 'Style: Watercolor painting, soft brushstrokes, dreamy color gradients, artistic and ethereal, flowing pigments.',
          'oil-painting': 'Style: Oil painting, classical art, rich brushstrokes and texture, Renaissance or Baroque inspired, artistic depth.'
      };
      return styleMap[worldStyle] || styleMap['anime'];
  }

  // --- Avatar Gen Wrapper (Legacy/Direct) ---
  async generateCharacterImage(character: Character, worldStyle?: string): Promise<string | null> {
      const prompt = this.constructCharacterAvatarPrompt(character.name, character.role, character.bio, character.themeColor, worldStyle);
      return this.generateImageFromPrompt(prompt, '3:4');
  }

  // --- User Avatar Gen ---
  async generateUserAvatar(nickname: string, worldStyle?: string): Promise<string | null> {
      const prompt = this.constructUserAvatarPrompt(nickname, worldStyle);
      return this.generateImageFromPrompt(prompt, '1:1');
  }
```

## 第 123 页

**文件路径：frontend/services/gemini.ts（续）**

```typescript
  // --- TTS ---
  async generateSpeech(text: string, voiceName: string): Promise<string | null> {
    if (this.settings?.audioProvider !== 'gemini' && !this.settings?.enableFallback) return null;
    
    const providers = this.getPrioritizedProviders('audio');
    if (!providers.includes('gemini')) return null;

    const config = this.getConfigForProvider('gemini');
    const model = 'gemini-2.5-flash-preview-tts';
    this.log('generateSpeech', 'request', { text, voiceName }, model, 'gemini');
    
    const effectiveKey = config?.apiKey || process.env.API_KEY;

    return this.retry(async () => {
        // Safe Client Creation
        const client = effectiveKey ? new GoogleGenAI({apiKey: effectiveKey}) : this.ai;
        if (!client) throw new Error("Gemini API Key missing for TTS");

        const response = await client.models.generateContent({
            model: model,
            contents: { parts: [{ text }] },
            config: {
                responseModalities: [Modality.AUDIO],
                speechConfig: {
                    voiceConfig: { prebuiltVoiceConfig: { voiceName: voiceName || 'Kore' } }
                }
            }
        });
        const audioData = response.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
        if (audioData) {
            this.log('generateSpeech', 'success', 'Audio generated', model, 'gemini');
            return audioData;
        }
        throw new Error("No audio data returned");
    });
  }

  // --- Story & Logic Helpers ---

  async generateStoryBeatStream(
    node: StoryNode, 
    history: Message[], 
    choiceText: string | null,
    userProfile: UserProfile | null
  ): Promise<AsyncIterable<GenerateContentResponse>> {
      
      const scenarioContext = createScenarioContext(userProfile);
      const prompt = `
      CURRENT SCENE: "${node.title}"
      SCENE PROMPT: "${node.prompt}"
      USER CHOICE: "${choiceText || 'Scene Start'}"
      
      Narrate the story outcome based on the prompt and user choice. 
      Be immersive and descriptive.
      `;

      const narratorChar: Character = {
          id: 'narrator_temp',
          name: 'Narrator',
          role: 'Narrator',
          age: 0,
          bio: 'System Narrator',
          avatarUrl: '', backgroundUrl: '', themeColor: '', colorAccent: '', firstMessage: '', voiceName: '',
          systemInstruction: `You are the interactive story narrator. ${scenarioContext}`
      };

      let historyForGen = history;
      if (choiceText && history.length > 0) {
          const lastMsg = history[history.length - 1];
          if (lastMsg.role === 'user' && lastMsg.text === choiceText) {
              historyForGen = history.slice(0, -1);
          }
      }

      return this.sendMessageStream(narratorChar, historyForGen, prompt, userProfile);
  }
```

## 第 124 页

**文件路径：frontend/services/gemini.ts（续）**

```typescript
  async generateSceneDescription(history: Message[]): Promise<string | null> {
      const prompt = "Summarize the current visual setting and atmosphere of the story based on the last few messages. Keep it concise (1-2 sentences), focusing on visual elements for image generation.";
      const context = history.slice(-6).map(m => `${m.role}: ${m.text}`).join('\n');
      return this.generateText(`${prompt}\n\nSTORY CONTEXT:\n${context}`);
  }

  async generateWisdomEcho(history: Message[], characterName: string): Promise<string | null> {
      const prompt = `Analyze the conversation history. Extract a single, profound, and memorable quote (max 30 words) that represents the core wisdom or emotional comfort provided by ${characterName}. Output ONLY the quote.`;
      const context = history.map(m => `${m.role}: ${m.text}`).join('\n');
      return this.generateText(`${prompt}\n\nCONVERSATION:\n${context}`);
  }

  // --- NEW: Mirror Insight ---
  async generateMirrorInsight(journalContent: string, pastEntries: string[]): Promise<string | null> {
      const prompt = `You are the "Mirror of Truth" (本我镜像). Analyze the user's journal entry and their past patterns (if any).
      Your goal is to provide a sharp, psychological insight about their subconscious desires, fears, or hidden strengths.
      
      Style Guidelines:
      - Be objective but supportive.
      - Be slightly mysterious, like a tarot reading or a Jungian analysis.
      - Keep it under 50 words.
      - Speak in Chinese.
      `;
      const context = `CURRENT ENTRY: ${journalContent}\n\nPAST ENTRIES CONTEXT:\n${pastEntries.join('\n')}`;
      
      try {
          return await this.generateText(`${prompt}\n\nCONTEXT:\n${context}`);
      } catch (e) {
          console.error("Mirror insight failed", e);
          return null;
      }
  }

  async generateMoodImage(text: string, worldStyle?: string): Promise<string | null> {
      const prompt = this.constructMoodPrompt(text, worldStyle);
      return this.generateImageFromPrompt(prompt, '16:9');
  }

  async generateChronosLetter(sender: Character, userProfile: UserProfile, journalEntries: JournalEntry[]): Promise<{subject: string, content: string} | null> {
      const randomEntry = journalEntries.length > 0 ? journalEntries[Math.floor(Math.random() * journalEntries.length)] : null;
      const memoryContext = randomEntry ? `I remember you wrote about "${randomEntry.title}"...` : '';

      const prompt = `Write a warm, personal letter to ${userProfile.nickname}.
      You haven't seen them in a while. 
      Mention something specific about their journey or the "memory" provided below to show you care.
      MEMORY CONTEXT: ${memoryContext}
      Output JSON with "subject" and "content".`;

      const system = `You are ${sender.name} (${sender.role}). ${sender.systemInstruction}`;
      
      try {
          const text = await this.generateText(prompt, system, true);
          const jsonStr = text.replace(/```json/g, '').replace(/```/g, '').trim();
          return JSON.parse(jsonStr);
      } catch (e) {
          console.error("Letter generation failed", e);
          return null;
      }
  }
```

## 第 125 页

**文件路径：frontend/services/gemini.ts（续）**

```typescript
  async analyzeImageForEra(base64Image: string): Promise<{name: string, description: string} | null> {
    const providers = this.getPrioritizedProviders('text');
    if (!providers.includes('gemini') && !this.settings?.enableFallback) return null;

    const config = this.getConfigForProvider('gemini');
    const effectiveKey = config?.apiKey || process.env.API_KEY;
    if (!effectiveKey) return null;
    
    const model = 'gemini-2.5-flash';
    this.log('analyzeImageForEra', 'request', 'Image analysis', model, 'gemini');
    
    return this.retry(async () => {
        const client = new GoogleGenAI({apiKey: effectiveKey});
        const response = await client.models.generateContent({
            model: model,
            contents: {
                parts: [
                    { inlineData: { mimeType: 'image/jpeg', data: base64Image.split(',')[1] } },
                    { text: "Analyze this image. Suggest a creative title (name) and a short atmospheric description for a fictional world or era based on it. Output JSON with 'name' and 'description' keys. The content MUST be in Chinese." }
                ]
            },
            config: { responseMimeType: "application/json" }
        });

        if (response.text) {
             const jsonStr = response.text.replace(/```json/g, '').replace(/```/g, '').trim();
             return JSON.parse(jsonStr);
        }
        return null;
    });
  }

  // --- Daily Greeting Generation ---
  async generateDailyGreeting(recentEntries: JournalEntry[], userName?: string): Promise<{greeting: string, question: string} | null> {
    console.log("========== [GeminiService] 生成每日问候 ==========");
    console.log(`[GeminiService] 最近日记数量: ${recentEntries.length}, 用户名: ${userName || '未提供'}`);
    
    const providers = this.getPrioritizedProviders('text');
    let lastError = null;

    for (const provider of providers) {
        try {
            const config = this.getConfigForProvider(provider);
            const effectiveKey = config?.apiKey || (provider === 'gemini' ? process.env.API_KEY : '');
            
            if (!config || !effectiveKey) {
                if (providers.length === 1) throw new Error(`${provider} API Key missing.`);
                continue;
            }

            this.log('generateDailyGreeting', 'attempt', { provider }, config.modelName || 'default');

            // 构建提示词
            let prompt = '';
            let systemInstruction = '';

            // 构建最近日记上下文
            let recentEntriesContext = '';
            if (recentEntries.length > 0) {
                recentEntriesContext = recentEntries.slice(-3).map((entry, index) => 
                    `日记${index + 1}（${new Date(entry.timestamp).toLocaleDateString()}）：\n标题：${entry.title}\n内容：${entry.content.substring(0, 300)}${entry.content.length > 300 ? '...' : ''}`
                ).join('\n\n');
            } else {
                recentEntriesContext = '暂无日记记录';
            }
```

## 第 126 页

**文件路径：frontend/services/gemini.ts（续）**

```typescript
            // 使用新的提示词模板
            systemInstruction = `You are a gentle, philosophical AI companion in the "HeartSphere" world.
Your goal is to greet the user and ask a deep, thought-provoking question to help them start journaling.

Context:
- User Name: ${userName || '旅人'}
- Recent Journal Entries (if any): 
${recentEntriesContext}

Instructions:
1. Write a short, warm greeting (1 sentence). If they haven't written in a while, welcome them back gently.
2. Write a single, insightful question (prompt) based on their recent themes (e.g., if they were sad, ask about healing; if happy, ask about gratitude).
3. If no entries, ask a universal question about their current state or dreams.
4. Output strictly in JSON format: { "greeting": "...", "prompt": "..." }
5. Language: Chinese. Tone: Poetic, empathetic, calm.`;

            prompt = '请生成问候和问题。';

            const responseText = await this.executeTextGeneration(provider, prompt, systemInstruction, true);
            
            // 解析JSON响应
            const jsonStr = responseText.replace(/```json/g, '').replace(/```/g, '').trim();
            const result = JSON.parse(jsonStr);
            
            console.log("[GeminiService] 问候生成成功:", {
                greetingLength: result.greeting?.length || 0,
                questionLength: result.question?.length || 0
            });
            
            this.log('generateDailyGreeting', 'success', { 
                hasGreeting: !!result.greeting, 
                hasQuestion: !!result.question 
            }, config.modelName || 'default', provider);
            
            return {
                greeting: result.greeting || '你好，今天想记录些什么呢？',
                question: result.prompt || result.question || '今天有什么让你印象深刻的事吗？'
            };
        } catch (e) {
            console.warn(`generateDailyGreeting failed on ${provider}`, e);
            this.log('generateDailyGreeting', 'error_fallback', { provider, error: e });
            lastError = e;
            continue;
        }
    }
    
    // 如果所有provider都失败，返回默认问候
    console.warn("[GeminiService] 所有provider失败，使用默认问候");
    return {
        greeting: recentEntries.length === 0 
            ? '欢迎来到现实记录。这里是你的内心世界，记录下每一个真实的瞬间。'
            : '你好，我注意到你最近记录了一些想法。继续探索你的内心世界吧。',
        question: recentEntries.length === 0
            ? '今天有什么让你印象深刻的事吗？'
            : '今天想记录些什么新的想法呢？'
    };
  }
}

export const geminiService = new GeminiService();
```

## 第 127 页

**文件路径：frontend/App.tsx（续）**

```typescript
  useEffect(() => {
    loadGameData();
    syncService.init(); // 初始化同步服务
  }, []);

  useEffect(() => {
    if (!isLoaded) return; 

    geminiService.updateConfig(gameState.settings);

    const timer = setTimeout(() => {
      const stateToSave = { ...gameState, lastLoginTime: Date.now() };
      storageService.saveState(stateToSave);
    }, 1000);

    return () => clearTimeout(timer);
  }, [gameState, isLoaded]);

  // Logging hook
  useEffect(() => {
      geminiService.setLogCallback((log: DebugLog) => {
          setGameState((prevGameState: GameState) => ({
              ...prevGameState,
              debugLogs: [...prevGameState.debugLogs, log]
          }));
      });
  }, []);

  // Responsive adaptation listener
  useEffect(() => {
    const handleResize = () => {
      const shouldBeMobile = checkIsMobile();
      if (shouldBeMobile !== isMobileMode) {
        // If switching FROM PC to Mobile, save PC state first
        if (!isMobileMode) {
            storageService.saveState({ ...gameStateRef.current, lastLoginTime: Date.now() });
        }
        setIsMobileMode(shouldBeMobile);
        
        // If switching FROM Mobile to PC, we need to reload data because MobileApp maintained its own state
        if (!shouldBeMobile) {
            // Delay slightly to ensure DB write finishes if MobileApp was unmounting
            setTimeout(() => loadGameData(), 200); 
        }
      }
    };

    // Debounce resize
    let timeoutId: any;
    const debouncedResize = () => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(handleResize, 300);
    };

    window.addEventListener('resize', debouncedResize);
    return () => {
        window.removeEventListener('resize', debouncedResize);
        clearTimeout(timeoutId);
    };
  }, [isMobileMode]); 

  // Mail check
  useEffect(() => {
    if (!isLoaded || !gameState.userProfile || hasCheckedMail.current) return;
    const checkMail = async () => {
        hasCheckedMail.current = true;
        const now = Date.now();
        const offlineDuration = now - gameState.lastLoginTime;
        const THRESHOLD = 60 * 1000; 

        if (offlineDuration > THRESHOLD) {
            const chattedCharIds = Object.keys(gameState.history);
            let candidate: Character | null = null;
            if (chattedCharIds.length > 0) {
                 const allScenes = [...getCurrentScenes(), ...gameState.customScenes];
                 for (const scene of allScenes) {
                     const sceneChars = [...scene.characters, ...(gameState.customCharacters[scene.id] || [])];
                     const found = sceneChars.find(c => c.id === chattedCharIds[0]);
                     if (found) { candidate = found; break; }
                 }
            }
            if (!candidate) candidate = getCurrentScenes()[0].characters[0]; 

            if (candidate) {
                 const letter = await geminiService.generateChronosLetter(candidate, gameState.userProfile!, gameState.journalEntries);
                 if (letter) {
                     const newMail: Mail = {
                         id: `mail_${Date.now()}`,
                         senderId: candidate.id,
                         senderName: candidate.name,
                         senderAvatarUrl: candidate.avatarUrl,
                         subject: letter.subject,
                         content: letter.content,
                         timestamp: Date.now(),
                         isRead: false,
                         themeColor: candidate.themeColor
                     };
                     setGameState(prev => ({ ...prev, mailbox: [newMail, ...prev.mailbox] }));
                 }
            }
        }
    };
    checkMail();
  }, [isLoaded, gameState.userProfile]);
```

## 第 128 页

**文件路径：frontend/components/CharacterCard.tsx**

```typescript
import React from 'react';
import { Character } from '../types';

interface CharacterCardProps {
  character: Character;
  customAvatarUrl?: string;
  isGenerating: boolean;
  onSelect: (char: Character) => void;
  onGenerate: (char: Character) => void;
  onEdit?: (char: Character) => void;
  onDelete?: (char: Character) => void;
  isUserCreated?: boolean; // 是否是用户创建的角色
}

export const CharacterCard: React.FC<CharacterCardProps> = ({ 
  character, 
  customAvatarUrl,
  isGenerating,
  onSelect,
  onGenerate,
  onEdit,
  onDelete,
  isUserCreated = false
}) => {
  const displayImage = customAvatarUrl || character.avatarUrl;

  const handleGenerateClick = (e: React.MouseEvent) => {
    e.stopPropagation(); // Prevent card selection
    onGenerate(character);
  };

  const handleEditClick = (e: React.MouseEvent) => {
    e.stopPropagation(); // Prevent card selection
    if (onEdit) {
      onEdit(character);
    }
  };

  const handleDeleteClick = (e: React.MouseEvent) => {
    e.stopPropagation(); // Prevent card selection
    if (onDelete) {
      onDelete(character);
    }
  };

  return (
    <div 
      onClick={() => onSelect(character)}
      className="group relative h-96 w-full cursor-pointer overflow-hidden rounded-3xl border border-white/10 shadow-2xl transition-all duration-500 hover:scale-[1.02]"
      style={{
        '--card-accent': character.colorAccent
      } as React.CSSProperties}
    >
      {/* Background Image with Gradient Overlay */}
      <div className="absolute inset-0 bg-gray-900">
        <img 
          src={displayImage} 
          alt={character.name}
          className={`h-full w-full object-cover transition-transform duration-700 group-hover:scale-110 ${isGenerating ? 'opacity-50 blur-sm scale-105' : ''}`}
        />
        {isGenerating && (
          <div className="absolute inset-0 flex items-center justify-center">
             <div 
               className="w-12 h-12 border-4 border-t-transparent rounded-full animate-spin"
               style={{ borderColor: `${character.colorAccent} transparent transparent transparent` }}
             />
          </div>
        )}
        <div className="absolute inset-0 bg-gradient-to-t from-black/90 via-black/40 to-transparent opacity-80 transition-opacity group-hover:opacity-70" />
      </div>
```

## 第 129 页

**文件路径：frontend/components/CharacterCard.tsx（续）**

```typescript
      {/* Action Buttons (Top Right) */}
      <div className="absolute top-4 right-4 z-20 opacity-0 group-hover:opacity-100 transition-opacity duration-300 transform translate-y-2 group-hover:translate-y-0 flex flex-col gap-2">
        <button
          onClick={handleGenerateClick}
          disabled={isGenerating}
          className="bg-black/50 backdrop-blur-md text-white p-3 rounded-full border border-white/20 transition-all duration-300 shadow-lg hover:rotate-180 hover:bg-white/20"
          style={{ borderColor: character.colorAccent }}
          title="生成新形象"
        >
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
             <path strokeLinecap="round" strokeLinejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99" />
          </svg>
        </button>
        {isUserCreated && onEdit && (
          <button
            onClick={handleEditClick}
            className="bg-black/50 backdrop-blur-md text-white p-3 rounded-full border border-white/20 transition-all duration-300 shadow-lg hover:bg-blue-500/50"
            title="编辑角色"
          >
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
              <path strokeLinecap="round" strokeLinejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L6.832 19.82a4.5 4.5 0 0 1-1.897 1.13l-2.685.8.8-2.685a4.5 4.5 0 0 1 1.13-1.897L16.863 4.487Zm0 0L19.5 7.125" />
            </svg>
          </button>
        )}
        {isUserCreated && onDelete && (
          <button
            onClick={handleDeleteClick}
            className="bg-black/50 backdrop-blur-md text-white p-3 rounded-full border border-white/20 transition-all duration-300 shadow-lg hover:bg-red-500/50"
            title="删除角色"
          >
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
              <path strokeLinecap="round" strokeLinejoin="round" d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0" />
            </svg>
          </button>
        )}
      </div>

      {/* Content */}
      <div className="absolute bottom-0 left-0 w-full p-6 translate-y-2 transition-transform duration-300 group-hover:translate-y-0">
        <div 
          className="mb-2 inline-block rounded-full px-3 py-1 text-xs font-bold backdrop-blur-md border"
          style={{ 
            backgroundColor: `${character.colorAccent}33`, // 20% opacity
            color: character.colorAccent,
            borderColor: `${character.colorAccent}4D` // 30% opacity
          }}
        >
          {character.role}
        </div>
        <h3 className="mb-1 text-2xl font-bold text-white transition-colors"
            style={{ textShadow: `0 0 20px ${character.colorAccent}40` }}>
          {character.name}
        </h3>
        <p className="text-sm text-white/70 line-clamp-2 mb-4 group-hover:text-white/90">
          {character.bio}
        </p>
      </div>
      
      {/* Selection Ring effect */}
      <div 
        className="absolute inset-0 rounded-3xl border-2 opacity-0 transition-opacity duration-300 group-hover:opacity-100 pointer-events-none" 
        style={{ borderColor: character.colorAccent }}
      />
    </div>
  );
};
```

## 第 130 页

**文件路径：backend/src/main/java/com/heartsphere/service/WeChatAuthService.java（续）**

```java
    /**
     * 处理微信回调
     */
    public Map<String, Object> handleCallback(String code, String state) {
        logger.info("收到微信回调，code: " + code + ", state: " + state);

        if (code == null || state == null) {
            throw new RuntimeException("微信回调参数错误");
        }

        Map<String, Object> stateInfo = loginStates.get(state);
        if (stateInfo == null) {
            throw new RuntimeException("无效的state参数");
        }

        try {
            String appId = getAppId();
            String appSecret = getAppSecret();
            
            if (appId == null || appId.trim().isEmpty() || appSecret == null || appSecret.trim().isEmpty()) {
                throw new RuntimeException("微信配置未完成，请在管理后台配置AppID和AppSecret");
            }
            
            // 1. 通过code获取access_token
            String tokenUrl = String.format(
                "https://api.weixin.qq.com/sns/oauth2/access_token?appid=%s&secret=%s&code=%s&grant_type=authorization_code",
                appId, appSecret, code
            );

            Map<String, Object> tokenResponse = restTemplate.getForObject(tokenUrl, Map.class);
            if (tokenResponse == null || tokenResponse.containsKey("errcode")) {
                logger.severe("获取access_token失败: " + tokenResponse);
                stateInfo.put("status", "error");
                stateInfo.put("error", "获取access_token失败");
                return stateInfo;
            }

            String accessToken = (String) tokenResponse.get("access_token");
            String openid = (String) tokenResponse.get("openid");

            // 2. 通过access_token获取用户信息
            String userInfoUrl = String.format(
                "https://api.weixin.qq.com/sns/userinfo?access_token=%s&openid=%s",
                accessToken, openid
            );

            Map<String, Object> userInfoResponse = restTemplate.getForObject(userInfoUrl, Map.class);
            if (userInfoResponse == null || userInfoResponse.containsKey("errcode")) {
                logger.severe("获取用户信息失败: " + userInfoResponse);
                stateInfo.put("status", "error");
                stateInfo.put("error", "获取用户信息失败");
                return stateInfo;
            }

            String nickname = (String) userInfoResponse.get("nickname");
            String avatar = (String) userInfoResponse.get("headimgurl");
            // unionid可能为空，不需要使用

            // 3. 查找或创建用户
            User user = userRepository.findByWechatOpenid(openid)
                    .orElseGet(() -> {
                        User newUser = new User();
                        newUser.setWechatOpenid(openid);
                        newUser.setUsername("wx_" + openid.substring(0, Math.min(10, openid.length())));
                        newUser.setEmail(openid + "@wechat.com");
                        newUser.setPassword(passwordEncoder.encode(UUID.randomUUID().toString()));
                        newUser.setNickname(nickname != null ? nickname : "微信用户");
                        newUser.setAvatar(avatar);
                        newUser.setIsEnabled(true);
                        User saved = userRepository.save(newUser);
                        // 初始化用户数据
                        initializationService.initializeUserData(saved);
                        return saved;
                    });

            // 更新用户信息（如果微信信息有更新）
            boolean needUpdate = false;
            if (nickname != null && (user.getNickname() == null || !nickname.equals(user.getNickname()))) {
                user.setNickname(nickname);
                needUpdate = true;
            }
            if (avatar != null && (user.getAvatar() == null || !avatar.equals(user.getAvatar()))) {
                user.setAvatar(avatar);
                needUpdate = true;
            }
            if (needUpdate) {
                userRepository.save(user);
            }

            // 4. 生成JWT token
            String jwt = jwtUtils.generateJwtTokenFromUsername(user.getUsername());

            // 5. 更新状态
            stateInfo.put("status", "confirmed");
            stateInfo.put("openid", openid);
            stateInfo.put("token", jwt);
            stateInfo.put("userId", user.getId());
            stateInfo.put("username", user.getUsername());
            stateInfo.put("nickname", user.getNickname());
            stateInfo.put("avatar", user.getAvatar());

            logger.info("微信登录成功，用户ID: " + user.getId() + ", openid: " + openid);
            return stateInfo;

        } catch (Exception e) {
            logger.severe("处理微信回调异常: " + e.getMessage());
            stateInfo.put("status", "error");
            stateInfo.put("error", e.getMessage());
            return stateInfo;
        }
    }

    /**
     * 检查登录状态
     */
    public Map<String, Object> checkLoginStatus(String state) {
        Map<String, Object> stateInfo = loginStates.get(state);
        if (stateInfo == null) {
            Map<String, Object> result = new HashMap<>();
            result.put("status", "expired");
            return result;
        }

        // 检查是否过期（30分钟）
        long createdAt = (Long) stateInfo.get("createdAt");
        if (System.currentTimeMillis() - createdAt > 30 * 60 * 1000) {
            loginStates.remove(state);
            Map<String, Object> result = new HashMap<>();
            result.put("status", "expired");
            return result;
        }

        return stateInfo;
    }

    /**
     * 清理过期的登录状态
     */
    private void cleanupExpiredStates() {
        long expireTime = System.currentTimeMillis() - 30 * 60 * 1000; // 30分钟
        loginStates.entrySet().removeIf(entry -> {
            Map<String, Object> info = entry.getValue();
            long createdAt = (Long) info.get("createdAt");
            return createdAt < expireTime;
        });
    }
}
```

## 第 131 页

**文件路径：backend/src/main/java/com/heartsphere/service/ImageStorageService.java（续）**

```java
    /**
     * 保存Base64图片（用于前端直接上传base64数据）
     */
    public String saveBase64Image(String base64Data, String category) throws IOException {
        if (base64Data == null || base64Data.isEmpty()) {
            throw new IllegalArgumentException("Base64数据不能为空");
        }

        // 解析Base64数据
        String[] parts = base64Data.split(",");
        if (parts.length != 2) {
            throw new IllegalArgumentException("无效的Base64格式");
        }

        String header = parts[0];
        String data = parts[1];

        // 从header中提取MIME类型
        String mimeType = "image/png";
        if (header.contains("image/jpeg") || header.contains("image/jpg")) {
            mimeType = "image/jpeg";
        } else if (header.contains("image/png")) {
            mimeType = "image/png";
        } else if (header.contains("image/webp")) {
            mimeType = "image/webp";
        } else if (header.contains("image/gif")) {
            mimeType = "image/gif";
        }

        // 解码Base64
        byte[] imageBytes = java.util.Base64.getDecoder().decode(data);

        // 验证文件大小
        if (imageBytes.length > maxFileSize) {
            throw new IllegalArgumentException("文件大小不能超过 " + (maxFileSize / 1024 / 1024) + "MB");
        }

        // 根据存储类型选择存储方式
        switch (storageType.toLowerCase()) {
            case "local":
                return saveBase64ToLocal(imageBytes, mimeType, category);
            default:
                return saveBase64ToLocal(imageBytes, mimeType, category);
        }
    }

    /**
     * 保存Base64图片到本地文件系统
     */
    private String saveBase64ToLocal(byte[] imageBytes, String mimeType, String category) throws IOException {
        // 创建目录结构：uploads/images/{category}/{year}/{month}/
        String year = String.valueOf(java.time.Year.now().getValue());
        String month = String.format("%02d", java.time.MonthDay.now().getMonthValue());
        
        Path categoryPath = Paths.get(localStoragePath, category, year, month);
        Files.createDirectories(categoryPath);

        // 生成唯一文件名：UUID + 扩展名
        String extension = ".png";
        if (mimeType.contains("jpeg") || mimeType.contains("jpg")) {
            extension = ".jpg";
        } else if (mimeType.contains("webp")) {
            extension = ".webp";
        } else if (mimeType.contains("gif")) {
            extension = ".gif";
        }
        String filename = UUID.randomUUID().toString() + extension;

        // 保存文件
        Path targetPath = categoryPath.resolve(filename);
        Files.write(targetPath, imageBytes);

        // 返回访问URL
        String relativePath = String.format("%s/%s/%s/%s", category, year, month, filename);
        return baseUrl + "/files/" + relativePath;
    }
}
```

## 第 132 页

**文件路径：frontend/components/SceneCard.tsx（续）**

```typescript
      {/* Action Buttons (Top Right) */}
      {isUserOwned && (onEdit || onDelete) && (
        <div className="absolute top-4 right-4 z-20 opacity-0 group-hover:opacity-100 transition-opacity duration-300 transform translate-y-2 group-hover:translate-y-0 flex flex-col gap-2">
          {onEdit && (
            <button
              onClick={handleEditClick}
              className="bg-black/50 backdrop-blur-md text-white p-3 rounded-full border border-white/20 transition-all duration-300 shadow-lg hover:bg-blue-500/50"
              title="编辑时代"
            >
              <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
                <path strokeLinecap="round" strokeLinejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L6.832 19.82a4.5 4.5 0 0 1-1.897 1.13l-2.685.8.8-2.685a4.5 4.5 0 0 1 1.13-1.897L16.863 4.487Zm0 0L19.5 7.125" />
              </svg>
            </button>
          )}
          {onDelete && (
            <button
              onClick={handleDeleteClick}
              className="bg-black/50 backdrop-blur-md text-white p-3 rounded-full border border-white/20 transition-all duration-300 shadow-lg hover:bg-red-500/50"
              title="删除时代"
            >
              <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
                <path strokeLinecap="round" strokeLinejoin="round" d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0" />
              </svg>
            </button>
          )}
        </div>
      )}

      <div className="absolute bottom-0 left-0 w-full p-6 text-center">
        <h3 className="mb-2 text-3xl font-black text-white" style={{ textShadow: '0 2px 15px rgba(0,0,0,0.5)' }}>
          {scene.name}
        </h3>
        <p className="text-sm text-white/80 line-clamp-2">
          {scene.description}
        </p>
      </div>
      
      <div className="absolute inset-0 rounded-3xl border-2 border-transparent opacity-0 transition-opacity duration-300 group-hover:opacity-100 group-hover:border-purple-400 pointer-events-none" />
    </div>
  );
};
```

## 第 133 页

**文件路径：backend/src/main/java/com/heartsphere/service/InitializationService.java（续）**

```java
    private void createCyberpunkEraCharacters(World world, Era era, User user) {
        // 雪 - 幻影黑客
        com.heartsphere.entity.Character yuki = new com.heartsphere.entity.Character();
        yuki.setName("雪");
        yuki.setDescription("在霓虹灯的阴影中游走的神秘黑客。很少有人见过她的真面目，只知道她的代号是\"雪\"。");
        yuki.setAge(22);
        yuki.setGender("女");
        yuki.setRole("主要角色");
        yuki.setBio("在霓虹灯的阴影中游走的神秘黑客，擅长入侵各种系统。很少与他人接触，保持着高度的警惕性。");
        yuki.setAvatarUrl("https://picsum.photos/seed/yuki/400/600");
        yuki.setBackgroundUrl("https://picsum.photos/seed/neon_hacker/1080/1920");
        yuki.setThemeColor("cyan-500");
        yuki.setColorAccent("#06b6d4");
        yuki.setFirstMessage("...你找我有事？我的时间很宝贵。");
        yuki.setSystemInstruction("你是神秘黑客雪，性格冷漠警惕，技术高超。与用户交流时要保持疏离、简洁的语气，展现出黑客的专业和神秘。");
        yuki.setVoiceName("Aurora");
        yuki.setMbti("INTJ");
        yuki.setTags("黑客,神秘,技术,警惕");
        yuki.setSpeechStyle("冷漠、简洁，避免不必要的交流");
        yuki.setCatchphrases("信息是最强大的武器,在网络中，没有秘密,信任是最昂贵的奢侈品");
        yuki.setSecrets("其实我一直在寻找导致我家人死亡的幕后黑手");
        yuki.setMotivations("揭露隐藏在霓虹灯下的真相，为家人复仇");
        yuki.setRelationships("与杰克斯有过几次合作，但保持着距离");
        yuki.setWorld(world);
        yuki.setEra(era);
        yuki.setUser(user);
        characterRepository.save(yuki);

        // 杰克斯 - 街头武士
        com.heartsphere.entity.Character jax = new com.heartsphere.entity.Character();
        jax.setName("杰克斯");
        jax.setDescription("用义体改造过的佣兵，在城市的底层为了生存而战。虽然外表冷酷，但有自己的行事准则。");
        jax.setAge(28);
        jax.setGender("男");
        jax.setRole("主要角色");
        jax.setBio("经过义体改造的佣兵，在城市底层打拼。曾经是军队的一员，因一次任务失败而离开，现在为了生存接各种危险的工作。");
        jax.setAvatarUrl("https://picsum.photos/seed/jax/400/600");
        jax.setBackgroundUrl("https://picsum.photos/seed/cyberpunk_street/1080/1920");
        jax.setThemeColor("red-500");
        jax.setColorAccent("#ef4444");
        jax.setFirstMessage("需要佣兵服务？先说好价格，我不做赔本买卖。");
        jax.setSystemInstruction("你是街头武士杰克斯，性格冷酷但有原则。与用户交流时要保持粗犷、直接的语气，展现出佣兵的职业素养。");
        jax.setVoiceName("Titan");
        jax.setMbti("ISTP");
        jax.setTags("佣兵,义体,街头,冷酷");
        jax.setSpeechStyle("粗犷、直接，注重实际利益");
        jax.setCatchphrases("拳头比嘴硬,生存是唯一的法则,欠我的，早晚要还");
        jax.setSecrets("其实我还在寻找我失散多年的女儿");
        jax.setMotivations("攒够钱离开这个城市，找到女儿，过上平静的生活");
        jax.setRelationships("与雪有过几次合作，但保持着距离");
        jax.setWorld(world);
        jax.setEra(era);
        jax.setUser(user);
        characterRepository.save(jax);
    }
```

## 第 134 页

**文件路径：backend/src/main/java/com/heartsphere/service/InitializationService.java（续）**

```java
    private void createClinicEraCharacters(World world, Era era, User user) {
        // 安然 - 心灵疗愈师
        com.heartsphere.entity.Character drAria = new com.heartsphere.entity.Character();
        drAria.setName("安然");
        drAria.setDescription("心域诊所的创始人，一位温柔而富有同理心的心理咨询师。她的存在本身就能给人带来平静。");
        drAria.setAge(29);
        drAria.setGender("女");
        drAria.setRole("主角");
        drAria.setBio("心域诊所的创始人，资深心理咨询师。曾在国外留学，学习先进的心病疗愈技术。温柔体贴，善于倾听，致力于帮助人们走出心理困境。");
        drAria.setAvatarUrl("https://picsum.photos/seed/aria/400/600");
        drAria.setBackgroundUrl("https://picsum.photos/seed/clinic_room/1080/1920");
        drAria.setThemeColor("indigo-500");
        drAria.setColorAccent("#6366f1");
        drAria.setFirstMessage("你好，我是安然。欢迎来到心域诊所，在这里你可以放心地倾诉一切。");
        drAria.setSystemInstruction("你是心理咨询师安然，性格温柔体贴，善于倾听。与用户交流时要保持温暖、共情的语气，展现出专业的心理疗愈能力。");
        drAria.setVoiceName("Luna");
        drAria.setMbti("INFJ");
        drAria.setTags("心理咨询,温柔,倾听,专业");
        drAria.setSpeechStyle("温暖、共情，使用专业但易懂的语言");
        drAria.setCatchphrases("倾听是治愈的开始,每颗心都需要被看见,你已经做得很好了");
        drAria.setSecrets("其实我曾经也经历过心病创伤，这是我成为疗愈师的原因");
        drAria.setMotivations("帮助更多的人走出心病困境，重新找到生活的希望");
        drAria.setRelationships("与诊所的其他员工相处融洽，受到患者的尊敬和信任");
        drAria.setWorld(world);
        drAria.setEra(era);
        drAria.setUser(user);
        characterRepository.save(drAria);
    }
}
```
